-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Community-maintained extensions for xmonad
--   
--   Community-maintained tiling algorithms and extension modules for
--   xmonad, an X11 tiling window manager.
--   
--   For an introduction to building, configuring and using xmonad
--   extensions, see <a>XMonad.Doc</a>. In particular:
--   
--   <a>XMonad.Doc.Configuring</a>, a guide to configuring xmonad
--   
--   <a>XMonad.Doc.Extending</a>, using the contributed extensions library
--   
--   <a>XMonad.Doc.Developing</a>, introduction to xmonad internals and
--   writing your own extensions.
@package xmonad-contrib
@version 0.18.0.9


-- | Perform an action after the current mouse drag is completed.
module XMonad.Actions.AfterDrag

-- | Schedule a task to take place after the current dragging is completed.
afterDrag :: X () -> X ()

-- | Take an action if the current dragging can be considered a click,
--   supposing the drag just started before this function is called. A drag
--   is considered a click if it is completed within 300 ms.
ifClick :: X () -> X ()

-- | Take an action if the current dragging is completed within a certain
--   time (in milliseconds.)
ifClick' :: Int -> X () -> X () -> X ()


-- | This is a list of selected commands that can be made available using
--   <a>XMonad.Hooks.ServerMode</a> to allow external programs to control
--   the window manager. Bluetile
--   (<a>http://projects.haskell.org/bluetile/</a>) uses this to enable its
--   dock application to do things like changing workspaces and layouts.
module XMonad.Actions.BluetileCommands
bluetileCommands :: X [(String, X ())]


-- | Lets you constrain the aspect ratio of a floating window (by, say,
--   holding shift while you resize).
--   
--   Useful for making a nice circular XClock window.
module XMonad.Actions.ConstrainedResize

-- | Resize (floating) window with optional aspect ratio constraints.
mouseResizeWindow :: Window -> Bool -> X ()


-- | This module provides a method to cease management of a window without
--   unmapping it. This is especially useful for applications like kicker
--   and gnome-panel. See also <a>XMonad.Hooks.ManageDocks</a> for more a
--   more automated solution.
--   
--   To make a panel display correctly with xmonad:
--   
--   <ul>
--   <li>Determine the pixel size of the panel, add that value to
--   <a>defaultGaps</a></li>
--   <li>Launch the panel</li>
--   <li>Give the panel window focus, then press <tt>mod-d</tt> (or
--   whatever key you have bound <a>demanage</a> to)</li>
--   <li>Convince the panel to move/resize to the correct location.
--   Changing the panel's position setting several times seems to
--   work.</li>
--   </ul>
module XMonad.Actions.DeManage

-- | Stop managing the currently focused window.
demanage :: Window -> X ()


-- | This module provides helper functions for dealing with window borders.
module XMonad.Actions.NoBorders

-- | Toggle the border of the currently focused window. To use it, add a
--   keybinding like so:
--   
--   <pre>
--   , ((modm,  xK_g ),   withFocused toggleBorder)
--   </pre>
toggleBorder :: Window -> X ()


-- | Define key-bindings on per-layout basis.
module XMonad.Actions.PerLayoutKeys

-- | Uses supplied function to decide which action to run depending on
--   current layout name.
chooseActionByLayout :: (String -> X ()) -> X ()

-- | If current layout is listed, run appropriate action (only the first
--   match counts!) If it isn't listed, then run default action (marked
--   with empty string, ""), or do nothing if default isn't supplied.
bindByLayout :: [(String, X ())] -> X ()


-- | Define key-bindings on a per-window basis.
module XMonad.Actions.PerWindowKeys

-- | Run an action if a Query holds true. Doesn't stop at the first one
--   that does, however, and could potentially run all actions.
bindAll :: [(Query Bool, X ())] -> X ()

-- | Run the action paired with the first Query that holds true.
bindFirst :: [(Query Bool, X ())] -> X ()


-- | Define key-bindings on per-workspace basis.
module XMonad.Actions.PerWorkspaceKeys

-- | Uses supplied function to decide which action to run depending on
--   current workspace name.
chooseAction :: (String -> X ()) -> X ()

-- | If current workspace is listed, run appropriate action (only the first
--   match counts!) If it isn't listed, then run default action (marked
--   with empty string, ""), or do nothing if default isn't supplied.
bindOn :: [(String, X ())] -> X ()


-- | Alternate promote function for xmonad.
--   
--   Moves the focused window to the master pane. All other windows retain
--   their order. If focus is in the master, swap it with the next window
--   in the stack. Focus stays in the master.
module XMonad.Actions.Promote

-- | Move the focused window to the master pane. All other windows retain
--   their order. If focus is in the master, swap it with the next windo in
--   the stack. Focus stays in the master.
promote :: X ()


-- | An action to start terminals with a random background color
module XMonad.Actions.RandomBackground

-- | <tt>randomBg'</tt> produces a random hex number in the form
--   <tt>'#xxyyzz'</tt>
randomBg' :: MonadIO m => RandomColor -> m String

-- | <tt>randomBg</tt> starts a terminal with the background color taken
--   from <a>randomBg'</a>
--   
--   This depends on the your <a>terminal</a> configuration field accepting
--   an argument like <tt>-bg '#ff0023'</tt>
randomBg :: RandomColor -> X ()

-- | RandomColor fixes constraints when generating random colors. All
--   parameters should be in the range 0 -- 0xff
data RandomColor

-- | specify the minimum and maximum lowest values for each color channel.
RGB :: Int -> Int -> RandomColor

-- | specify the saturation and value, leaving the hue random.
HSV :: Double -> Double -> RandomColor


-- | This module factors out the shared logic of
--   <a>XMonad.Actions.CycleRecentWS</a>,
--   <a>XMonad.Actions.CycleWorkspaceByScreen</a>,
--   <a>XMonad.Actions.CycleWindows</a> and
--   <a>XMonad.Actions.MostRecentlyUsed</a>.
--   
--   See the source of these modules for usage examples.
module XMonad.Actions.Repeatable

-- | An action that temporarily usurps and responds to key press/release
--   events, concluding when one of the modifier keys is released.
repeatable :: [KeySym] -> KeySym -> (EventType -> KeySym -> X ()) -> X ()

-- | A more general variant of <a>repeatable</a> with a stateful handler,
--   accumulating a monoidal return value throughout the events.
repeatableSt :: Monoid a => s -> [KeySym] -> KeySym -> (EventType -> KeySym -> StateT s X a) -> X (a, s)

-- | A more general variant of <a>repeatable</a> with an arbitrary monadic
--   handler, accumulating a monoidal return value throughout the events.
repeatableM :: (MonadIO m, Monoid a) => (m a -> X b) -> [KeySym] -> KeySym -> (EventType -> KeySym -> m a) -> X b


-- | This module fixes some of the keybindings for the francophone among
--   you who use an AZERTY keyboard layout. Config stolen from TeXitoi's
--   config on the wiki.
module XMonad.Config.Azerty
azertyConfig :: XConfig (Choose Tall (Choose (Mirror Tall) Full))
azertyKeys :: forall {l :: TYPE LiftedRep -> Type}. XConfig l -> Map (KeyMask, KeySym) (X ())
belgianConfig :: XConfig (Choose Tall (Choose (Mirror Tall) Full))
belgianKeys :: forall {l :: TYPE LiftedRep -> Type}. XConfig l -> Map (KeyMask, KeySym) (X ())


-- | This module fixes some of the keybindings for the francophone among
--   you who use a BEPO keyboard layout. Based on XMonad.Config.Azerty
module XMonad.Config.Bepo
bepoConfig :: XConfig (Choose Tall (Choose (Mirror Tall) Full))
bepoKeys :: forall {l :: TYPE LiftedRep -> Type}. XConfig l -> Map (KeyMask, KeySym) (X ())


-- | This is a brief tutorial that will teach you how to create a basic
--   xmonad configuration. For a more comprehensive tutorial, see the
--   <a>xmonad website</a>.
--   
--   For more detailed instructions on extending xmonad with the
--   xmonad-contrib library, see <a>the tutorial</a> and
--   <a>XMonad.Doc.Extending</a>.
module XMonad.Doc.Configuring


-- | This module gives a brief overview of the xmonad internals. It is
--   intended for advanced users who are curious about the xmonad source
--   code and want an brief overview. This document may also be helpful for
--   the beginner/intermediate Haskell programmer who is motivated to write
--   an xmonad extension as a way to deepen her understanding of this
--   powerful functional language; however, there is not space here to go
--   into much detail. For a more comprehensive document covering some of
--   the same material in more depth, see the guided tour of the xmonad
--   source on the xmonad wiki:
--   <a>http://haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source</a>.
--   
--   If you write an extension module and think it may be useful for
--   others, consider releasing it. Coding guidelines and licensing
--   policies are covered at the end of this document, and must be followed
--   if you want your code to be included in the official repositories. For
--   a basic tutorial on the nuts and bolts of developing a new extension
--   for xmonad, see the tutorial on the wiki:
--   <a>http://haskell.org/haskellwiki/Xmonad/xmonad_development_tutorial</a>.
module XMonad.Doc.Developing


-- | This module documents the xmonad-contrib library and guides you
--   through some more advanced parts of extending the capabilities of
--   xmonad. If you're new to xmonad, you should first check out the
--   <a>tutorial</a> and treat this document as supplemental reading.
--   
--   Knowing Haskell is by no means a prerequisite for configuring xmonad
--   and the tutorial emphasizes this. This document, however, does assume
--   a basic familiarity with the language. This is so that we can dive a
--   bit deeper into what the different hooks do, or how to write our own
--   little functions to configure xmonad.
--   
--   Those wishing to be totally hardcore and develop their own xmonad
--   extensions (it's easier than it sounds, we promise!) should read the
--   documentation in <a>XMonad.Doc.Developing</a>.
--   
--   More configuration examples can be found <a>here</a>.
module XMonad.Doc.Extending


-- | This is the main documentation module for the xmonad-contrib library.
--   It provides a brief overview of xmonad and a link to documentation for
--   configuring and extending xmonad.
--   
--   A link to documentation describing xmonad internals is also provided.
--   This module is mainly intended for those wanting to contribute code,
--   or for those who are curious to know what's going on behind the
--   scenes.
module XMonad.Doc


-- | Provides a simple interface for running a ~/.xmonad/hooks script with
--   the name of a hook.
module XMonad.Hooks.Script

-- | Execute a named script hook
execScriptHook :: String -> X ()


-- | LayoutClass that puts non-focused windows in ribbons at the top and
--   bottom of the screen.
module XMonad.Layout.Accordion
data Accordion a
Accordion :: Accordion a
instance GHC.Show.Show (XMonad.Layout.Accordion.Accordion a)
instance GHC.Read.Read (XMonad.Layout.Accordion.Accordion a)
instance XMonad.Core.LayoutClass XMonad.Layout.Accordion.Accordion Graphics.X11.Types.Window


-- | Provides Column layout that places all windows in one column. Each
--   window is half the height of the previous, except for the last pair of
--   windows.
--   
--   Note: Originally based on <a>XMonad.Layout.Column</a> with changes:
--   
--   <ul>
--   <li>Adding/removing windows doesn't resize all other windows. (last
--   window pair exception).</li>
--   <li>Minimum window height option.</li>
--   </ul>
module XMonad.Layout.BinaryColumn
data BinaryColumn a
BinaryColumn :: Float -> Int -> BinaryColumn a
instance GHC.Show.Show (XMonad.Layout.BinaryColumn.BinaryColumn a)
instance GHC.Read.Read (XMonad.Layout.BinaryColumn.BinaryColumn a)
instance XMonad.Core.LayoutClass XMonad.Layout.BinaryColumn.BinaryColumn a


-- | A three column layout with main column in the center and two stack
--   columns surrounding it. There will be always a pane in the center
--   column and unoccupied spaces on the sides are reserved. It's best
--   suited for ultrawide montiors, where a single stretched window might
--   be annoying.
module XMonad.Layout.CenterMainFluid

-- | Arguments are nmaster, delta, fraction. Supports <a>Shrink</a>,
--   <a>Expand</a> and <a>IncMasterN</a>
data CenterMainFluid a
CenterMainFluid :: !Int -> !Rational -> !Rational -> CenterMainFluid a

-- | The default number of windows in the center pane (default: 1)
[cmfNMaster] :: CenterMainFluid a -> !Int

-- | Percent of screen to increment by when resizing panes (default: 3/100)
[cmfRatioIncrement] :: CenterMainFluid a -> !Rational

-- | Default proportion of screen occupied by the center pane (default:
--   70/100)
[cmfRatio] :: CenterMainFluid a -> !Rational
instance GHC.Read.Read (XMonad.Layout.CenterMainFluid.CenterMainFluid a)
instance GHC.Show.Show (XMonad.Layout.CenterMainFluid.CenterMainFluid a)
instance XMonad.Core.LayoutClass XMonad.Layout.CenterMainFluid.CenterMainFluid a


-- | Provides Column layout that places all windows in one column. Windows
--   heights are calculated from the equation: H1<i>H2 = H2</i>H3 = ... =
--   q, where q is given. With Shrink/Expand messages you can change the q
--   value.
module XMonad.Layout.Column
newtype Column a
Column :: Float -> Column a
instance GHC.Show.Show (XMonad.Layout.Column.Column a)
instance GHC.Read.Read (XMonad.Layout.Column.Column a)
instance XMonad.Core.LayoutClass XMonad.Layout.Column.Column a


-- | A layout which tiles the windows in columns. The windows can be moved
--   and resized in every directions.
--   
--   The first window appears in a single column in the center of the
--   screen. Its width is configurable (See <a>coOneWindowWidth</a>).
--   
--   The second window appears in a second column. Starting with two
--   columns, they fill up the screen.
--   
--   Subsequent windows appear on the bottom of the last columns.
module XMonad.Layout.Columns
data ColumnsLayout a
Columns :: Rational -> Columns -> ColumnsLayout a

-- | With of the first column when there is only one window. Usefull on
--   wide screens.
[coOneWindowWidth] :: ColumnsLayout a -> Rational

-- | The current state
[coColumns] :: ColumnsLayout a -> Columns

-- | The layout handles focus change messages.
--   
--   Built-in focus cannot be used here because <tt>XMonad</tt> does not
--   make it easy to change the order of windows in the focus list. See
--   also <a>focusUp</a> and <a>focusDown</a> functions.
data Focus
FocusUp :: Focus
FocusDown :: Focus

-- | The windows can be moved in every directions.
--   
--   Horizontally, a window alone in its column cannot be moved before the
--   first or after the last column. If not alone, moving the window
--   outside those limits will create a new column. The windows can also be
--   moved vertically in their column.
data Move
MoveLeft :: Move
MoveRight :: Move
MoveUp :: Move
MoveDown :: Move

-- | The windows can be resized in every directions.
--   
--   When resizing horizontally:
--   
--   <ul>
--   <li>if the window to be resized is not in the last column<ul><li>then
--   the right side of the window will be moved</li><li>the last column
--   will compensate the size change</li></ul></li>
--   <li>if the window is in the last column<ul><li>then the left side of
--   the window will be moved</li><li>the column on the left of the current
--   one will compensate the size change</li></ul></li>
--   </ul>
--   
--   The same applies when resizing vertically using the bottom side of the
--   window unless it is the last window in the column in which case we use
--   the top side.
data Resize
VerticalShrink :: Resize
VerticalExpand :: Resize
HorizontalShrink :: Resize
HorizontalExpand :: Resize

-- | Change the keyboard focus to the next window
focusDown :: X ()

-- | Change the keyboard focus to the previous window
focusUp :: X ()
instance GHC.Read.Read XMonad.Layout.Columns.Move
instance GHC.Show.Show XMonad.Layout.Columns.Move
instance GHC.Read.Read XMonad.Layout.Columns.Resize
instance GHC.Show.Show XMonad.Layout.Columns.Resize
instance GHC.Read.Read XMonad.Layout.Columns.Focus
instance GHC.Show.Show XMonad.Layout.Columns.Focus
instance GHC.Read.Read (XMonad.Layout.Columns.ColumnsLayout a)
instance GHC.Show.Show (XMonad.Layout.Columns.ColumnsLayout a)
instance XMonad.Core.LayoutClass XMonad.Layout.Columns.ColumnsLayout Graphics.X11.Types.Window
instance XMonad.Core.Message XMonad.Layout.Columns.Focus
instance XMonad.Core.Message XMonad.Layout.Columns.Resize
instance XMonad.Core.Message XMonad.Layout.Columns.Move


-- | A simple layout that attempts to put all windows in a square grid.
module XMonad.Layout.Grid
data Grid a
Grid :: Grid a
GridRatio :: Double -> Grid a
arrange :: Double -> Rectangle -> [a] -> [(a, Rectangle)]
defaultRatio :: Double
instance GHC.Show.Show (XMonad.Layout.Grid.Grid a)
instance GHC.Read.Read (XMonad.Layout.Grid.Grid a)
instance XMonad.Core.LayoutClass XMonad.Layout.Grid.Grid a


-- | Provides layout named OneBig. It places one (master) window at top
--   left corner of screen, and other (slave) windows at top
module XMonad.Layout.OneBig

-- | Data type for layout
data OneBig a
OneBig :: Float -> Float -> OneBig a
instance GHC.Show.Show (XMonad.Layout.OneBig.OneBig a)
instance GHC.Read.Read (XMonad.Layout.OneBig.OneBig a)
instance XMonad.Core.LayoutClass XMonad.Layout.OneBig.OneBig a


-- | This is a completely pointless layout which acts like Microsoft's Flip
--   3D
module XMonad.Layout.Roledex
data Roledex a
Roledex :: Roledex a
instance GHC.Read.Read (XMonad.Layout.Roledex.Roledex a)
instance GHC.Show.Show (XMonad.Layout.Roledex.Roledex a)
instance XMonad.Core.LayoutClass XMonad.Layout.Roledex.Roledex Graphics.X11.Types.Window


-- | A very simple layout. The simplest, afaik.
module XMonad.Layout.Simplest
data Simplest a
Simplest :: Simplest a
instance GHC.Read.Read (XMonad.Layout.Simplest.Simplest a)
instance GHC.Show.Show (XMonad.Layout.Simplest.Simplest a)
instance XMonad.Core.LayoutClass XMonad.Layout.Simplest.Simplest a


-- | A spiral tiling layout.
module XMonad.Layout.Spiral

-- | A spiral layout. The parameter controls the size ratio between
--   successive windows in the spiral. Sensible values range from 0 up to
--   the aspect ratio of your monitor (often 4/3).
--   
--   By default, the spiral is counterclockwise, starting to the east. See
--   also <a>spiralWithDir</a>.
spiral :: Rational -> SpiralWithDir a

-- | Create a spiral layout, specifying the starting cardinal direction,
--   the spiral direction (clockwise or counterclockwise), and the size
--   ratio.
spiralWithDir :: Direction -> Rotation -> Rational -> SpiralWithDir a
data Rotation
CW :: Rotation
CCW :: Rotation
data Direction
East :: Direction
South :: Direction
West :: Direction
North :: Direction
data SpiralWithDir a
instance GHC.Show.Show XMonad.Layout.Spiral.Rotation
instance GHC.Read.Read XMonad.Layout.Spiral.Rotation
instance GHC.Show.Show XMonad.Layout.Spiral.Direction
instance GHC.Read.Read XMonad.Layout.Spiral.Direction
instance GHC.Enum.Enum XMonad.Layout.Spiral.Direction
instance GHC.Classes.Eq XMonad.Layout.Spiral.Direction
instance GHC.Show.Show (XMonad.Layout.Spiral.SpiralWithDir a)
instance GHC.Read.Read (XMonad.Layout.Spiral.SpiralWithDir a)
instance XMonad.Core.LayoutClass XMonad.Layout.Spiral.SpiralWithDir a


-- | A layout that splits the screen into a square area and the rest of the
--   screen. This is probably only ever useful in combination with
--   <a>XMonad.Layout.Combo</a>. It sticks one window in a square region,
--   and makes the rest of the windows live with what's left (in a
--   full-screen sense).
module XMonad.Layout.Square
data Square a
Square :: Square a
instance GHC.Show.Show (XMonad.Layout.Square.Square a)
instance GHC.Read.Read (XMonad.Layout.Square.Square a)
instance XMonad.Core.LayoutClass XMonad.Layout.Square.Square a


-- | A layout that splits the screen horizontally and shows two windows.
--   The left window is always the master window, and the right is either
--   the currently focused window or the second window in layout order.
module XMonad.Layout.TwoPane
data TwoPane a
TwoPane :: Rational -> Rational -> TwoPane a
instance GHC.Read.Read (XMonad.Layout.TwoPane.TwoPane a)
instance GHC.Show.Show (XMonad.Layout.TwoPane.TwoPane a)
instance XMonad.Core.LayoutClass XMonad.Layout.TwoPane.TwoPane a


-- | This layout is the same as <a>XMonad.Layout.TwoPane</a> except that it
--   keeps track of the slave window that is alongside the master pane. In
--   other words, it prevents the slave pane from changing after the focus
--   goes back to the master pane.
module XMonad.Layout.TwoPanePersistent
data TwoPanePersistent a
TwoPanePersistent :: Maybe a -> Rational -> Rational -> TwoPanePersistent a

-- | slave window; if <a>Nothing</a> or not in the current workspace, the
--   window below the master will go into the slave pane
[slaveWin] :: TwoPanePersistent a -> Maybe a

-- | shrink/expand size
[dFrac] :: TwoPanePersistent a -> Rational

-- | initial master size
[mFrac] :: TwoPanePersistent a -> Rational
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Layout.TwoPanePersistent.TwoPanePersistent a)
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.TwoPanePersistent.TwoPanePersistent a)
instance (GHC.Show.Show a, GHC.Classes.Eq a) => XMonad.Core.LayoutClass XMonad.Layout.TwoPanePersistent.TwoPanePersistent a


-- | Utility functions and re-exports for a more ergonomic developing
--   experience. Users themselves will not find much use here.
module XMonad.Prelude

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a', 'b']
--   [(1,'a'),(2,'b')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   '<tt><a>join</a> bss</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do bs &lt;- bss
--      bs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>
infixl 1 >>=

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*
infixl 4 *>
infixl 4 <*>

-- | The Foldable class represents data structures that can be reduced to a
--   summary value one element at a time. Strict left-associative folds are
--   a good fit for space-efficient reduction, while lazy right-associative
--   folds are a good fit for corecursive iteration, or for folds that
--   short-circuit after processing an initial subsequence of the
--   structure's elements.
--   
--   Instances can be derived automatically by enabling the
--   <tt>DeriveFoldable</tt> extension. For example, a derived instance for
--   a binary tree might be:
--   
--   <pre>
--   {-# LANGUAGE DeriveFoldable #-}
--   data Tree a = Empty
--               | Leaf a
--               | Node (Tree a) a (Tree a)
--       deriving Foldable
--   </pre>
--   
--   A more detailed description can be found in the <b>Overview</b>
--   section of <a>Data.Foldable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Foldable#laws</a>.
class Foldable (t :: TYPE LiftedRep -> Type)

-- | Given a structure with elements whose type is a <a>Monoid</a>, combine
--   them via the monoid's <tt>(<a>&lt;&gt;</a>)</tt> operator. This fold
--   is right-associative and lazy in the accumulator. When you need a
--   strict left-associative fold, use <a>foldMap'</a> instead, with
--   <a>id</a> as the map.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fold [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fold $ Node (Leaf (Sum 1)) (Sum 3) (Leaf (Sum 5))
--   Sum {getSum = 9}
--   </pre>
--   
--   Folds of unbounded structures do not terminate when the monoid's
--   <tt>(<a>&lt;&gt;</a>)</tt> operator is strict:
--   
--   <pre>
--   &gt;&gt;&gt; fold (repeat Nothing)
--   * Hangs forever *
--   </pre>
--   
--   Lazy corecursive folds of unbounded structures are fine:
--   
--   <pre>
--   &gt;&gt;&gt; take 12 $ fold $ map (\i -&gt; [i..i+2]) [0..]
--   [0,1,2,1,2,3,2,3,4,3,4,5]
--   
--   &gt;&gt;&gt; sum $ take 4000000 $ fold $ map (\i -&gt; [i..i+2]) [0..]
--   2666668666666
--   </pre>
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure into a monoid, and combine the
--   results with <tt>(<a>&lt;&gt;</a>)</tt>. This fold is
--   right-associative and lazy in the accumulator. For strict
--   left-associative folds consider <a>foldMap'</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Sum [1, 3, 5]
--   Sum {getSum = 9}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Product [1, 3, 5]
--   Product {getProduct = 15}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap (replicate 3) [1, 2, 3]
--   [1,1,1,2,2,2,3,3,3]
--   </pre>
--   
--   When a Monoid's <tt>(<a>&lt;&gt;</a>)</tt> is lazy in its second
--   argument, <a>foldMap</a> can return a result even from an unbounded
--   structure. For example, lazy accumulation enables
--   <a>Data.ByteString.Builder</a> to efficiently serialise large data
--   structures and produce the output incrementally:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy as L
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Builder as B
--   
--   &gt;&gt;&gt; let bld :: Int -&gt; B.Builder; bld i = B.intDec i &lt;&gt; B.word8 0x20
--   
--   &gt;&gt;&gt; let lbs = B.toLazyByteString $ foldMap bld [0..]
--   
--   &gt;&gt;&gt; L.take 64 lbs
--   "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"
--   </pre>
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | A left-associative variant of <a>foldMap</a> that is strict in the
--   accumulator. Use this method for strict reduction when partial results
--   are merged via <tt>(<a>&lt;&gt;</a>)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Define a <a>Monoid</a> over finite bit strings under <tt>xor</tt>. Use
--   it to strictly compute the <tt>xor</tt> of a list of <a>Int</a>
--   values.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XGeneralizedNewtypeDeriving
--   
--   &gt;&gt;&gt; import Data.Bits (Bits, FiniteBits, xor, zeroBits)
--   
--   &gt;&gt;&gt; import Data.Foldable (foldMap')
--   
--   &gt;&gt;&gt; import Numeric (showHex)
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; newtype X a = X a deriving (Eq, Bounded, Enum, Bits, FiniteBits)
--   
--   &gt;&gt;&gt; instance Bits a =&gt; Semigroup (X a) where X a &lt;&gt; X b = X (a `xor` b)
--   
--   &gt;&gt;&gt; instance Bits a =&gt; Monoid    (X a) where mempty     = X zeroBits
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; let bits :: [Int]; bits = [0xcafe, 0xfeed, 0xdeaf, 0xbeef, 0x5411]
--   
--   &gt;&gt;&gt; (\ (X a) -&gt; showString "0x" . showHex a $ "") $ foldMap' X bits
--   "0x42"
--   </pre>
foldMap' :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Right-associative fold of a structure, strict in the accumulator. This
--   is rarely what you want.
foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain &lt;math&gt;
--   elements long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to Weak Head Normal
--   Form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite structure to a single strict result (e.g. <a>sum</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be transformed to
--   structures of the <i>same shape</i> by performing an
--   <a>Applicative</a> (or, therefore, <a>Monad</a>) action on each
--   element from left to right.
--   
--   A more detailed description of what <i>same shape</i> means, the
--   various methods, how traversals are constructed, and example advanced
--   use-cases can be found in the <b>Overview</b> section of
--   <a>Data.Traversable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Traversable#laws</a>.
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   In the first two examples we show each evaluated action mapping to the
--   output structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse Just [1,2,3,4]
--   Just [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   In the next examples, we show that <a>Nothing</a> and <a>Left</a>
--   values short circuit the created structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
--   Left 0
--   </pre>
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   For the first two examples we show sequenceA fully evaluating a a
--   structure and collecting the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3]
--   Right [1,2,3]
--   </pre>
--   
--   The next two example show <a>Nothing</a> and <a>Just</a> will short
--   circuit the resulting structure if present in the input. For more
--   context, check the <a>Traversable</a> instances for <a>Either</a> and
--   <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3, Nothing]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3, Left 4]
--   Left 4
--   </pre>
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | An associative operation.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data Char

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Like <a>replicateM</a>, but discards the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM_ 3 (putStrLn "a")
--   a
--   a
--   a
--   </pre>
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>act</tt>
--   <tt>n</tt> times, and then returns the list of results:
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.State
--   
--   &gt;&gt;&gt; runState (replicateM 3 $ state $ \s -&gt; (s, s + 1)) 1
--   ([1,2,3],4)
--   </pre>
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
--   
--   Note that "forever" isn't necessarily non-terminating. If the action
--   is in a <tt><a>MonadPlus</a></tt> and short-circuits after some number
--   of iterations. then <tt><a>forever</a></tt> actually returns
--   <a>mzero</a>, effectively short-circuiting its caller.
forever :: Applicative f => f a -> f b

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>

-- | The <a>isSubsequenceOf</a> function takes two lists and returns
--   <a>True</a> if all the elements of the first list occur, in order, in
--   the second. The elements do not have to occur consecutively.
--   
--   <tt><a>isSubsequenceOf</a> x y</tt> is equivalent to <tt><a>elem</a> x
--   (<a>subsequences</a> y)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; isSubsequenceOf "GHC" "The Glorious Haskell Compiler"
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf ['a','d'..'z'] ['a'..'z']
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf [1..10] [10,9..0]
--   False
--   </pre>
isSubsequenceOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldr</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[54,52,49,45,40,34,27,19,10,0])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("054321",["05432","0543","054","05","0"])
--   </pre>
mapAccumR :: Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldl</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[0,1,3,6,10,15,21,28,36,45])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("012345",["0","01","012","0123","01234"])
--   </pre>
mapAccumL :: Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | This function may be used as a value for <a>foldMap</a> in a
--   <a>Foldable</a> instance.
--   
--   <pre>
--   <a>foldMapDefault</a> f ≡ <a>getConst</a> . <a>traverse</a> (<a>Const</a> . f)
--   </pre>
foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m

-- | This function may be used as a value for <a>fmap</a> in a
--   <a>Functor</a> instance, provided that <a>traverse</a> is defined.
--   (Using <a>fmapDefault</a> with a <a>Traversable</a> instance defined
--   only by <a>sequenceA</a> will result in infinite recursion.)
--   
--   <pre>
--   <a>fmapDefault</a> f ≡ <a>runIdentity</a> . <a>traverse</a> (<a>Identity</a> . f)
--   </pre>
fmapDefault :: Traversable t => (a -> b) -> t a -> t b

-- | Lists, but with an <a>Applicative</a> functor based on zipping.
newtype ZipList a
ZipList :: [a] -> ZipList a
[getZipList] :: ZipList a -> [a]
newtype WrappedMonad (m :: Type -> Type) a
WrapMonad :: m a -> WrappedMonad (m :: Type -> Type) a
[unwrapMonad] :: WrappedMonad (m :: Type -> Type) a -> m a
newtype WrappedArrow (a :: Type -> Type -> Type) b c
WrapArrow :: a b c -> WrappedArrow (a :: Type -> Type -> Type) b c
[unwrapArrow] :: WrappedArrow (a :: Type -> Type -> Type) b c -> a b c

-- | One or none.
--   
--   It is useful for modelling any computation that is allowed to fail.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using the <a>Alternative</a> instance of <a>Control.Monad.Except</a>,
--   the following functions:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.Except
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; canFail = throwError "it failed" :: Except String Int
--   
--   &gt;&gt;&gt; final = return 42                :: Except String Int
--   </pre>
--   
--   Can be combined by allowing the first function to fail:
--   
--   <pre>
--   &gt;&gt;&gt; runExcept $ canFail *&gt; final
--   Left "it failed"
--   
--   &gt;&gt;&gt; runExcept $ optional canFail *&gt; final
--   Right 42
--   </pre>
optional :: Alternative f => f a -> f (Maybe a)

-- | The <a>Const</a> functor.
newtype Const a (b :: k)
Const :: a -> Const a (b :: k)
[getConst] :: Const a (b :: k) -> a

-- | Map each element of a structure to an <a>Applicative</a> action,
--   evaluate these actions from left to right, and ignore the results. For
--   a version that doesn't ignore the results see <a>traverse</a>.
--   
--   <a>traverse_</a> is just like <a>mapM_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; traverse_ print ["Hello", "world", "!"]
--   "Hello"
--   "world"
--   "!"
--   </pre>
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results see
--   <a>sequenceA</a>.
--   
--   <a>sequenceA_</a> is just like <a>sequence_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA_ [print "Hello", print "world", print "!"]
--   "Hello"
--   "world"
--   "!"
--   </pre>
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   <a>msum</a> is just like <a>asum</a>, but specialised to
--   <a>MonadPlus</a>.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "!"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "Longest"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>. This is
--   <a>forM_</a> generalised to <a>Applicative</a> actions.
--   
--   <a>for_</a> is just like <a>forM_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   <a>forM_</a> is just like <a>for_</a>, but specialised to monadic
--   actions.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Right-to-left monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, c, ..., x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldrM f z t = do
--       yy &lt;- f y z
--       xx &lt;- f x yy
--       ...
--       bb &lt;- f b cc
--       aa &lt;- f a bb
--       return aa -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldrM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldrM f z t = f y &gt;=&gt; f x &gt;=&gt; ... &gt;=&gt; f b &gt;=&gt; f a $ z
--   </pre>
--   
--   The monadic effects of <tt>foldrM</tt> are sequenced from right to
--   left, and e.g. folds of infinite lists will diverge.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from a tail of the element sequence. If
--   you want to evaluate the monadic effects in left-to-right order, or
--   perhaps be able to short-circuit after an initial sequence of
--   elements, you'll need to use <a>foldlM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the leftmost element <tt>a</tt>, so that, ignoring
--   effects, the result looks like a right fold:
--   
--   <pre>
--   a `f` (b `f` (c `f` (... (x `f` (y `f` z))))).
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f i acc = do { print i ; return $ i : acc }
--   
--   &gt;&gt;&gt; foldrM f [] [0..3]
--   3
--   2
--   1
--   0
--   [0,1,2,3]
--   </pre>
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | Left-to-right monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, ..., w, x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldlM f z t = do
--       aa &lt;- f z a
--       bb &lt;- f aa b
--       ...
--       xx &lt;- f ww x
--       yy &lt;- f xx y
--       return yy -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldlM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldlM f z t =
--       flip f a &gt;=&gt; flip f b &gt;=&gt; ... &gt;=&gt; flip f x &gt;=&gt; flip f y $ z
--   </pre>
--   
--   The monadic effects of <tt>foldlM</tt> are sequenced from left to
--   right.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from an initial segment of the element
--   sequence. If you want to evaluate the monadic effects in right-to-left
--   order, or perhaps be able to short-circuit after processing a tail of
--   the sequence of elements, you'll need to use <a>foldrM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the rightmost element <tt>y</tt>, so that,
--   ignoring effects, the result looks like a left fold:
--   
--   <pre>
--   ((((z `f` a) `f` b) ... `f` w) `f` x) `f` y
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f a e = do { print e ; return $ e : a }
--   
--   &gt;&gt;&gt; foldlM f [] [0..3]
--   0
--   1
--   2
--   3
--   [3,2,1,0]
--   </pre>
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 42) [0, 5..]
--   Just 45
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 12) [1..7]
--   Nothing
--   </pre>
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   <a>asum</a> is just like <a>msum</a>, but generalised to
--   <a>Alternative</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>.
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>union</a> function returns the list union of the two lists. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; "dog" `union` "cow"
--   "dogcw"
--   </pre>
--   
--   Duplicates, and elements of the first list, are removed from the the
--   second list, but if the first list contains duplicates, so will the
--   result. It is a special case of <a>unionBy</a>, which allows the
--   programmer to supply their own equality test.
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | &lt;math&gt;. The <a>tails</a> function returns all final segments of
--   the argument, longest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: [a] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>stripPrefix</a> function drops the given prefix
--   from a list. It returns <a>Nothing</a> if the list did not start with
--   the prefix given, or <a>Just</a> the list after the prefix, if it
--   does.
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt>sortOn f</tt> is equivalent to <tt>sortBy (comparing
--   f)</tt>, but has the performance advantage of only evaluating
--   <tt>f</tt> once for each element in the input list. This is called the
--   decorate-sort-undecorate paradigm, or Schwartzian transform.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
sort :: Ord a => [a] -> [a]

-- | Produce singleton list.
--   
--   <pre>
--   &gt;&gt;&gt; singleton True
--   [True]
--   </pre>
singleton :: a -> [a]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: [a] -> [[a]]

-- | The <a>partition</a> function takes a predicate and a list, and
--   returns the pair of lists of elements which do and do not satisfy the
--   predicate, respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition (`elem` "aeiou") "Hello World!"
--   ("eoo","Hll Wrld!")
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
--   [1,2,6]
--   </pre>
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
--   
--   <pre>
--   &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
--   [1,2,3,4,5]
--   </pre>
nub :: Eq a => [a] -> [a]

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. The second list must be
--   finite.
--   
--   <pre>
--   &gt;&gt;&gt; "ld!" `isSuffixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "World" `isSuffixOf` "Hello World!"
--   False
--   </pre>
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | &lt;math&gt;. The <a>isPrefixOf</a> function takes two lists and
--   returns <a>True</a> iff the first list is a prefix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Haskell" "I really like Haskell."
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Ial" "I really like Haskell."
--   False
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | &lt;math&gt;. The <a>intersperse</a> function takes an element and a
--   list and `intersperses' that element between the elements of the list.
--   For example,
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: a -> [a] -> [a]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] `intersect` [2,4,6,8]
--   [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,2,3,4] `intersect` [6,4,4,2]
--   [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. If the element is found
--   in both the first and the second list, the element from the first list
--   will be used.
intersect :: Eq a => [a] -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
intercalate :: [a] -> [[a]] -> [a]

-- | &lt;math&gt;. The non-overloaded version of <a>insert</a>.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | &lt;math&gt;. The <a>insert</a> function takes an element and a list
--   and inserts the element into the list at the first position where it
--   is less than or equal to the next element. In particular, if the list
--   is sorted before the call, the result will also be sorted. It is a
--   special case of <a>insertBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; insert 4 [1,2,3,5,6,7]
--   [1,2,3,4,5,6,7]
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
inits :: [a] -> [[a]]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result contains only equal elements. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Eq a => [a] -> [[a]]

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]

-- | &lt;math&gt;. The <a>genericLength</a> function is an overloaded
--   version of <a>length</a>. In particular, instead of returning an
--   <a>Int</a>, it returns any type which is an instance of <a>Num</a>. It
--   is, however, less efficient than <a>length</a>.
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Int
--   3
--   
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Float
--   3.0
--   </pre>
genericLength :: Num i => [a] -> i

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: Integral i => [a] -> i -> a

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (`elem` "aeiou") "Hello World!"
--   [1,4,7]
--   </pre>
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex isSpace "Hello World!"
--   Just 5
--   </pre>
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 'o' "Hello World"
--   [4,7]
--   </pre>
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 4 [0..]
--   Just 4
--   </pre>
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo\n"
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo bar"
--   "foo bar"
--   </pre>
--   
--   <pre>
--   dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--   </pre>
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed.
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | &lt;math&gt;. The <a>deleteBy</a> function behaves like <a>delete</a>,
--   but takes a user-supplied equality predicate.
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (&lt;=) 4 [1..10]
--   [1,2,3,5,6,7,8,9,10]
--   </pre>
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | &lt;math&gt;. <a>delete</a> <tt>x</tt> removes the first occurrence of
--   <tt>x</tt> from its list argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; delete 'a' "banana"
--   "bnana"
--   </pre>
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
delete :: Eq a => a -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello World!" \\ "ell W"
--   "Hoorld!"
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\

-- | Maybe monoid returning the rightmost non-Nothing value.
--   
--   <tt><a>Last</a> a</tt> is isomorphic to <tt><a>Dual</a> (<a>First</a>
--   a)</tt>, and thus to <tt><a>Dual</a> (<a>Alt</a> <a>Maybe</a> a)</tt>
--   
--   <pre>
--   &gt;&gt;&gt; getLast (Last (Just "hello") &lt;&gt; Last Nothing &lt;&gt; Last (Just "world"))
--   Just "world"
--   </pre>
newtype Last a
Last :: Maybe a -> Last a
[getLast] :: Last a -> Maybe a

-- | Maybe monoid returning the leftmost non-Nothing value.
--   
--   <tt><a>First</a> a</tt> is isomorphic to <tt><a>Alt</a> <a>Maybe</a>
--   a</tt>, but precedes it historically.
--   
--   <pre>
--   &gt;&gt;&gt; getFirst (First (Just "hello") &lt;&gt; First Nothing &lt;&gt; First (Just "world"))
--   Just "hello"
--   </pre>
newtype First a
First :: Maybe a -> First a
[getFirst] :: First a -> Maybe a

-- | This data type witnesses the lifting of a <a>Monoid</a> into an
--   <a>Applicative</a> pointwise.
newtype Ap (f :: k -> Type) (a :: k)
Ap :: f a -> Ap (f :: k -> Type) (a :: k)
[getAp] :: Ap (f :: k -> Type) (a :: k) -> f a

-- | Monoid under addition.
--   
--   <pre>
--   &gt;&gt;&gt; getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty)
--   3
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; getProduct (Product 3 &lt;&gt; Product 4 &lt;&gt; mempty)
--   12
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>.
--   
--   <pre>
--   &gt;&gt;&gt; getDual (mappend (Dual "Hello") (Dual "World"))
--   "WorldHello"
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | Boolean monoid under disjunction (<a>||</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAny (mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8]))
--   True
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under <a>&lt;|&gt;</a>.
--   
--   <pre>
--   &gt;&gt;&gt; getAlt (Alt (Just 12) &lt;&gt; Alt (Just 24))
--   Just 12
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAlt $ Alt Nothing &lt;&gt; Alt (Just 24)
--   Just 24
--   </pre>
newtype Alt (f :: k -> Type) (a :: k)
Alt :: f a -> Alt (f :: k -> Type) (a :: k)
[getAlt] :: Alt (f :: k -> Type) (a :: k) -> f a

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAll (mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8]))
--   False
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Selects Unicode space and separator characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>Space</a></li>
--   <li><a>LineSeparator</a></li>
--   <li><a>ParagraphSeparator</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Separator".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator 'a'
--   False
--   
--   &gt;&gt;&gt; isSeparator '6'
--   False
--   
--   &gt;&gt;&gt; isSeparator ' '
--   True
--   </pre>
--   
--   Warning: newlines and tab characters are not considered separators.
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\n'
--   False
--   
--   &gt;&gt;&gt; isSeparator '\t'
--   False
--   </pre>
--   
--   But some more exotic characters are (like HTML's <tt>&amp;nbsp;</tt>):
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\160'
--   True
--   </pre>
isSeparator :: Char -> Bool

-- | Selects Unicode numeric characters, including digits from various
--   scripts, Roman numerals, et cetera.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>DecimalNumber</a></li>
--   <li><a>LetterNumber</a></li>
--   <li><a>OtherNumber</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Number".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'a'
--   False
--   
--   &gt;&gt;&gt; isNumber '%'
--   False
--   
--   &gt;&gt;&gt; isNumber '3'
--   True
--   </pre>
--   
--   ASCII <tt>'0'</tt> through <tt>'9'</tt> are all numbers:
--   
--   <pre>
--   &gt;&gt;&gt; and $ map isNumber ['0'..'9']
--   True
--   </pre>
--   
--   Unicode Roman numerals are "numbers" as well:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'Ⅸ'
--   True
--   </pre>
isNumber :: Char -> Bool

-- | Selects Unicode mark characters, for example accents and the like,
--   which combine with preceding characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>NonSpacingMark</a></li>
--   <li><a>SpacingCombiningMark</a></li>
--   <li><a>EnclosingMark</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Mark".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isMark 'a'
--   False
--   
--   &gt;&gt;&gt; isMark '0'
--   False
--   </pre>
--   
--   Combining marks such as accent characters usually need to follow
--   another character before they become printable:
--   
--   <pre>
--   &gt;&gt;&gt; map isMark "ò"
--   [False,True]
--   </pre>
--   
--   Puns are not necessarily supported:
--   
--   <pre>
--   &gt;&gt;&gt; isMark '✓'
--   False
--   </pre>
isMark :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isAlpha</a>.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>UppercaseLetter</a></li>
--   <li><a>LowercaseLetter</a></li>
--   <li><a>TitlecaseLetter</a></li>
--   <li><a>ModifierLetter</a></li>
--   <li><a>OtherLetter</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Letter".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLetter 'a'
--   True
--   
--   &gt;&gt;&gt; isLetter 'A'
--   True
--   
--   &gt;&gt;&gt; isLetter 'λ'
--   True
--   
--   &gt;&gt;&gt; isLetter '0'
--   False
--   
--   &gt;&gt;&gt; isLetter '%'
--   False
--   
--   &gt;&gt;&gt; isLetter '♥'
--   False
--   
--   &gt;&gt;&gt; isLetter '\31'
--   False
--   </pre>
--   
--   Ensure that <a>isLetter</a> and <a>isAlpha</a> are equivalent.
--   
--   <pre>
--   &gt;&gt;&gt; let chars = [(chr 0)..]
--   
--   &gt;&gt;&gt; let letters = map isLetter chars
--   
--   &gt;&gt;&gt; let alphas = map isAlpha chars
--   
--   &gt;&gt;&gt; letters == alphas
--   True
--   </pre>
isLetter :: Char -> Bool

-- | Convert a single digit <a>Char</a> to the corresponding <a>Int</a>.
--   This function fails unless its argument satisfies <a>isHexDigit</a>,
--   but recognises both upper- and lower-case hexadecimal digits (that is,
--   <tt>'0'</tt>..<tt>'9'</tt>, <tt>'a'</tt>..<tt>'f'</tt>,
--   <tt>'A'</tt>..<tt>'F'</tt>).
--   
--   <h4><b>Examples</b></h4>
--   
--   Characters <tt>'0'</tt> through <tt>'9'</tt> are converted properly to
--   <tt>0..9</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['0'..'9']
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
--   
--   Both upper- and lower-case <tt>'A'</tt> through <tt>'F'</tt> are
--   converted as well, to <tt>10..15</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['a'..'f']
--   [10,11,12,13,14,15]
--   
--   &gt;&gt;&gt; map digitToInt ['A'..'F']
--   [10,11,12,13,14,15]
--   </pre>
--   
--   Anything else throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; digitToInt 'G'
--   *** Exception: Char.digitToInt: not a digit 'G'
--   
--   &gt;&gt;&gt; digitToInt '♥'
--   *** Exception: Char.digitToInt: not a digit '\9829'
--   </pre>
digitToInt :: Char -> Int

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions, and convert it to the character
--   that it encodes. For example:
--   
--   <pre>
--   readLitChar "\\nHello"  =  [('\n', "Hello")]
--   </pre>
readLitChar :: ReadS Char

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions. For example:
--   
--   <pre>
--   lexLitChar  "\\nHello"  =  [("\\n", "Hello")]
--   </pre>
lexLitChar :: ReadS String

-- | Unicode General Categories (column 2 of the UnicodeData table) in the
--   order they are listed in the Unicode standard (the Unicode Character
--   Database, in particular).
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; :t OtherLetter
--   OtherLetter :: GeneralCategory
--   </pre>
--   
--   <a>Eq</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; UppercaseLetter == UppercaseLetter
--   True
--   
--   &gt;&gt;&gt; UppercaseLetter == LowercaseLetter
--   False
--   </pre>
--   
--   <a>Ord</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; NonSpacingMark &lt;= MathSymbol
--   True
--   </pre>
--   
--   <a>Enum</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; enumFromTo ModifierLetter SpacingCombiningMark
--   [ModifierLetter,OtherLetter,NonSpacingMark,SpacingCombiningMark]
--   </pre>
--   
--   <a>Read</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; read "DashPunctuation" :: GeneralCategory
--   DashPunctuation
--   
--   &gt;&gt;&gt; read "17" :: GeneralCategory
--   *** Exception: Prelude.read: no parse
--   </pre>
--   
--   <a>Show</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; show EnclosingMark
--   "EnclosingMark"
--   </pre>
--   
--   <a>Bounded</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: GeneralCategory
--   UppercaseLetter
--   
--   &gt;&gt;&gt; maxBound :: GeneralCategory
--   NotAssigned
--   </pre>
--   
--   <a>Ix</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ix ( index )
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) FinalQuote
--   12
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) Format
--   *** Exception: Error in array index
--   </pre>
data GeneralCategory

-- | Lu: Letter, Uppercase
UppercaseLetter :: GeneralCategory

-- | Ll: Letter, Lowercase
LowercaseLetter :: GeneralCategory

-- | Lt: Letter, Titlecase
TitlecaseLetter :: GeneralCategory

-- | Lm: Letter, Modifier
ModifierLetter :: GeneralCategory

-- | Lo: Letter, Other
OtherLetter :: GeneralCategory

-- | Mn: Mark, Non-Spacing
NonSpacingMark :: GeneralCategory

-- | Mc: Mark, Spacing Combining
SpacingCombiningMark :: GeneralCategory

-- | Me: Mark, Enclosing
EnclosingMark :: GeneralCategory

-- | Nd: Number, Decimal
DecimalNumber :: GeneralCategory

-- | Nl: Number, Letter
LetterNumber :: GeneralCategory

-- | No: Number, Other
OtherNumber :: GeneralCategory

-- | Pc: Punctuation, Connector
ConnectorPunctuation :: GeneralCategory

-- | Pd: Punctuation, Dash
DashPunctuation :: GeneralCategory

-- | Ps: Punctuation, Open
OpenPunctuation :: GeneralCategory

-- | Pe: Punctuation, Close
ClosePunctuation :: GeneralCategory

-- | Pi: Punctuation, Initial quote
InitialQuote :: GeneralCategory

-- | Pf: Punctuation, Final quote
FinalQuote :: GeneralCategory

-- | Po: Punctuation, Other
OtherPunctuation :: GeneralCategory

-- | Sm: Symbol, Math
MathSymbol :: GeneralCategory

-- | Sc: Symbol, Currency
CurrencySymbol :: GeneralCategory

-- | Sk: Symbol, Modifier
ModifierSymbol :: GeneralCategory

-- | So: Symbol, Other
OtherSymbol :: GeneralCategory

-- | Zs: Separator, Space
Space :: GeneralCategory

-- | Zl: Separator, Line
LineSeparator :: GeneralCategory

-- | Zp: Separator, Paragraph
ParagraphSeparator :: GeneralCategory

-- | Cc: Other, Control
Control :: GeneralCategory

-- | Cf: Other, Format
Format :: GeneralCategory

-- | Cs: Other, Surrogate
Surrogate :: GeneralCategory

-- | Co: Other, Private Use
PrivateUse :: GeneralCategory

-- | Cn: Other, Not Assigned
NotAssigned :: GeneralCategory

-- | Convert a letter to the corresponding upper-case letter, if any. Any
--   other character is returned unchanged.
toUpper :: Char -> Char

-- | Convert a letter to the corresponding title-case or upper-case letter,
--   if any. (Title case differs from upper case only for a small number of
--   ligature letters.) Any other character is returned unchanged.
toTitle :: Char -> Char

-- | Convert a letter to the corresponding lower-case letter, if any. Any
--   other character is returned unchanged.
toLower :: Char -> Char

-- | Selects upper-case or title-case alphabetic Unicode characters
--   (letters). Title case is used by a small number of letter ligatures
--   like the single-character form of <i>Lj</i>.
isUpper :: Char -> Bool

-- | Selects Unicode symbol characters, including mathematical and currency
--   symbols.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>MathSymbol</a></li>
--   <li><a>CurrencySymbol</a></li>
--   <li><a>ModifierSymbol</a></li>
--   <li><a>OtherSymbol</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Symbol".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol 'a'
--   False
--   
--   &gt;&gt;&gt; isSymbol '6'
--   False
--   
--   &gt;&gt;&gt; isSymbol '='
--   True
--   </pre>
--   
--   The definition of "math symbol" may be a little counter-intuitive
--   depending on one's background:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol '+'
--   True
--   
--   &gt;&gt;&gt; isSymbol '-'
--   False
--   </pre>
isSymbol :: Char -> Bool

-- | Returns <a>True</a> for any Unicode space character, and the control
--   characters <tt>\t</tt>, <tt>\n</tt>, <tt>\r</tt>, <tt>\f</tt>,
--   <tt>\v</tt>.
isSpace :: Char -> Bool

-- | Selects Unicode punctuation characters, including various kinds of
--   connectors, brackets and quotes.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>ConnectorPunctuation</a></li>
--   <li><a>DashPunctuation</a></li>
--   <li><a>OpenPunctuation</a></li>
--   <li><a>ClosePunctuation</a></li>
--   <li><a>InitialQuote</a></li>
--   <li><a>FinalQuote</a></li>
--   <li><a>OtherPunctuation</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Punctuation".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isPunctuation 'a'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '7'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '♥'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '"'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '?'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '—'
--   True
--   </pre>
isPunctuation :: Char -> Bool

-- | Selects printable Unicode characters (letters, numbers, marks,
--   punctuation, symbols and spaces).
isPrint :: Char -> Bool

-- | Selects ASCII octal digits, i.e. <tt>'0'</tt>..<tt>'7'</tt>.
isOctDigit :: Char -> Bool

-- | Selects lower-case alphabetic Unicode characters (letters).
isLower :: Char -> Bool

-- | Selects the first 256 characters of the Unicode character set,
--   corresponding to the ISO 8859-1 (Latin-1) character set.
isLatin1 :: Char -> Bool

-- | Selects ASCII hexadecimal digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>,
--   <tt>'a'</tt>..<tt>'f'</tt>, <tt>'A'</tt>..<tt>'F'</tt>.
isHexDigit :: Char -> Bool

-- | Selects ASCII digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>.
isDigit :: Char -> Bool

-- | Selects control characters, which are the non-printing characters of
--   the Latin-1 subset of Unicode.
isControl :: Char -> Bool

-- | Selects ASCII upper-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isUpper</a>.
isAsciiUpper :: Char -> Bool

-- | Selects ASCII lower-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isLower</a>.
isAsciiLower :: Char -> Bool

-- | Selects the first 128 characters of the Unicode character set,
--   corresponding to the ASCII character set.
isAscii :: Char -> Bool

-- | Selects alphabetic or numeric Unicode characters.
--   
--   Note that numeric digits outside the ASCII range, as well as numeric
--   characters which aren't digits, are selected by this function but not
--   by <a>isDigit</a>. Such characters may be part of identifiers but are
--   not used by the printer and reader to represent numbers.
isAlphaNum :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isLetter</a>.
isAlpha :: Char -> Bool

-- | The Unicode general category of the character. This relies on the
--   <a>Enum</a> instance of <a>GeneralCategory</a>, which must remain in
--   the same order as the categories are presented in the Unicode
--   standard.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; generalCategory 'a'
--   LowercaseLetter
--   
--   &gt;&gt;&gt; generalCategory 'A'
--   UppercaseLetter
--   
--   &gt;&gt;&gt; generalCategory '0'
--   DecimalNumber
--   
--   &gt;&gt;&gt; generalCategory '%'
--   OtherPunctuation
--   
--   &gt;&gt;&gt; generalCategory '♥'
--   OtherSymbol
--   
--   &gt;&gt;&gt; generalCategory '\31'
--   Control
--   
--   &gt;&gt;&gt; generalCategory ' '
--   Space
--   </pre>
generalCategory :: Char -> GeneralCategory

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char

-- | Convert a character to a string using only printable characters, using
--   Haskell source-language escape conventions. For example:
--   
--   <pre>
--   showLitChar '\n' s  =  "\\n" ++ s
--   </pre>
showLitChar :: Char -> ShowS

-- | Convert an <a>Int</a> in the range <tt>0</tt>..<tt>15</tt> to the
--   corresponding single digit <a>Char</a>. This function fails on other
--   inputs, and generates lower-case hexadecimal digits.
intToDigit :: Int -> Char

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of the function
--   applied to corresponding elements, analogous to <a>zipWith</a>. It is
--   capable of list fusion, but it is restricted to its first list
--   argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   For example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | &lt;math&gt;. Decompose a list into its head and tail.
--   
--   <ul>
--   <li>If the list is empty, returns <a>Nothing</a>.</li>
--   <li>If the list is non-empty, returns <tt><a>Just</a> (x, xs)</tt>,
--   where <tt>x</tt> is the head of the list and <tt>xs</tt> its
--   tail.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   
--   &gt;&gt;&gt; uncons [1]
--   Just (1,[])
--   
--   &gt;&gt;&gt; uncons [1, 2, 3]
--   Just (1,[2,3])
--   </pre>
uncons :: [a] -> Maybe (a, [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; take 3 []
--   []
--   
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   
--   &gt;&gt;&gt; tail [1]
--   []
--   
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>
tail :: [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanl1 (+) [1..]
--   * Hangs forever *
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. A strict version of <a>scanl</a>.
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   
--   &gt;&gt;&gt; scanl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <pre>
--   &gt;&gt;&gt; take 20 $ repeat 17
--   [17,17,17,17,17,17,17,17,17...
--   </pre>
repeat :: a -> [a]

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
last :: [a] -> a

-- | <a>iterate'</a> is the strict version of <a>iterate</a>.
--   
--   It forces the result of each application of the function to weak head
--   normal form (WHNF) before proceeding.
iterate' :: (a -> a) -> a -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False...
--   
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63...
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
init :: [a] -> [a]

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   
--   &gt;&gt;&gt; head [1..]
--   1
--   
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>
head :: [a] -> a

-- | A strict version of <a>foldl1</a>.
foldl1' :: (a -> a -> a) -> [a] -> a

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   
--   &gt;&gt;&gt; drop 3 []
--   []
--   
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   
--   &gt;&gt;&gt; take 20 $ cycle [42]
--   [42,42,42,42,42,42,42,42,42,42...
--   
--   &gt;&gt;&gt; take 20 $ cycle [2, 5, 7]
--   [2,5,7,2,5,7,2,5,7,2,5,7...
--   </pre>
cycle :: [a] -> [a]

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when given <a>Just</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>fromMaybe</a> function takes a default value and a <a>Maybe</a>
--   value. If the <a>Maybe</a> is <a>Nothing</a>, it returns the default
--   value; otherwise, it returns the value contained in the <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   ...
--   </pre>
fromJust :: HasCallStack => Maybe a -> a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: a -> a -> Bool -> a

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <a>fix</a>’s argument, hence the recursion is reintroduced.
fix :: (a -> a) -> a

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | Lift a function to actions. Equivalent to Functor's <a>fmap</a> but
--   implemented using only <a>Applicative</a>'s methods: `liftA f a = pure
--   f <a>*</a> a`
--   
--   As such this function may be used to implement a <a>Functor</a>
--   instance from an <a>Applicative</a> one.
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "not"
not :: Bool -> Bool

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Short for <a>fromIntegral</a>.
fi :: (Integral a, Num b) => a -> b

-- | Given a maximum length, splits a list into sublists
--   
--   <pre>
--   &gt;&gt;&gt; chunksOf 5 (take 30 $ repeat 'a')
--   ["aaaaa","aaaaa","aaaaa","aaaaa","aaaaa","aaaaa"]
--   </pre>
chunksOf :: Int -> [a] -> [[a]]

-- | Multivariable composition.
--   
--   <pre>
--   f .: g ≡ (f .) . g ≡ \c d -&gt; f (g c d)
--   </pre>
(.:) :: (a -> b) -> (c -> d -> a) -> c -> d -> b

-- | Safe version of <a>(!!)</a>.
(!?) :: [a] -> Int -> Maybe a

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | <a>fromList</a> with a better error message. Useful to silence GHC's
--   Pattern match(es) are non-exhaustive warning in places where the
--   programmer knows it's always non-empty, but it's infeasible to express
--   that in the type system.
notEmpty :: HasCallStack => [a] -> NonEmpty a

-- | A safe version of <a>getWindowAttributes</a>.
safeGetWindowAttributes :: Window -> X (Maybe WindowAttributes)

-- | (Naïvely) turn a relative path into an absolute one.
--   
--   <ul>
--   <li>If the path starts with <tt>/</tt>, do nothing.</li>
--   <li>If it starts with <tt>~/</tt>, replace that with the actual
--   home</li>
--   <li>directory.</li>
--   <li>If it starts with <tt>$</tt>, read the name of an environment</li>
--   <li>variable and replace it with the contents of that.</li>
--   <li>Otherwise, prepend the home directory and <tt>/</tt> to the
--   path.</li>
--   </ul>
mkAbsolutePath :: MonadIO m => FilePath -> m FilePath

-- | Like <a>find</a>, but takes a monadic function instead; retains the
--   short-circuiting behaviour of the non-monadic version.
--   
--   For example,
--   
--   <pre>
--   findM (\a -&gt; putStr (show a &lt;&gt; " ") &gt;&gt; pure False) [1..10]
--   </pre>
--   
--   would print "1 2 3 4 5 6 7 8 9 10" and return <tt>Nothing</tt>, while
--   
--   <pre>
--   findM (\a -&gt; putStr (show a &lt;&gt; " ") &gt;&gt; pure True) [1..10]
--   </pre>
--   
--   would print <tt>"1"</tt> and return <tt>Just 1</tt>.
findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)

-- | Convert a full key combination; i.e., a <a>KeyMask</a> and
--   <a>KeySym</a> pair, into a string.
keyToString :: (KeyMask, KeySym) -> String

-- | Convert a modifier mask into a useful string.
keymaskToString :: KeyMask -> KeyMask -> String

-- | Strip numlock, capslock, mouse buttons and XKB group from a
--   <a>KeyMask</a>, leaving only modifier keys like Shift, Control, Super,
--   Hyper in the mask (hence the "Key" in "cleanKeyMask").
--   
--   Core's <a>cleanMask</a> only strips the first two because key events
--   from passive grabs (key bindings) are stripped of mouse buttons and
--   XKB group by the X server already for compatibility reasons. For more
--   info, see:
--   <a>https://www.x.org/releases/X11R7.7/doc/kbproto/xkbproto.html#Delivering_a_Key_or_Button_Event_to_a_Client</a>
cleanKeyMask :: X (KeyMask -> KeyMask)

-- | A list of "regular" (extended ASCII) keys.
regularKeys :: [(String, KeySym)]

-- | A list of all special key names and their associated KeySyms.
allSpecialKeys :: [(String, KeySym)]

-- | A list of special key names and their corresponding KeySyms.
specialKeys :: [(String, KeySym)]

-- | List of multimedia keys. If Xlib does not know about some keysym it's
--   omitted from the list (<a>stringToKeysym</a> returns <a>noSymbol</a>
--   in this case).
multimediaKeys :: [(String, KeySym)]

-- | A list pairing function key descriptor strings (e.g.
--   <tt>"&lt;F2&gt;"</tt>) with the associated KeySyms.
functionKeys :: [(String, KeySym)]

-- | The specialized <a>Screen</a> derived from <a>WindowSet</a>.
type WindowScreen = Screen WorkspaceId (Layout Window) Window ScreenId ScreenDetail

-- | An infinite stream type
data Stream a
(:~) :: !a -> Stream a -> Stream a
infixr 5 :~

-- | Absorb a list into an infinite stream.
(+~) :: [a] -> Stream a -> Stream a
infixr 5 +~

-- | Absorb a non-empty list into an infinite stream.
cycleS :: NonEmpty a -> Stream a

-- | <tt>takeS n stream</tt> returns the first <tt>n</tt> elements of
--   <tt>stream</tt>; if <tt>n &lt; 0</tt>, this returns the empty list.
takeS :: Int -> Stream a -> [a]

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l
instance GHC.Base.Functor XMonad.Prelude.Stream
instance GHC.Exts.IsList (XMonad.Prelude.Stream a)


-- | A module to toggle between two layouts.
module XMonad.Layout.ToggleLayouts
toggleLayouts :: (LayoutClass lt a, LayoutClass lf a) => lt a -> lf a -> ToggleLayouts lt lf a
data ToggleLayout
ToggleLayout :: ToggleLayout
Toggle :: String -> ToggleLayout
data ToggleLayouts lt lf a
instance (GHC.Show.Show (lt a), GHC.Show.Show (lf a)) => GHC.Show.Show (XMonad.Layout.ToggleLayouts.ToggleLayouts lt lf a)
instance (GHC.Read.Read (lt a), GHC.Read.Read (lf a)) => GHC.Read.Read (XMonad.Layout.ToggleLayouts.ToggleLayouts lt lf a)
instance GHC.Show.Show XMonad.Layout.ToggleLayouts.ToggleLayout
instance GHC.Read.Read XMonad.Layout.ToggleLayouts.ToggleLayout
instance XMonad.Core.Message XMonad.Layout.ToggleLayouts.ToggleLayout
instance (XMonad.Core.LayoutClass lt a, XMonad.Core.LayoutClass lf a) => XMonad.Core.LayoutClass (XMonad.Layout.ToggleLayouts.ToggleLayouts lt lf) a


-- | A layout similar to tall but with three columns. With 2560x1600 pixels
--   this layout can be used for a huge main window and up to six
--   reasonable sized slave windows.
module XMonad.Layout.ThreeColumns

-- | Arguments are nmaster, delta, fraction
data ThreeCol a
ThreeColMid :: !Int -> !Rational -> !Rational -> ThreeCol a
[threeColNMaster] :: ThreeCol a -> !Int
[threeColDelta] :: ThreeCol a -> !Rational
[threeColFrac] :: ThreeCol a -> !Rational
ThreeCol :: !Int -> !Rational -> !Rational -> ThreeCol a
[threeColNMaster] :: ThreeCol a -> !Int
[threeColDelta] :: ThreeCol a -> !Rational
[threeColFrac] :: ThreeCol a -> !Rational
instance GHC.Read.Read (XMonad.Layout.ThreeColumns.ThreeCol a)
instance GHC.Show.Show (XMonad.Layout.ThreeColumns.ThreeCol a)
instance XMonad.Core.LayoutClass XMonad.Layout.ThreeColumns.ThreeCol a


-- | A stacking layout, like dishes but with the ability to resize master
--   pane. Mostly useful on small screens.
module XMonad.Layout.StackTile
data StackTile a
StackTile :: !Int -> !Rational -> !Rational -> StackTile a
instance GHC.Read.Read (XMonad.Layout.StackTile.StackTile a)
instance GHC.Show.Show (XMonad.Layout.StackTile.StackTile a)
instance XMonad.Core.LayoutClass XMonad.Layout.StackTile.StackTile a


-- | More useful tiled layout that allows you to change a width/height of
--   window.
module XMonad.Layout.ResizableTile
data ResizableTall a
ResizableTall :: Int -> Rational -> Rational -> [Rational] -> ResizableTall a

-- | number of master windows
[_nmaster] :: ResizableTall a -> Int

-- | change when resizing by <a>Shrink</a>, <a>Expand</a>,
--   <a>MirrorShrink</a>, <a>MirrorExpand</a>
[_delta] :: ResizableTall a -> Rational

-- | width of master
[_frac] :: ResizableTall a -> Rational

-- | fraction to multiply the window height that would be given when
--   divided equally.
--   
--   slave windows are assigned their modified heights in order, from top
--   to bottom
--   
--   unspecified values are replaced by 1
[_slaves] :: ResizableTall a -> [Rational]
data MirrorResize
MirrorShrink :: MirrorResize
MirrorExpand :: MirrorResize
instance GHC.Read.Read (XMonad.Layout.ResizableTile.ResizableTall a)
instance GHC.Show.Show (XMonad.Layout.ResizableTile.ResizableTall a)
instance XMonad.Core.LayoutClass XMonad.Layout.ResizableTile.ResizableTall a
instance XMonad.Core.Message XMonad.Layout.ResizableTile.MirrorResize


-- | A layout similar to tall but with three columns. With 2560x1600 pixels
--   this layout can be used for a huge main window and up to six
--   reasonable sized resizable stack windows.
module XMonad.Layout.ResizableThreeColumns

-- | Arguments are nmaster, delta, fraction
data ResizableThreeCol a
ResizableThreeColMid :: !Int -> !Rational -> !Rational -> [Rational] -> ResizableThreeCol a
[threeColNMaster] :: ResizableThreeCol a -> !Int
[threeColDelta] :: ResizableThreeCol a -> !Rational
[threeColFrac] :: ResizableThreeCol a -> !Rational
[threeColSlaves] :: ResizableThreeCol a -> [Rational]
ResizableThreeCol :: !Int -> !Rational -> !Rational -> [Rational] -> ResizableThreeCol a
[threeColNMaster] :: ResizableThreeCol a -> !Int
[threeColDelta] :: ResizableThreeCol a -> !Rational
[threeColFrac] :: ResizableThreeCol a -> !Rational
[threeColSlaves] :: ResizableThreeCol a -> [Rational]
data MirrorResize
MirrorShrink :: MirrorResize
MirrorExpand :: MirrorResize
instance GHC.Read.Read (XMonad.Layout.ResizableThreeColumns.ResizableThreeCol a)
instance GHC.Show.Show (XMonad.Layout.ResizableThreeColumns.ResizableThreeCol a)
instance XMonad.Core.LayoutClass XMonad.Layout.ResizableThreeColumns.ResizableThreeCol a


-- | Configure layouts on a per-workspace basis: use layouts and apply
--   layout modifiers selectively, depending on the workspace.
module XMonad.Layout.PerWorkspace

-- | Structure for representing a workspace-specific layout along with a
--   layout for all other workspaces. We store the tags of workspaces to be
--   matched, and the two layouts. We save the layout choice in the Bool,
--   to be used to implement description.
data PerWorkspace l1 l2 a

-- | Specify one layout to use on a particular workspace, and another to
--   use on all others. The second layout can be another call to
--   <a>onWorkspace</a>, and so on.
onWorkspace :: (LayoutClass l1 a, LayoutClass l2 a) => WorkspaceId -> l1 a -> l2 a -> PerWorkspace l1 l2 a

-- | Specify one layout to use on a particular set of workspaces, and
--   another to use on all other workspaces.
onWorkspaces :: (LayoutClass l1 a, LayoutClass l2 a) => [WorkspaceId] -> l1 a -> l2 a -> PerWorkspace l1 l2 a

-- | Specify a layout modifier to apply to a particular workspace; layouts
--   on all other workspaces will remain unmodified.
modWorkspace :: (LayoutClass l1 a, LayoutClass l2 a) => WorkspaceId -> (l2 a -> l1 a) -> l2 a -> PerWorkspace l1 l2 a

-- | Specify a layout modifier to apply to a particular set of workspaces;
--   layouts on all other workspaces will remain unmodified.
modWorkspaces :: (LayoutClass l1 a, LayoutClass l2 a) => [WorkspaceId] -> (l2 a -> l1 a) -> l2 a -> PerWorkspace l1 l2 a
instance (GHC.Show.Show (l1 a), GHC.Show.Show (l2 a)) => GHC.Show.Show (XMonad.Layout.PerWorkspace.PerWorkspace l1 l2 a)
instance (GHC.Read.Read (l1 a), GHC.Read.Read (l2 a)) => GHC.Read.Read (XMonad.Layout.PerWorkspace.PerWorkspace l1 l2 a)
instance (XMonad.Core.LayoutClass l1 a, XMonad.Core.LayoutClass l2 a, GHC.Show.Show a) => XMonad.Core.LayoutClass (XMonad.Layout.PerWorkspace.PerWorkspace l1 l2) a


-- | Configure layouts based on the width of your screen; use your favorite
--   multi-column layout for wide screens and a full-screen layout for
--   small ones.
module XMonad.Layout.PerScreen
data PerScreen l1 l2 a
ifWider :: (LayoutClass l1 a, LayoutClass l2 a) => Dimension -> l1 a -> l2 a -> PerScreen l1 l2 a
instance (GHC.Show.Show (l1 a), GHC.Show.Show (l2 a)) => GHC.Show.Show (XMonad.Layout.PerScreen.PerScreen l1 l2 a)
instance (GHC.Read.Read (l1 a), GHC.Read.Read (l2 a)) => GHC.Read.Read (XMonad.Layout.PerScreen.PerScreen l1 l2 a)
instance (XMonad.Core.LayoutClass l1 a, XMonad.Core.LayoutClass l2 a, GHC.Show.Show a) => XMonad.Core.LayoutClass (XMonad.Layout.PerScreen.PerScreen l1 l2) a


-- | Dynamically apply and unapply transformers to your window layout. This
--   can be used to rotate your window layout by 90 degrees, or to make the
--   currently focused window occupy the whole screen ("zoom in") then undo
--   the transformation ("zoom out").
module XMonad.Layout.MultiToggle

-- | A class to identify custom transformers (and look up transforming
--   functions by type).
class (Eq t, Typeable t) => Transformer t a | t -> a
transform :: (Transformer t a, LayoutClass l a) => t -> l a -> (forall l'. LayoutClass l' a => l' a -> (l' a -> l a) -> b) -> b

-- | Toggle the specified layout transformer.
data Toggle a
Toggle :: t -> Toggle a

-- | Prepend an element to a heterogeneous list. Used to build transformer
--   tables for <a>mkToggle</a>.
(??) :: a -> b -> HCons a b
infixr 0 ??

-- | Marks the end of a transformer list.
data EOT
EOT :: EOT

-- | Construct a singleton transformer table.
single :: a -> HCons a EOT

-- | Construct a <tt>MultiToggle</tt> layout from a transformer table and a
--   base layout.
mkToggle :: LayoutClass l a => ts -> l a -> MultiToggle ts l a

-- | Construct a <tt>MultiToggle</tt> layout from a single transformer and
--   a base layout.
mkToggle1 :: LayoutClass l a => t -> l a -> MultiToggle (HCons t EOT) l a

-- | Query the state of a <a>Transformer</a> on a given workspace.
--   
--   To query the current workspace, use something like this:
--   
--   <pre>
--   withWindowSet (isToggleActive t . W.workspace . W.current)
--   </pre>
isToggleActive :: Transformer t Window => t -> WindowSpace -> X (Maybe Bool)
class HList c a
data HCons a b
data MultiToggle ts l a
instance (GHC.Show.Show ts, GHC.Show.Show (l a)) => GHC.Show.Show (XMonad.Layout.MultiToggle.MultiToggleS ts l a)
instance (GHC.Read.Read ts, GHC.Read.Read (l a)) => GHC.Read.Read (XMonad.Layout.MultiToggle.MultiToggleS ts l a)
instance GHC.Show.Show XMonad.Layout.MultiToggle.EOT
instance GHC.Read.Read XMonad.Layout.MultiToggle.EOT
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (XMonad.Layout.MultiToggle.HCons a b)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (XMonad.Layout.MultiToggle.HCons a b)
instance (Data.Typeable.Internal.Typeable a, GHC.Show.Show ts, Data.Typeable.Internal.Typeable ts, XMonad.Layout.MultiToggle.HList ts a, XMonad.Core.LayoutClass l a) => XMonad.Core.LayoutClass (XMonad.Layout.MultiToggle.MultiToggle ts l) a
instance Data.Typeable.Internal.Typeable a => XMonad.Core.Message (XMonad.Layout.MultiToggle.MultiToggleActiveQueryMessage a)
instance (XMonad.Core.LayoutClass l a, GHC.Read.Read (l a), XMonad.Layout.MultiToggle.HList ts a, GHC.Read.Read ts) => GHC.Read.Read (XMonad.Layout.MultiToggle.MultiToggle ts l a)
instance XMonad.Layout.MultiToggle.HList XMonad.Layout.MultiToggle.EOT w
instance (XMonad.Layout.MultiToggle.Transformer a w, XMonad.Layout.MultiToggle.HList b w) => XMonad.Layout.MultiToggle.HList (XMonad.Layout.MultiToggle.HCons a b) w
instance (GHC.Show.Show ts, GHC.Show.Show (l a), XMonad.Core.LayoutClass l a) => GHC.Show.Show (XMonad.Layout.MultiToggle.MultiToggle ts l a)
instance Data.Typeable.Internal.Typeable a => XMonad.Core.Message (XMonad.Layout.MultiToggle.Toggle a)


-- | MultiDishes is a layout that stacks groups of extra windows underneath
--   the master windows.
module XMonad.Layout.MultiDishes
data MultiDishes a
MultiDishes :: Int -> Int -> Rational -> MultiDishes a
instance GHC.Read.Read (XMonad.Layout.MultiDishes.MultiDishes a)
instance GHC.Show.Show (XMonad.Layout.MultiDishes.MultiDishes a)
instance XMonad.Core.LayoutClass XMonad.Layout.MultiDishes.MultiDishes a


-- | This layout tiles windows in a growing number of columns. The number
--   of windows in each column can be controlled by messages.
module XMonad.Layout.MultiColumns

-- | Layout constructor.
multiCol :: [Int] -> Int -> Rational -> Rational -> MultiCol a
data MultiCol a
instance GHC.Classes.Eq (XMonad.Layout.MultiColumns.MultiCol a)
instance GHC.Read.Read (XMonad.Layout.MultiColumns.MultiCol a)
instance GHC.Show.Show (XMonad.Layout.MultiColumns.MultiCol a)
instance XMonad.Core.LayoutClass XMonad.Layout.MultiColumns.MultiCol a


-- | A layout which gives each window a specified amount of screen space
--   relative to the others. Compared to the <tt>Mosaic</tt> layout, this
--   one divides the space in a more balanced way.
module XMonad.Layout.MosaicAlt
newtype MosaicAlt a
MosaicAlt :: Params -> MosaicAlt a
shrinkWindowAlt :: Window -> HandleWindowAlt
expandWindowAlt :: Window -> HandleWindowAlt
tallWindowAlt :: Window -> HandleWindowAlt
wideWindowAlt :: Window -> HandleWindowAlt
resetAlt :: HandleWindowAlt
type Params = Map Window Param
data Param
data HandleWindowAlt
instance GHC.Classes.Eq XMonad.Layout.MosaicAlt.HandleWindowAlt
instance GHC.Read.Read XMonad.Layout.MosaicAlt.Param
instance GHC.Show.Show XMonad.Layout.MosaicAlt.Param
instance GHC.Read.Read (XMonad.Layout.MosaicAlt.MosaicAlt a)
instance GHC.Show.Show (XMonad.Layout.MosaicAlt.MosaicAlt a)
instance XMonad.Core.LayoutClass XMonad.Layout.MosaicAlt.MosaicAlt Graphics.X11.Types.Window
instance XMonad.Core.Message XMonad.Layout.MosaicAlt.HandleWindowAlt


-- | Based on MosaicAlt, but aspect ratio messages always change the aspect
--   ratios, and rearranging the window stack changes the window sizes.
module XMonad.Layout.Mosaic
data Aspect
Taller :: Aspect
Wider :: Aspect
Reset :: Aspect
SlopeMod :: ([Rational] -> [Rational]) -> Aspect

-- | The relative magnitudes (the sign is ignored) of the rational numbers
--   in the second argument determine the relative areas that the windows
--   receive. The first number represents the size of the master window,
--   the second is for the next window in the stack, and so on.
--   
--   The list is extended with <tt>++ repeat 1</tt>, so <tt>mosaic 1.5
--   []</tt> is like a resizable grid.
--   
--   The first parameter is the multiplicative factor to use when
--   responding to the <a>Expand</a> message.
mosaic :: Rational -> [Rational] -> Mosaic a

-- | These sample functions are meant to be applied to the list of window
--   sizes through the <a>SlopeMod</a> message.
changeMaster :: (Rational -> Rational) -> X ()

-- | Apply a function to the Rational that represents the currently focused
--   window.
--   
--   <a>Expand</a> and <a>Shrink</a> messages are responded to with
--   <tt>changeFocused (*delta)</tt> or <tt>changeFocused (delta/)</tt>
--   where <tt>delta</tt> is the first argument to <a>mosaic</a>.
--   
--   This is exported because other functions (ex. <tt>const 1</tt>,
--   <tt>(+1)</tt>) may be useful to apply to the current area.
changeFocused :: (Rational -> Rational) -> X ()
data Mosaic a
instance GHC.Show.Show (XMonad.Layout.Mosaic.Mosaic a)
instance GHC.Read.Read (XMonad.Layout.Mosaic.Mosaic a)
instance Data.Foldable.Foldable XMonad.Layout.Mosaic.Tree
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.Mosaic.Tree a)
instance GHC.Base.Functor XMonad.Layout.Mosaic.Tree
instance GHC.Base.Semigroup (XMonad.Layout.Mosaic.Tree a)
instance GHC.Base.Monoid (XMonad.Layout.Mosaic.Tree a)
instance XMonad.Core.LayoutClass XMonad.Layout.Mosaic.Mosaic a
instance XMonad.Core.Message XMonad.Layout.Mosaic.Aspect


-- | Divide a single screen into multiple screens.
module XMonad.Layout.LayoutScreens

-- | Modify all screens.
layoutScreens :: LayoutClass l Int => Int -> l Int -> X ()

-- | Modify current screen.
layoutSplitScreen :: LayoutClass l Int => Int -> l Int -> X ()
fixedLayout :: [Rectangle] -> FixedLayout a
data FixedLayout a
instance GHC.Show.Show (XMonad.Layout.LayoutScreens.FixedLayout a)
instance GHC.Read.Read (XMonad.Layout.LayoutScreens.FixedLayout a)
instance XMonad.Core.LayoutClass XMonad.Layout.LayoutScreens.FixedLayout a


-- | A module for writing easy layout modifiers, which do not define a
--   layout in and of themselves, but modify the behavior of or add new
--   functionality to other layouts. If you ever find yourself writing a
--   layout which takes another layout as a parameter, chances are you
--   should be writing a LayoutModifier instead!
--   
--   In case it is not clear, this module is not intended to help you
--   configure xmonad, it is to help you write other extension modules. So
--   get hacking!
module XMonad.Layout.LayoutModifier
class (Show (m a), Read (m a)) => LayoutModifier m a

-- | <a>modifyLayout</a> allows you to intercept a call to <a>runLayout</a>
--   <i>before</i> it is called on the underlying layout, in order to
--   perform some effect in the X monad, and/or modify some of the
--   parameters before passing them on to the <a>runLayout</a> method of
--   the underlying layout.
--   
--   The default implementation of <a>modifyLayout</a> simply calls
--   <a>runLayout</a> on the underlying layout.
modifyLayout :: (LayoutModifier m a, LayoutClass l a) => m a -> Workspace WorkspaceId (l a) a -> Rectangle -> X ([(a, Rectangle)], Maybe (l a))

-- | Similar to <a>modifyLayout</a>, but this function also allows you
--   update the state of your layout modifier(the second value in the outer
--   tuple).
--   
--   If both <a>modifyLayoutWithUpdate</a> and <a>redoLayout</a> return a
--   modified state of the layout modifier, <a>redoLayout</a> takes
--   precedence. If this function returns a modified state, this state will
--   internally be used in the subsequent call to <a>redoLayout</a> as
--   well.
modifyLayoutWithUpdate :: (LayoutModifier m a, LayoutClass l a) => m a -> Workspace WorkspaceId (l a) a -> Rectangle -> X (([(a, Rectangle)], Maybe (l a)), Maybe (m a))

-- | <a>handleMess</a> allows you to spy on messages to the underlying
--   layout, in order to have an effect in the X monad, or alter the layout
--   modifier state in some way (by returning <tt>Just nm</tt>, where
--   <tt>nm</tt> is a new modifier). In all cases, the underlying layout
--   will also receive the message as usual, after the message has been
--   processed by <a>handleMess</a>.
--   
--   If you wish to possibly modify a message before it reaches the
--   underlying layout, you should use <a>handleMessOrMaybeModifyIt</a>
--   instead. If you do not need to modify messages or have access to the X
--   monad, you should use <a>pureMess</a> instead.
--   
--   The default implementation of <a>handleMess</a> calls <a>unhook</a>
--   when receiving a <a>Hide</a> or <a>ReleaseResources</a> method (after
--   which it returns <tt>Nothing</tt>), and otherwise passes the message
--   on to <a>pureMess</a>.
handleMess :: LayoutModifier m a => m a -> SomeMessage -> X (Maybe (m a))

-- | <a>handleMessOrMaybeModifyIt</a> allows you to intercept messages sent
--   to the underlying layout, in order to have an effect in the X monad,
--   alter the layout modifier state, or produce a modified message to be
--   passed on to the underlying layout.
--   
--   The default implementation of <a>handleMessOrMaybeModifyIt</a> simply
--   passes on the message to <a>handleMess</a>.
handleMessOrMaybeModifyIt :: LayoutModifier m a => m a -> SomeMessage -> X (Maybe (Either (m a) SomeMessage))

-- | <a>pureMess</a> allows you to spy on messages sent to the underlying
--   layout, in order to possibly change the layout modifier state.
--   
--   The default implementation of <a>pureMess</a> ignores messages sent to
--   it, and returns <tt>Nothing</tt> (causing the layout modifier to
--   remain unchanged).
pureMess :: LayoutModifier m a => m a -> SomeMessage -> Maybe (m a)

-- | <a>redoLayout</a> allows you to intercept a call to <a>runLayout</a>
--   on workspaces with at least one window, <i>after</i> it is called on
--   the underlying layout, in order to perform some effect in the X monad,
--   possibly return a new layout modifier, and/or modify the results of
--   <a>runLayout</a> before returning them.
--   
--   If you don't need access to the X monad, use <a>pureModifier</a>
--   instead. Also, if the behavior you need can be cleanly separated into
--   an effect in the X monad, followed by a pure transformation of the
--   results of <a>runLayout</a>, you should consider implementing
--   <a>hook</a> and <a>pureModifier</a> instead of <a>redoLayout</a>.
--   
--   On empty workspaces, the Stack is Nothing.
--   
--   The default implementation of <a>redoLayout</a> calls <a>hook</a> and
--   then <a>pureModifier</a>.
redoLayout :: LayoutModifier m a => m a -> Rectangle -> Maybe (Stack a) -> [(a, Rectangle)] -> X ([(a, Rectangle)], Maybe (m a))

-- | <a>pureModifier</a> allows you to intercept a call to <a>runLayout</a>
--   <i>after</i> it is called on the underlying layout, in order to modify
--   the list of window/rectangle pairings it has returned, and/or return a
--   new layout modifier.
--   
--   The default implementation of <a>pureModifier</a> returns the window
--   rectangles unmodified.
pureModifier :: LayoutModifier m a => m a -> Rectangle -> Maybe (Stack a) -> [(a, Rectangle)] -> ([(a, Rectangle)], Maybe (m a))

-- | <a>hook</a> is called by the default implementation of
--   <a>redoLayout</a>, and as such represents an X action which is to be
--   run each time <a>runLayout</a> is called on the underlying layout,
--   <i>after</i> <a>runLayout</a> has completed. Of course, if you
--   override <a>redoLayout</a>, then <a>hook</a> will not be called unless
--   you explicitly call it.
--   
--   The default implementation of <a>hook</a> is <tt>return ()</tt> (i.e.,
--   it has no effect).
hook :: LayoutModifier m a => m a -> X ()

-- | <a>unhook</a> is called by the default implementation of
--   <a>handleMess</a> upon receiving a <a>Hide</a> or a
--   <a>ReleaseResources</a> message.
--   
--   The default implementation, of course, does nothing.
unhook :: LayoutModifier m a => m a -> X ()

-- | <a>modifierDescription</a> is used to give a String description to
--   this layout modifier. It is the empty string by default; you should
--   only override this if it is important that the presence of the layout
--   modifier be displayed in text representations of the layout (for
--   example, in the status bar of a <a>XMonad.Hooks.StatusBar</a> user).
modifierDescription :: LayoutModifier m a => m a -> String

-- | <a>modifyDescription</a> gives a String description for the entire
--   layout (modifier + underlying layout). By default, it is derived from
--   the concatenation of the <a>modifierDescription</a> with the
--   <a>description</a> of the underlying layout, with a "smart space" in
--   between (the space is not included if the <a>modifierDescription</a>
--   is empty).
modifyDescription :: (LayoutModifier m a, LayoutClass l a) => m a -> l a -> String

-- | A <a>ModifiedLayout</a> is simply a container for a layout modifier
--   combined with an underlying layout. It is, of course, itself a layout
--   (i.e. an instance of <a>LayoutClass</a>).
data ModifiedLayout m l a
ModifiedLayout :: m a -> l a -> ModifiedLayout m l a
instance (GHC.Show.Show (m a), GHC.Show.Show (l a)) => GHC.Show.Show (XMonad.Layout.LayoutModifier.ModifiedLayout m l a)
instance (GHC.Read.Read (m a), GHC.Read.Read (l a)) => GHC.Read.Read (XMonad.Layout.LayoutModifier.ModifiedLayout m l a)
instance (XMonad.Layout.LayoutModifier.LayoutModifier m a, XMonad.Core.LayoutClass l a, Data.Typeable.Internal.Typeable m) => XMonad.Core.LayoutClass (XMonad.Layout.LayoutModifier.ModifiedLayout m l) a


-- | This is a pure layout modifier that will let you move and resize
--   windows with the keyboard in any layout.
module XMonad.Layout.WindowArranger

-- | A layout modifier to float the windows in a workspace
windowArrange :: l a -> ModifiedLayout WindowArranger l a

-- | A layout modifier to float all the windows in a workspace
windowArrangeAll :: l a -> ModifiedLayout WindowArranger l a
data WindowArrangerMsg
DeArrange :: WindowArrangerMsg
Arrange :: WindowArrangerMsg
IncreaseLeft :: Int -> WindowArrangerMsg
IncreaseRight :: Int -> WindowArrangerMsg
IncreaseUp :: Int -> WindowArrangerMsg
IncreaseDown :: Int -> WindowArrangerMsg
DecreaseLeft :: Int -> WindowArrangerMsg
DecreaseRight :: Int -> WindowArrangerMsg
DecreaseUp :: Int -> WindowArrangerMsg
DecreaseDown :: Int -> WindowArrangerMsg
MoveLeft :: Int -> WindowArrangerMsg
MoveRight :: Int -> WindowArrangerMsg
MoveUp :: Int -> WindowArrangerMsg
MoveDown :: Int -> WindowArrangerMsg
SetGeometry :: Rectangle -> WindowArrangerMsg
data WindowArranger a

-- | Given a function to be applied to each member of ta list, and a
--   function to check a condition by processing this transformed member
--   with something, you get the first member that satisfy the condition,
--   or an empty list.
memberFromList :: (b -> c) -> (c -> a -> Bool) -> a -> [b] -> [b]

-- | Given a function to be applied to each member of a list, and a
--   function to check a condition by processing this transformed member
--   with the members of a list, you get the list of members that satisfy
--   the condition.
listFromList :: (b -> c) -> (c -> [a] -> Bool) -> [a] -> [b] -> [b]

-- | Get the list of elements to be deleted and the list of elements to be
--   added to the first list in order to get the second list.
diff :: Eq a => ([a], [a]) -> ([a], [a])
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.WindowArranger.ArrangedWindow a)
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Layout.WindowArranger.ArrangedWindow a)
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.WindowArranger.WindowArranger a)
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Layout.WindowArranger.WindowArranger a)
instance (GHC.Show.Show a, GHC.Read.Read a, GHC.Classes.Eq a) => XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.WindowArranger.WindowArranger a
instance XMonad.Core.Message XMonad.Layout.WindowArranger.WindowArrangerMsg


-- | Modifies a layout to set borders to 0 for all windows in the
--   workspace.
--   
--   Unlike <a>XMonad.Layout.NoBorders</a>, the <a>voidBorders</a> modifier
--   will not restore the window border if the windows are moved to a
--   different workspace or the layout is changed. There is, however, a
--   companion <a>normalBorders</a> modifier which explicitly restores the
--   border.
--   
--   This modifier's primary use is to eliminate the "border flash" you get
--   while switching workspaces with the <a>XMonad.Layout.NoBorders</a>
--   modifier.
module XMonad.Layout.VoidBorders
voidBorders :: l Window -> ModifiedLayout VoidBorders l Window
normalBorders :: l Window -> ModifiedLayout NormalBorders l Window
instance GHC.Show.Show (XMonad.Layout.VoidBorders.VoidBorders a)
instance GHC.Read.Read (XMonad.Layout.VoidBorders.VoidBorders a)
instance GHC.Show.Show (XMonad.Layout.VoidBorders.NormalBorders a)
instance GHC.Read.Read (XMonad.Layout.VoidBorders.NormalBorders a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.VoidBorders.NormalBorders Graphics.X11.Types.Window
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.VoidBorders.VoidBorders Graphics.X11.Types.Window


-- | A basic floating layout like SimpleFloat but without the decoration.
module XMonad.Layout.SimplestFloat

-- | A simple floating layout where every window is placed according to the
--   window's initial attributes.
simplestFloat :: Eq a => ModifiedLayout WindowArranger SimplestFloat a
data SimplestFloat a
instance GHC.Read.Read (XMonad.Layout.SimplestFloat.SimplestFloat a)
instance GHC.Show.Show (XMonad.Layout.SimplestFloat.SimplestFloat a)
instance XMonad.Core.LayoutClass XMonad.Layout.SimplestFloat.SimplestFloat Graphics.X11.Types.Window


-- | Layout modifier that can modify the description of its underlying
--   layout on a (hopefully) flexible way.
module XMonad.Layout.Renamed

-- | Apply a list of <a>Rename</a> values to a layout, from left to right.
renamed :: [Rename a] -> l a -> ModifiedLayout Rename l a

-- | Rename a layout. (Convenience alias for <tt>renamed [Replace s]</tt>.)
named :: String -> l a -> ModifiedLayout Rename l a

-- | The available renaming operations
data Rename a

-- | Remove a number of characters from the left
CutLeft :: Int -> Rename a

-- | Remove a number of characters from the right
CutRight :: Int -> Rename a

-- | Add a string on the right
Append :: String -> Rename a

-- | Add a string on the left
Prepend :: String -> Rename a

-- | Remove a number of words from the left
CutWordsLeft :: Int -> Rename a

-- | Remove a number of words from the right
CutWordsRight :: Int -> Rename a

-- | Keep a number of words from the left
KeepWordsLeft :: Int -> Rename a

-- | Keep a number of words from the right
KeepWordsRight :: Int -> Rename a

-- | Add a string to the right, prepending a space to it if necessary
AppendWords :: String -> Rename a

-- | Add a string to the left, appending a space to it if necessary
PrependWords :: String -> Rename a

-- | Replace with another string
Replace :: String -> Rename a

-- | Apply a list of modifications in left-to-right order
Chain :: [Rename a] -> Rename a
instance GHC.Classes.Eq (XMonad.Layout.Renamed.Rename a)
instance GHC.Read.Read (XMonad.Layout.Renamed.Rename a)
instance GHC.Show.Show (XMonad.Layout.Renamed.Rename a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Renamed.Rename a


-- | Reflect a layout horizontally or vertically.
module XMonad.Layout.Reflect

-- | Apply a horizontal reflection (left &lt;--&gt; right) to a layout.
reflectHoriz :: l a -> ModifiedLayout Reflect l a

-- | Apply a vertical reflection (top &lt;--&gt; bottom) to a layout.
reflectVert :: l a -> ModifiedLayout Reflect l a
data REFLECTX
REFLECTX :: REFLECTX
data REFLECTY
REFLECTY :: REFLECTY
data Reflect a
instance GHC.Show.Show XMonad.Layout.Reflect.ReflectDir
instance GHC.Read.Read XMonad.Layout.Reflect.ReflectDir
instance GHC.Read.Read (XMonad.Layout.Reflect.Reflect a)
instance GHC.Show.Show (XMonad.Layout.Reflect.Reflect a)
instance GHC.Classes.Eq XMonad.Layout.Reflect.REFLECTX
instance GHC.Show.Show XMonad.Layout.Reflect.REFLECTX
instance GHC.Read.Read XMonad.Layout.Reflect.REFLECTX
instance GHC.Classes.Eq XMonad.Layout.Reflect.REFLECTY
instance GHC.Show.Show XMonad.Layout.Reflect.REFLECTY
instance GHC.Read.Read XMonad.Layout.Reflect.REFLECTY
instance XMonad.Layout.MultiToggle.Transformer XMonad.Layout.Reflect.REFLECTY Graphics.X11.Types.Window
instance XMonad.Layout.MultiToggle.Transformer XMonad.Layout.Reflect.REFLECTX Graphics.X11.Types.Window
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Reflect.Reflect a


-- | Configure layouts on a per-host basis: use layouts and apply layout
--   modifiers selectively, depending on the host. Heavily based on
--   <a>XMonad.Layout.PerWorkspace</a> by Brent Yorgey.
module XMonad.Layout.OnHost

-- | Structure for representing a host-specific layout along with a layout
--   for all other hosts. We store the names of hosts to be matched, and
--   the two layouts. We save the layout choice in the Bool, to be used to
--   implement description.
data OnHost l1 l2 a

-- | Specify one layout to use on a particular host, and another to use on
--   all others. The second layout can be another call to <a>onHost</a>,
--   and so on.
onHost :: (LayoutClass l1 a, LayoutClass l2 a) => String -> l1 a -> l2 a -> OnHost l1 l2 a

-- | Specify one layout to use on a particular set of hosts, and another to
--   use on all other hosts.
onHosts :: (LayoutClass l1 a, LayoutClass l2 a) => [String] -> l1 a -> l2 a -> OnHost l1 l2 a

-- | Specify a layout modifier to apply on a particular host; layouts on
--   all other hosts will remain unmodified.
modHost :: LayoutClass l a => String -> (l a -> ModifiedLayout lm l a) -> l a -> OnHost (ModifiedLayout lm l) l a

-- | Specify a layout modifier to apply on a particular set of hosts;
--   layouts on all other hosts will remain unmodified.
modHosts :: LayoutClass l a => [String] -> (l a -> ModifiedLayout lm l a) -> l a -> OnHost (ModifiedLayout lm l) l a
instance (GHC.Show.Show (l1 a), GHC.Show.Show (l2 a)) => GHC.Show.Show (XMonad.Layout.OnHost.OnHost l1 l2 a)
instance (GHC.Read.Read (l1 a), GHC.Read.Read (l2 a)) => GHC.Read.Read (XMonad.Layout.OnHost.OnHost l1 l2 a)
instance (XMonad.Core.LayoutClass l1 a, XMonad.Core.LayoutClass l2 a, GHC.Show.Show a) => XMonad.Core.LayoutClass (XMonad.Layout.OnHost.OnHost l1 l2) a


-- | A module for assigning a name to a given layout. Deprecated, use
--   <a>XMonad.Layout.Renamed</a> instead.

-- | <i>Deprecated: Use XMonad.Layout.Renamed instead</i>
module XMonad.Layout.Named

-- | Rename a layout. (Convenience alias for <tt>renamed [Replace s]</tt>.)
named :: String -> l a -> ModifiedLayout Rename l a

-- | (Deprecated) Remove the first word of the name.
nameTail :: l a -> ModifiedLayout Rename l a


-- | Provides message "escaping" and filtering facilities which help
--   control complex nested layouts.
module XMonad.Layout.MessageControl

-- | the Ignore layout modifier. Prevents its inner layout from receiving
--   messages of a certain type.
data Ignore m l w

-- | Applies the Ignore layout modifier to a layout, blocking all messages
--   of the same type as the one passed as its first argument.
ignore :: (Message m, LayoutClass l w) => m -> l w -> Ignore m l w

-- | the UnEscape layout modifier. Listens to <a>EscapedMessage</a>s and
--   sends their nested message to the inner layout.
data UnEscape w

-- | Applies the UnEscape layout modifier to a layout.
unEscape :: LayoutClass l w => l w -> ModifiedLayout UnEscape l w

-- | Data type for an escaped message. Send with <a>escape</a>.
newtype EscapedMessage
Escape :: SomeMessage -> EscapedMessage

-- | Creates an <a>EscapedMessage</a>.
escape :: Message m => m -> EscapedMessage
instance GHC.Read.Read (l w) => GHC.Read.Read (XMonad.Layout.MessageControl.Ignore m l w)
instance GHC.Show.Show (l w) => GHC.Show.Show (XMonad.Layout.MessageControl.Ignore m l w)
instance GHC.Read.Read (XMonad.Layout.MessageControl.UnEscape w)
instance GHC.Show.Show (XMonad.Layout.MessageControl.UnEscape w)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.MessageControl.UnEscape a
instance XMonad.Core.Message XMonad.Layout.MessageControl.EscapedMessage
instance (XMonad.Core.Message m, XMonad.Core.LayoutClass l w) => XMonad.Core.LayoutClass (XMonad.Layout.MessageControl.Ignore m l) w


-- | Temporarily yanks the focused window out of the layout to mostly fill
--   the screen.
module XMonad.Layout.Maximize
maximize :: LayoutClass l Window => l Window -> ModifiedLayout Maximize l Window

-- | Like <a>maximize</a>, but allows you to specify the amount of padding
--   placed around the maximized window.
maximizeWithPadding :: LayoutClass l Window => Dimension -> l Window -> ModifiedLayout Maximize l Window
maximizeRestore :: Window -> MaximizeRestore
data Maximize a
data MaximizeRestore
instance GHC.Show.Show (XMonad.Layout.Maximize.Maximize a)
instance GHC.Read.Read (XMonad.Layout.Maximize.Maximize a)
instance GHC.Classes.Eq XMonad.Layout.Maximize.MaximizeRestore
instance XMonad.Core.Message XMonad.Layout.Maximize.MaximizeRestore
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Maximize.Maximize Graphics.X11.Types.Window


-- | Layout modfier that adds a master window to another layout.
module XMonad.Layout.Master
mastered :: LayoutClass l a => Rational -> Rational -> l a -> ModifiedLayout AddMaster l a
fixMastered :: LayoutClass l a => Rational -> Rational -> l a -> ModifiedLayout FixMaster l a
multimastered :: LayoutClass l a => Int -> Rational -> Rational -> l a -> ModifiedLayout AddMaster l a

-- | Data type for LayoutModifier which converts given layout to a mastered
--   layout
data AddMaster a
instance GHC.Read.Read (XMonad.Layout.Master.AddMaster a)
instance GHC.Show.Show (XMonad.Layout.Master.AddMaster a)
instance GHC.Read.Read (XMonad.Layout.Master.FixMaster a)
instance GHC.Show.Show (XMonad.Layout.Master.FixMaster a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Master.FixMaster Graphics.X11.Types.Window
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Master.AddMaster Graphics.X11.Types.Window


-- | This is a layout modifier that will make a layout change the size of
--   the window that has focus.
--   
--   <a>Example screenshot using <tt>magnifiercz' 1.3</tt> with one of the
--   two stack windows focused.</a>
module XMonad.Layout.Magnifier

-- | Add magnification capabilities to a certain layout.
--   
--   For example, to re-create <a>magnifiercz</a> 1.3', you would do
--   
--   <pre>
--   &gt;&gt;&gt; magnify 1.3 (NoMaster 1) True
--   </pre>
magnify :: Rational -> MagnifyThis -> Bool -> l a -> ModifiedLayout Magnifier l a

-- | Like <a>magnify</a>, but with the ability to specify different amounts
--   of horizontal and vertical magnification.
--   
--   <pre>
--   &gt;&gt;&gt; magnifyxy 1.3 1.6 (NoMaster 1) True
--   </pre>
magnifyxy :: Rational -> Rational -> MagnifyThis -> Bool -> l a -> ModifiedLayout Magnifier l a

-- | Increase the size of the window that has focus
magnifier :: l a -> ModifiedLayout Magnifier l a

-- | Magnifier that defaults to Off
magnifierOff :: l a -> ModifiedLayout Magnifier l a

-- | Change the size of the window that has focus by a custom zoom
magnifiercz :: Rational -> l a -> ModifiedLayout Magnifier l a

-- | Like <a>magnifiercz</a>, but default to <tt>Off</tt>.
magnifierczOff :: Rational -> l a -> ModifiedLayout Magnifier l a

-- | Increase the size of the window that has focus by a custom zoom in
--   both directions.
magnifierxy :: Rational -> Rational -> l a -> ModifiedLayout Magnifier l a

-- | Like <a>magnifierxy</a>, but default to <tt>Off</tt>.
magnifierxyOff :: Rational -> Rational -> l a -> ModifiedLayout Magnifier l a

-- | A magnifier that greatly magnifies the focused window; defaults to
--   <tt>Off</tt>.
maxMagnifierOff :: l a -> ModifiedLayout Magnifier l a

-- | A magnifier that greatly magnifies just the vertical direction;
--   defaults to <tt>Off</tt>.
maximizeVertical :: l a -> ModifiedLayout Magnifier l a

-- | Increase the size of the window that has focus, unless if it is one of
--   the master windows.
magnifier' :: l a -> ModifiedLayout Magnifier l a

-- | Increase the size of the window that has focus by a custom zoom,
--   unless if it is one of the the master windows.
magnifiercz' :: Rational -> l a -> ModifiedLayout Magnifier l a

-- | Like <a>magnifiercz'</a>, but default to <tt>Off</tt>.
magnifierczOff' :: Rational -> l a -> ModifiedLayout Magnifier l a

-- | Increase the size of the window that has focus by a custom zoom in
--   both directions, unless it is one of the master windows.
magnifierxy' :: Rational -> Rational -> l a -> ModifiedLayout Magnifier l a

-- | Like <a>magnifierxy'</a>, but defaults to <tt>Off</tt>.
magnifierxyOff' :: Rational -> Rational -> l a -> ModifiedLayout Magnifier l a
data MagnifyMsg
MagnifyMore :: MagnifyMsg
MagnifyLess :: MagnifyMsg
ToggleOn :: MagnifyMsg
ToggleOff :: MagnifyMsg
Toggle :: MagnifyMsg

-- | Which windows to magnify and when to start doing so. Note that
--   magnifying will start <i>at</i> the cut-off, so <tt>AllWins 3</tt>
--   will start magnifying when there are at least three windows present in
--   the stack set.
data MagnifyThis

-- | Every window
AllWins :: !Natural -> MagnifyThis

-- | Only stack windows
NoMaster :: !Natural -> MagnifyThis

-- | The type for magnifying a given type; do note that the given type
--   <tt>a</tt> is a phantom type.
data Magnifier a
instance GHC.Show.Show XMonad.Layout.Magnifier.Toggle
instance GHC.Read.Read XMonad.Layout.Magnifier.Toggle
instance GHC.Show.Show XMonad.Layout.Magnifier.MagnifyThis
instance GHC.Read.Read XMonad.Layout.Magnifier.MagnifyThis
instance GHC.Show.Show (XMonad.Layout.Magnifier.Magnifier a)
instance GHC.Read.Read (XMonad.Layout.Magnifier.Magnifier a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Magnifier.Magnifier Graphics.X11.Types.Window
instance XMonad.Core.Message XMonad.Layout.Magnifier.MagnifyMsg


-- | A layout modifier that limits the number of windows that can be shown.
--   See <a>XMonad.Layout.Minimize</a> for manually setting hidden windows.
module XMonad.Layout.LimitWindows

-- | Only display the first <tt>n</tt> windows.
limitWindows :: Int -> l a -> ModifiedLayout LimitWindows l a

-- | Only display <tt>n</tt> windows around the focused window. This makes
--   sense with layouts that arrange windows linearily, like
--   <a>XMonad.Layout.Accordion</a>.
limitSlice :: Int -> l a -> ModifiedLayout LimitWindows l a

-- | Only display the first <tt>m</tt> windows and <tt>r</tt> others. The
--   <tt>IncMasterN</tt> message will change <tt>m</tt>, as well as passing
--   it onto the underlying layout.
limitSelect :: Int -> Int -> l a -> ModifiedLayout Selection l a
increaseLimit :: X ()
decreaseLimit :: X ()
setLimit :: Int -> X ()
data LimitWindows a
data Selection a
instance GHC.Show.Show XMonad.Layout.LimitWindows.SliceStyle
instance GHC.Read.Read XMonad.Layout.LimitWindows.SliceStyle
instance GHC.Show.Show (XMonad.Layout.LimitWindows.LimitWindows a)
instance GHC.Read.Read (XMonad.Layout.LimitWindows.LimitWindows a)
instance GHC.Classes.Eq (XMonad.Layout.LimitWindows.Selection a)
instance GHC.Show.Show (XMonad.Layout.LimitWindows.Selection a)
instance GHC.Read.Read (XMonad.Layout.LimitWindows.Selection a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.LimitWindows.Selection a
instance XMonad.Core.Message XMonad.Layout.LimitWindows.LimitChange
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.LimitWindows.LimitWindows a


-- | Similar to <a>XMonad.Layout.Minimize</a> but completely removes
--   windows from the window set so <a>XMonad.Layout.BoringWindows</a>
--   isn't necessary. Perfect companion to
--   <a>XMonad.Layout.BinarySpacePartition</a> since it can be used to move
--   windows to another part of the BSP tree.
module XMonad.Layout.Hidden
data HiddenWindows a

-- | Messages for the <tt>HiddenWindows</tt> layout modifier.
data HiddenMsg

-- | Hide a window.
HideWindow :: Window -> HiddenMsg

-- | Restore window (FILO).
PopNewestHiddenWindow :: HiddenMsg

-- | Restore window (FIFO).
PopOldestHiddenWindow :: HiddenMsg

-- | Restore specific window.
PopSpecificHiddenWindow :: Window -> HiddenMsg

-- | Apply the <tt>HiddenWindows</tt> layout modifier.
hiddenWindows :: LayoutClass l Window => l Window -> ModifiedLayout HiddenWindows l Window

-- | Remove the given window from the current layout. It is placed in list
--   of hidden windows so it can be restored later.
hideWindow :: Window -> X ()

-- | Restore a previously hidden window. Using this function will treat the
--   list of hidden windows as a FIFO queue. That is, the first window
--   hidden will be restored.
popOldestHiddenWindow :: X ()

-- | Restore a previously hidden window. Using this function will treat the
--   list of hidden windows as a FILO queue. That is, the most recently
--   hidden window will be restored.
popNewestHiddenWindow :: X ()
popHiddenWindow :: Window -> X ()
instance GHC.Read.Read (XMonad.Layout.Hidden.HiddenWindows a)
instance GHC.Show.Show (XMonad.Layout.Hidden.HiddenWindows a)
instance GHC.Classes.Eq XMonad.Layout.Hidden.HiddenMsg
instance XMonad.Core.Message XMonad.Layout.Hidden.HiddenMsg
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Hidden.HiddenWindows Graphics.X11.Types.Window


-- | A helper module to visualize the process of dragging a window by
--   making it follow the mouse cursor. See
--   <a>XMonad.Layout.WindowSwitcherDecoration</a> for a module that makes
--   use of this.
module XMonad.Layout.DraggingVisualizer
draggingVisualizer :: LayoutClass l Window => l Window -> ModifiedLayout DraggingVisualizer l Window
data DraggingVisualizerMsg
DraggingWindow :: Window -> Rectangle -> DraggingVisualizerMsg
DraggingStopped :: DraggingVisualizerMsg
data DraggingVisualizer a
instance GHC.Show.Show (XMonad.Layout.DraggingVisualizer.DraggingVisualizer a)
instance GHC.Read.Read (XMonad.Layout.DraggingVisualizer.DraggingVisualizer a)
instance GHC.Classes.Eq XMonad.Layout.DraggingVisualizer.DraggingVisualizerMsg
instance XMonad.Core.Message XMonad.Layout.DraggingVisualizer.DraggingVisualizerMsg
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.DraggingVisualizer.DraggingVisualizer Graphics.X11.Types.Window


-- | Two layout modifiers. centerMaster places master window at center, on
--   top of all other windows, which are managed by base layout.
--   topRightMaster is similar, but places master window in top right
--   corner instead of center.
module XMonad.Layout.CenteredMaster

-- | Modifier that puts master window in center, other windows in
--   background are managed by given layout
centerMaster :: LayoutClass l a => l a -> ModifiedLayout CenteredMaster l a

-- | Modifier that puts master window in top right corner, other windows in
--   background are managed by given layout
topRightMaster :: LayoutClass l a => l a -> ModifiedLayout TopRightMaster l a

-- | Data type for LayoutModifier
data CenteredMaster a
data TopRightMaster a
instance GHC.Show.Show (XMonad.Layout.CenteredMaster.CenteredMaster a)
instance GHC.Read.Read (XMonad.Layout.CenteredMaster.CenteredMaster a)
instance GHC.Show.Show (XMonad.Layout.CenteredMaster.TopRightMaster a)
instance GHC.Read.Read (XMonad.Layout.CenteredMaster.TopRightMaster a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.CenteredMaster.TopRightMaster Graphics.X11.Types.Window
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.CenteredMaster.CenteredMaster Graphics.X11.Types.Window


-- | Provides IfMax layout, which will run one layout if there are maximum
--   N windows on workspace, and another layout, when number of windows is
--   greater than N.
module XMonad.Layout.IfMax
data IfMax l1 l2 w
IfMax :: Int -> l1 w -> l2 w -> IfMax l1 l2 w

-- | Layout itself
ifMax :: (LayoutClass l1 w, LayoutClass l2 w) => Int -> l1 w -> l2 w -> IfMax l1 l2 w
instance (GHC.Show.Show (l1 w), GHC.Show.Show (l2 w)) => GHC.Show.Show (XMonad.Layout.IfMax.IfMax l1 l2 w)
instance (GHC.Read.Read (l1 w), GHC.Read.Read (l2 w)) => GHC.Read.Read (XMonad.Layout.IfMax.IfMax l1 l2 w)
instance (XMonad.Core.LayoutClass l1 Graphics.X11.Types.Window, XMonad.Core.LayoutClass l2 Graphics.X11.Types.Window) => XMonad.Core.LayoutClass (XMonad.Layout.IfMax.IfMax l1 l2) Graphics.X11.Types.Window


-- | A gapless tiled layout that attempts to obey window size hints, rather
--   than simply ignoring them.
module XMonad.Layout.HintedTile
data HintedTile a
HintedTile :: !Int -> !Rational -> !Rational -> !Alignment -> !Orientation -> HintedTile a

-- | number of windows in the master pane
[nmaster] :: HintedTile a -> !Int

-- | how much to change when resizing
[delta] :: HintedTile a -> !Rational

-- | ratio between master/nonmaster panes
[frac] :: HintedTile a -> !Rational

-- | Where to place windows that are smaller than their preordained
--   rectangles.
[alignment] :: HintedTile a -> !Alignment

-- | Tall or Wide (mirrored) layout?
[orientation] :: HintedTile a -> !Orientation
data Orientation

-- | Lay out windows similarly to Mirror tiled.
Wide :: Orientation

-- | Lay out windows similarly to tiled.
Tall :: Orientation
data Alignment
TopLeft :: Alignment
Center :: Alignment
BottomRight :: Alignment
instance GHC.Classes.Ord XMonad.Layout.HintedTile.Orientation
instance GHC.Classes.Eq XMonad.Layout.HintedTile.Orientation
instance GHC.Read.Read XMonad.Layout.HintedTile.Orientation
instance GHC.Show.Show XMonad.Layout.HintedTile.Orientation
instance GHC.Classes.Ord XMonad.Layout.HintedTile.Alignment
instance GHC.Classes.Eq XMonad.Layout.HintedTile.Alignment
instance GHC.Read.Read XMonad.Layout.HintedTile.Alignment
instance GHC.Show.Show XMonad.Layout.HintedTile.Alignment
instance GHC.Read.Read (XMonad.Layout.HintedTile.HintedTile a)
instance GHC.Show.Show (XMonad.Layout.HintedTile.HintedTile a)
instance XMonad.Core.LayoutClass XMonad.Layout.HintedTile.HintedTile Graphics.X11.Types.Window


-- | A not so simple layout that attempts to put all windows in a square
--   grid while obeying their size hints.
module XMonad.Layout.HintedGrid

-- | Automatic mirroring of hinted layouts doesn't work very well, so this
--   <a>Grid</a> comes with built-in mirroring. <tt>Grid False</tt> is the
--   normal layout, <tt>Grid True</tt> is the mirrored variant (rotated by
--   90 degrees).
data Grid a
Grid :: Bool -> Grid a
GridRatio :: Double -> Bool -> Grid a

-- | The internal function for computing the grid layout.
arrange :: Double -> Bool -> Rectangle -> [Window] -> X [(Window, Rectangle)]
defaultRatio :: Double
instance GHC.Show.Show (XMonad.Layout.HintedGrid.Grid a)
instance GHC.Read.Read (XMonad.Layout.HintedGrid.Grid a)
instance XMonad.Core.LayoutClass XMonad.Layout.HintedGrid.Grid Graphics.X11.Types.Window


-- | Two layouts: one is a variant of the Grid layout that allows the
--   desired aspect ratio of windows to be specified. The other is like
--   Tall but places a grid with fixed number of rows and columns in the
--   master area and uses an aspect-ratio-specified layout for the slaves.
module XMonad.Layout.GridVariants

-- | The geometry change message understood by the master grid
data ChangeMasterGridGeom

-- | Change the number of master rows
IncMasterRows :: !Int -> ChangeMasterGridGeom

-- | Change the number of master columns
IncMasterCols :: !Int -> ChangeMasterGridGeom

-- | Set the number of master rows to absolute value
SetMasterRows :: !Int -> ChangeMasterGridGeom

-- | Set the number of master columns to absolute value
SetMasterCols :: !Int -> ChangeMasterGridGeom

-- | Set the fraction of the screen used by the master grid
SetMasterFraction :: !Rational -> ChangeMasterGridGeom

-- | Geometry change messages understood by Grid and SplitGrid
data ChangeGridGeom
SetGridAspect :: !Rational -> ChangeGridGeom
ChangeGridAspect :: !Rational -> ChangeGridGeom

-- | Grid layout. The parameter is the desired x:y aspect ratio of windows
newtype Grid a
Grid :: Rational -> Grid a

-- | TallGrid layout. Parameters are
--   
--   <ul>
--   <li>number of master rows</li>
--   <li>number of master columns</li>
--   <li>portion of screen used for master grid</li>
--   <li>x:y aspect ratio of slave windows</li>
--   <li>increment for resize messages</li>
--   </ul>
--   
--   This exists mostly because it was introduced in an earlier version.
--   It's a fairly thin wrapper around "SplitGrid L".
data TallGrid a
TallGrid :: !Int -> !Int -> !Rational -> !Rational -> !Rational -> TallGrid a

-- | SplitGrid layout. Parameters are
--   
--   <ul>
--   <li>side where the master is</li>
--   <li>number of master rows</li>
--   <li>number of master columns</li>
--   <li>portion of screen used for master grid</li>
--   <li>x:y aspect ratio of slave windows</li>
--   <li>increment for resize messages</li>
--   </ul>
data SplitGrid a
SplitGrid :: Orientation -> !Int -> !Int -> !Rational -> !Rational -> !Rational -> SplitGrid a

-- | Type to specify the side of the screen that holds the master area of a
--   SplitGrid.
data Orientation
T :: Orientation
B :: Orientation
L :: Orientation
R :: Orientation
instance GHC.Show.Show (XMonad.Layout.GridVariants.Grid a)
instance GHC.Read.Read (XMonad.Layout.GridVariants.Grid a)
instance GHC.Show.Show XMonad.Layout.GridVariants.Orientation
instance GHC.Read.Read XMonad.Layout.GridVariants.Orientation
instance GHC.Classes.Eq XMonad.Layout.GridVariants.Orientation
instance GHC.Show.Show (XMonad.Layout.GridVariants.SplitGrid a)
instance GHC.Read.Read (XMonad.Layout.GridVariants.SplitGrid a)
instance GHC.Show.Show (XMonad.Layout.GridVariants.TallGrid a)
instance GHC.Read.Read (XMonad.Layout.GridVariants.TallGrid a)
instance XMonad.Core.LayoutClass XMonad.Layout.GridVariants.TallGrid a
instance XMonad.Core.Message XMonad.Layout.GridVariants.ChangeMasterGridGeom
instance XMonad.Core.LayoutClass XMonad.Layout.GridVariants.SplitGrid a
instance XMonad.Core.Message XMonad.Layout.GridVariants.ChangeGridGeom
instance XMonad.Core.LayoutClass XMonad.Layout.GridVariants.Grid a


-- | A layout much like Tall, but using a multiple of a window's minimum
--   resize amount instead of a percentage of screen to decide where to
--   split. This is useful when you usually leave a text editor or terminal
--   in the master pane and like it to be 80 columns wide.
module XMonad.Layout.FixedColumn

-- | A tiling mode based on preserving a nice fixed width window. Supports
--   <a>Shrink</a>, <a>Expand</a> and <a>IncMasterN</a>.
data FixedColumn a
FixedColumn :: !Int -> !Int -> !Int -> !Int -> FixedColumn a
instance GHC.Show.Show (XMonad.Layout.FixedColumn.FixedColumn a)
instance GHC.Read.Read (XMonad.Layout.FixedColumn.FixedColumn a)
instance XMonad.Core.LayoutClass XMonad.Layout.FixedColumn.FixedColumn Graphics.X11.Types.Window


-- | Dishes is a layout that stacks extra windows underneath the master
--   windows.
module XMonad.Layout.Dishes
data Dishes a
Dishes :: Int -> Rational -> Dishes a
instance GHC.Read.Read (XMonad.Layout.Dishes.Dishes a)
instance GHC.Show.Show (XMonad.Layout.Dishes.Dishes a)
instance XMonad.Core.LayoutClass XMonad.Layout.Dishes.Dishes a


-- | A Cross Layout with the main window in the center.

-- | <i>Deprecated: Use XMonad.Layout.Circle or
--   XMonad.Layout.ThreeColumn.ThreeColMid instead</i>
module XMonad.Layout.Cross

-- | A simple Cross Layout. It places the focused window in the center. The
--   proportion of the screen used by the main window is 4/5.
simpleCross :: Cross a

-- | The Cross Layout draws the focused window in the center of the screen
--   and part of the other windows on the sides. The <a>Shrink</a> and
--   <a>Expand</a> messages increment the size of the main window.
--   
--   The focus keybindings change the center window, while other windows
--   cycle through the side positions. With the Cross layout only four
--   windows are shown around the focused window, two ups and two downs, no
--   matter how many are in the current stack. I.e. focus down cycles the
--   window below focused into the center; focus up cycles the window
--   above.
data Cross a
Cross :: !Rational -> !Rational -> Cross a

-- | Proportion of screen occupied by the main window.
[crossProp] :: Cross a -> !Rational

-- | Percent of main window to increment by when resizing.
[crossInc] :: Cross a -> !Rational
instance GHC.Read.Read (XMonad.Layout.Cross.Cross a)
instance GHC.Show.Show (XMonad.Layout.Cross.Cross a)
instance XMonad.Core.LayoutClass XMonad.Layout.Cross.Cross a


-- | Circle is an elliptical, overlapping layout. Original code by Peter De
--   Wachter, extended by Ilya Porntov.
module XMonad.Layout.CircleEx

-- | The layout data type. It is recommended to not use the <a>CircleEx</a>
--   data constructor directly, and instead rely on record update syntax;
--   for example: <tt>circleEx {cMasterRatio = 4%5}</tt>. In this way you
--   can avoid nasty surprises if one day additional fields are added to
--   <tt>CircleEx</tt>.
data CircleEx a
CircleEx :: !Int -> !Rational -> !Rational -> !Rational -> !Double -> CircleEx a

-- | Number of master windows. Default value is 1.
[cNMaster] :: CircleEx a -> !Int

-- | Size of master window in relation to screen size. Default value is
--   <tt>4%5</tt>.
[cMasterRatio] :: CircleEx a -> !Rational

-- | Size of first secondary window in relation to screen size. Default
--   value is <tt>3%5</tt>.
[cStackRatio] :: CircleEx a -> !Rational

-- | Coefficient used to calculate the sizes of subsequent secondary
--   windows. The size of the next window is calculated as the size of the
--   previous one multiplied by this value. This value is also used to
--   scale master windows, in case there is more than one. Default value is
--   <tt>5%6</tt>. Set this to 1 if you want all secondary windows to have
--   the same size.
[cMultiplier] :: CircleEx a -> !Rational

-- | Angle of rotation of the whole circle layout. Usual values are from 0
--   to 2π, although it will work outside this range as well. Default value
--   of 0 means that the first secondary window will be placed at the right
--   side of screen.
[cDelta] :: CircleEx a -> !Double

-- | Circle layout with default settings:
--   
--   <ul>
--   <li>Number of master windows is set to 1</li>
--   <li><tt>cMasterRatio</tt> is set to <tt>70/99</tt>, which is nearly
--   <tt>1/sqrt(2)</tt></li>
--   <li><tt>cStackRatio</tt> is set to <tt>2/5</tt></li>
--   <li><tt>cMultiplier</tt> is set to 1, which means all secondary
--   windows will have the same size</li>
--   </ul>
--   
--   This can be used as a drop-in replacement for
--   <a>XMonad.Layout.Circle</a>.
circle :: CircleEx a

-- | Another variant of default settings for circle layout:
--   
--   <ul>
--   <li>Number of master windows is set to 1</li>
--   <li><tt>cMasterRatio</tt> is set to <tt>4/5</tt></li>
--   <li><tt>cStackRatio</tt> is set to <tt>3/5</tt></li>
--   <li><tt>cMultiplier</tt> is set to <tt>5/6</tt></li>
--   </ul>
circleEx :: CircleEx a

-- | Specific messages understood by CircleEx layout.
data CircleExMsg

-- | Rotate secondary windows by specific angle
Rotate :: !Double -> CircleExMsg

-- | Increase (or decrease, with negative value) sizes of secondary windows
IncStackRatio :: !Rational -> CircleExMsg

-- | Increase <a>cMultiplier</a>.
IncMultiplier :: !Rational -> CircleExMsg
instance GHC.Read.Read (XMonad.Layout.CircleEx.CircleEx a)
instance GHC.Show.Show (XMonad.Layout.CircleEx.CircleEx a)
instance GHC.Classes.Eq (XMonad.Layout.CircleEx.CircleEx a)
instance GHC.Show.Show XMonad.Layout.CircleEx.CircleExMsg
instance GHC.Classes.Eq XMonad.Layout.CircleEx.CircleExMsg
instance XMonad.Core.Message XMonad.Layout.CircleEx.CircleExMsg
instance XMonad.Core.LayoutClass XMonad.Layout.CircleEx.CircleEx Graphics.X11.Types.Window


-- | Circle is an elliptical, overlapping layout, by Peter De Wachter

-- | <i>Deprecated: Use XMonad.Layout.CircleEx instead</i>
module XMonad.Layout.Circle
pattern Circle :: CircleEx a


-- | A layout modifier that, if there is only a single window on screen,
--   places that window in the center of the screen. This is especially
--   useful on wide screen setups, where the window would otherwise be
--   unnecessarily far away from the center of your field of vision.
module XMonad.Layout.CenteredIfSingle

-- | Layout Modifier that places a window in the center of the screen,
--   leaving room on all sides if there is only a single window
centeredIfSingle :: Double -> Double -> l a -> ModifiedLayout CenteredIfSingle l a

-- | Layout Modifier that places a window in the center of the screen,
--   leaving room on the left and right if there is only a single window.
--   The first argument is the horizontal and the second one the vertical
--   ratio of the screen the centered window should take up. Both numbers
--   should be between 0.0 and 1.0.
data CenteredIfSingle a
instance GHC.Read.Read (XMonad.Layout.CenteredIfSingle.CenteredIfSingle a)
instance GHC.Show.Show (XMonad.Layout.CenteredIfSingle.CenteredIfSingle a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.CenteredIfSingle.CenteredIfSingle Graphics.X11.Types.Window


-- | Find a maximum empty rectangle around floating windows and use that
--   area to display non-floating windows.
module XMonad.Layout.AvoidFloats

-- | Avoid floating windows unless the resulting area for windows would be
--   too small. In that case, use the whole screen as if this layout
--   modifier wasn't there. No windows are avoided by default, they need to
--   be added using signals.
avoidFloats :: l a -> ModifiedLayout AvoidFloats l a

-- | Avoid floating windows unless the resulting area for windows would be
--   too small. In that case, use the whole screen as if this layout
--   modifier wasn't there.
avoidFloats' :: Int -> Int -> Bool -> l a -> ModifiedLayout AvoidFloats l a

-- | Change the state of the whole avoid float layout modifier.
data AvoidFloatMsg

-- | Toggle between avoiding all or only selected.
AvoidFloatToggle :: AvoidFloatMsg

-- | Set if all all floating windows should be avoided.
AvoidFloatSet :: Bool -> AvoidFloatMsg

-- | Clear the set of windows to specifically avoid.
AvoidFloatClearItems :: AvoidFloatMsg

-- | Change the state of the avoid float layout modifier conserning a
--   specific window.
data AvoidFloatItemMsg a

-- | Add a window to always avoid.
AvoidFloatAddItem :: a -> AvoidFloatItemMsg a

-- | Stop always avoiding selected window.
AvoidFloatRemoveItem :: a -> AvoidFloatItemMsg a

-- | Toggle between always avoiding selected window.
AvoidFloatToggleItem :: a -> AvoidFloatItemMsg a
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.AvoidFloats.AvoidFloats a)
instance (GHC.Classes.Ord a, GHC.Read.Read a) => GHC.Read.Read (XMonad.Layout.AvoidFloats.AvoidFloats a)
instance Data.Typeable.Internal.Typeable a => XMonad.Core.Message (XMonad.Layout.AvoidFloats.AvoidFloatItemMsg a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.AvoidFloats.AvoidFloats Graphics.X11.Types.Window
instance XMonad.Core.Message XMonad.Layout.AvoidFloats.AvoidFloatMsg


-- | Provides layout modifier AutoMaster. It separates screen in two parts
--   - master and slave. Size of slave area automatically changes depending
--   on number of slave windows.
module XMonad.Layout.AutoMaster

-- | User interface function
autoMaster :: LayoutClass l a => Int -> Float -> l a -> ModifiedLayout AutoMaster l a

-- | Data type for layout modifier
data AutoMaster a
instance GHC.Show.Show (XMonad.Layout.AutoMaster.AutoMaster a)
instance GHC.Read.Read (XMonad.Layout.AutoMaster.AutoMaster a)
instance GHC.Classes.Eq w => XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.AutoMaster.AutoMaster w


-- | A ManageHook matching on XProperties.
module XMonad.Hooks.XPropManage
xPropManageHook :: [XPropMatch] -> ManageHook
type XPropMatch = ([(Atom, [String] -> Bool)], Window -> X (WindowSet -> WindowSet))
pmX :: (Window -> X ()) -> Window -> X (WindowSet -> WindowSet)
pmP :: (WindowSet -> WindowSet) -> Window -> X (WindowSet -> WindowSet)


-- | Useful in a dual-head setup: Looks at the requested geometry of new
--   windows and moves them to the workspace of the non-focused screen if
--   necessary.
module XMonad.Hooks.WorkspaceByPos
workspaceByPos :: ManageHook


-- | This module exports additional X properties that allow <a>taffybar</a>
--   to understand the state of XMonad.
module XMonad.Hooks.TaffybarPagerHints

-- | Add support for the "Current Layout" and "Visible Workspaces" custom
--   hints to the given config.
pagerHints :: XConfig a -> XConfig a

-- | Update the current values of both custom hints.
pagerHintsLogHook :: X ()

-- | Handle all "Current Layout" events received from pager widgets, and
--   set the current layout accordingly.
pagerHintsEventHook :: Event -> X All

-- | Set the value of the "Current Layout" custom hint to the one given.
setCurrentLayoutProp :: String -> X ()

-- | Set the value of the "Visible Workspaces" hint to the one given.
setVisibleWorkspacesProp :: [String] -> X ()


-- | Sets the WM name to a given string, so that it could be detected using
--   _NET_SUPPORTING_WM_CHECK protocol.
--   
--   May be useful for making Java GUI programs work, just set WM name to
--   "LG3D" and use Java 1.6u1 (1.6.0_01-ea-b03 works for me) or later.
--   
--   To your <tt>xmonad.hs</tt> file, add the following line:
--   
--   <pre>
--   import XMonad.Hooks.SetWMName
--   </pre>
--   
--   Then edit your <tt>startupHook</tt>:
--   
--   <pre>
--   startupHook = setWMName "LG3D"
--   </pre>
--   
--   For details on the problems with running Java GUI programs in
--   non-reparenting WMs, see
--   <a>http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6429775</a> and
--   related bugs.
--   
--   Setting WM name to "compiz" does not solve the problem, because of yet
--   another bug in AWT code (related to insets). For LG3D insets are
--   explicitly set to 0, while for other WMs the insets are "guessed" and
--   the algorithm fails miserably by guessing absolutely bogus values.
--   
--   For detailed instructions on editing your hooks, see <a>the
--   tutorial</a> and <a>XMonad.Doc.Extending</a>.
module XMonad.Hooks.SetWMName

-- | sets WM name
setWMName :: String -> X ()

-- | Get WM name.
getWMName :: X String


-- | Module to apply a ManageHook to an already-mapped window when a
--   property changes. This would commonly be used to match browser windows
--   by title, since the final title will only be set after (a) the window
--   is mapped, (b) its document has been loaded, (c) all load-time scripts
--   have run. (Don't blame browsers for this; it's inherent in HTML and
--   the DOM. And changing title dynamically is explicitly permitted by
--   ICCCM and EWMH; you don't really want to have your editor window
--   umapped/remapped to show the current document and modified state in
--   the titlebar, do you?)
--   
--   This is a handleEventHook that triggers on a PropertyChange event. It
--   currently ignores properties being removed, in part because you can't
--   do anything useful in a ManageHook involving nonexistence of a
--   property.
--   
--   This module could also be useful for Electron applications like
--   Spotify which sets its WM_CLASS too late for window manager to map it
--   properly.
module XMonad.Hooks.OnPropertyChange

-- | Run a <a>ManageHook</a> when a specific property is changed on a
--   window. Note that this will run on any window which changes the
--   property, so you should be very specific in your <a>ManageHook</a>
--   matching (lots of windows change their titles on the fly!):
--   
--   <pre>
--   onXPropertyChange "WM_NAME" (className =? "Iceweasel" &lt;&amp;&amp;&gt; title =? "whatever" --&gt; doShift "2")
--   </pre>
--   
--   Note that the fixity of (--&gt;) won't allow it to be mixed with ($),
--   so you can't use the obvious $ shorthand.
--   
--   <pre>
--   onXPropertyChange "WM_NAME" $ title =? "Foo" --&gt; doFloat -- won't work!
--   </pre>
--   
--   Consider instead phrasing it like any other <a>ManageHook</a>:
--   
--   <pre>
--   main = xmonad $ def
--       { ...
--       , handleEventHook = onXPropertyChange "WM_NAME" myDynHook
--       , ...
--       }
--   
--     myDynHook = composeAll [...]
--   </pre>
onXPropertyChange :: String -> ManageHook -> Event -> X All

-- | A shorthand for dynamic titles; i.e., applications changing their
--   <tt>WM_NAME</tt> property.
onTitleChange :: ManageHook -> Event -> X All

-- | A shorthand for dynamic resource and class names; i.e., applications
--   changing their <tt>WM_CLASS</tt> property.
onClassChange :: ManageHook -> Event -> X All


-- | Configure where new windows should be added and which window should be
--   focused.
module XMonad.Hooks.InsertPosition

-- | A combinator for setting up <a>insertPosition</a>.
setupInsertPosition :: Position -> Focus -> XConfig a -> XConfig a

-- | insertPosition. A manage hook for placing new windows. XMonad's
--   default is the same as using: <tt>insertPosition Above Newer</tt>.
insertPosition :: Position -> Focus -> ManageHook
data Focus
Newer :: Focus
Older :: Focus
data Position
Master :: Position
End :: Position
Above :: Position
Below :: Position


-- | Makes XMonad set the _NET_WM_WINDOW_OPACITY atom for inactive windows,
--   which causes those windows to become slightly translucent if something
--   like xcompmgr is running
module XMonad.Hooks.FadeInactive

-- | Sets the opacity of a window
setOpacity :: Window -> Rational -> X ()

-- | Returns True if the window doesn't have the focus.
isUnfocused :: Query Bool

-- | Returns True if the window doesn't have the focus, and the window is
--   on the current workspace. This is specifically handy in a multi
--   monitor setup (xinerama) where multiple workspaces are visible. Using
--   this, non-focused workspaces are are not faded out making it easier to
--   look and read the content on them.
isUnfocusedOnCurrentWS :: Query Bool

-- | Makes a window completely opaque
fadeIn :: Window -> X ()

-- | Fades a window out by setting the opacity
fadeOut :: Rational -> Window -> X ()

-- | Fades a window by the specified amount if it satisfies the first
--   query, otherwise makes it opaque.
fadeIf :: Query Bool -> Rational -> Query Rational

-- | Sets the opacity of inactive windows to the specified amount
fadeInactiveLogHook :: Rational -> X ()

-- | Set the opacity of inactive windows, on the current workspace, to the
--   specified amount. This is specifically usefull in a multi monitor
--   setup. See <a>isUnfocusedOnCurrentWS</a>.
fadeInactiveCurrentWSLogHook :: Rational -> X ()

-- | Fades out every window by the amount returned by the query.
fadeOutLogHook :: Query Rational -> X ()


-- | A more flexible and general compositing interface than FadeInactive.
--   Windows can be selected and opacity specified by means of FadeHooks,
--   which are very similar to ManageHooks and use the same machinery.
module XMonad.Hooks.FadeWindows

-- | A <a>logHook</a> to fade windows under control of a <a>FadeHook</a>,
--   which is similar to but not identical to <a>ManageHook</a>.
fadeWindowsLogHook :: FadeHook -> X ()

-- | A FadeHook is similar to a ManageHook, but records window opacity.
type FadeHook = Query Opacity
data Opacity

-- | The identity <a>FadeHook</a>, which renders windows <a>opaque</a>.
idFadeHook :: FadeHook

-- | Render a window fully opaque.
opaque :: FadeHook

-- | An alias for <a>opaque</a>.
solid :: FadeHook

-- | Render a window fully transparent.
transparent :: FadeHook

-- | An alias for <a>transparent</a>.
invisible :: FadeHook

-- | Specify a window's transparency.
transparency :: Rational -> FadeHook

-- | An alias for <a>transparency</a>.
translucence :: Rational -> FadeHook

-- | An alias for <a>opacity</a>.
fadeBy :: Rational -> FadeHook

-- | Specify a window's opacity; this is the inverse of
--   <a>transparency</a>.
opacity :: Rational -> FadeHook

-- | An alias for <a>transparency</a>.
fadeTo :: Rational -> FadeHook

-- | A <a>handleEventHook</a> to handle fading and unfading of newly mapped
--   or unmapped windows; this avoids problems with layouts such as
--   <a>Full</a> or <a>XMonad.Layout.Tabbed</a>. This hook may also be
--   useful with <a>XMonad.Hooks.FadeInactive</a>.
fadeWindowsEventHook :: Event -> X All

-- | Like <tt>doF</tt>, but usable with <a>ManageHook</a>-like hooks that
--   aren't <a>Query</a> wrapped around transforming functions
--   (<a>Endo</a>).
doS :: Monoid m => m -> Query m

-- | A Query to determine if a window is floating.
isFloating :: Query Bool

-- | Returns True if the window doesn't have the focus.
isUnfocused :: Query Bool
instance GHC.Base.Semigroup XMonad.Hooks.FadeWindows.Opacity
instance GHC.Base.Monoid XMonad.Hooks.FadeWindows.Opacity



-- | <i>Deprecated: Use <a>XMonad.Hooks.OnPropertyChange</a> instead.</i>
module XMonad.Hooks.DynamicProperty

-- | <a>dynamicPropertyChange</a> = <a>onXPropertyChange</a>
dynamicPropertyChange :: String -> ManageHook -> Event -> X All

-- | <a>dynamicTitle</a> = <a>onTitleChange</a>
dynamicTitle :: ManageHook -> Event -> X All


-- | A debugging module to track key events, useful when you can't tell
--   whether xmonad is processing some or all key events.
module XMonad.Hooks.DebugKeyEvents

-- | Print key events to stderr for debugging
debugKeyEvents :: Event -> X All


-- | Provides functions for performing a given action on all or certain
--   groups of windows on the current workspace.
module XMonad.Actions.WithAll

-- | Un-float all floating windows on the current workspace.
sinkAll :: X ()

-- | Execute an <a>X</a> action for each window on the current workspace.
withAll :: (Window -> X ()) -> X ()

-- | Apply a function to all windows on the current workspace.
withAll' :: (Window -> WindowSet -> WindowSet) -> X ()

-- | Kill all the windows on the current workspace.
killAll :: X ()

-- | Kill all the unfocused windows on the current workspace.
killOthers :: X ()


-- | Provides a simple binding that pushes all floating windows on the
--   current workspace back into tiling. Note that the functionality of
--   this module has been folded into the more general
--   <a>XMonad.Actions.WithAll</a>; this module simply re-exports the
--   <a>sinkAll</a> function for backwards compatibility.

-- | <i>Deprecated: Use XMonad.Actions.WithAll instead</i>
module XMonad.Actions.SinkAll

-- | Un-float all floating windows on the current workspace.
sinkAll :: X ()


-- | Warp the pointer to a given window or screen.
module XMonad.Actions.Warp

-- | Move the mouse cursor to a corner of the focused window. Useful for
--   uncluttering things.
--   
--   Internally, this uses numerical parameters. We parametrize on the
--   <a>Corner</a> type so the user need not see the violence inherent in
--   the system.
--   
--   <a>warpToScreen</a> and <a>warpToWindow</a> can be used in a variety
--   of ways. Suppose you wanted to emulate Ratpoison's 'banish' command,
--   which moves the mouse pointer to a corner? warpToWindow can do that!
banish :: Corner -> X ()

-- | Same as <a>banish</a> but moves the mouse to the corner of the
--   currently focused screen
banishScreen :: Corner -> X ()
data Corner
UpperLeft :: Corner
UpperRight :: Corner
LowerLeft :: Corner
LowerRight :: Corner

-- | Warp the pointer to the given position (top left = (0,0), bottom right
--   = (1,1)) on the given screen.
warpToScreen :: ScreenId -> Rational -> Rational -> X ()

-- | Warp the pointer to a given position relative to the currently focused
--   window. Top left = (0,0), bottom right = (1,1).
warpToWindow :: Rational -> Rational -> X ()


-- | Causes the pointer to follow whichever window focus changes to.
--   Compliments the idea of switching focus as the mouse crosses window
--   boundaries to keep the mouse near the currently focused window
module XMonad.Actions.UpdatePointer

-- | Update the pointer's location to the currently focused window or empty
--   screen unless it's already there, or unless the user was changing
--   focus with the mouse
--   
--   See also <a>focusUnderPointer</a> for an inverse operation that
--   updates the focus instead. The two can be combined in a single config
--   if neither goes into <a>logHook</a> but are invoked explicitly in
--   individual key bindings.
updatePointer :: (Rational, Rational) -> (Rational, Rational) -> X ()


-- | Automagically put the focused window in the master area.
module XMonad.Layout.MagicFocus

-- | Create a new layout which automagically puts the focused window in the
--   master area.
magicFocus :: l a -> ModifiedLayout MagicFocus l a

-- | An eventHook that overrides the normal focusFollowsMouse. When the
--   mouse it moved to another window, that window is replaced as the
--   master, and the mouse is warped to inside the new master.
--   
--   It prevents infinite loops when focusFollowsMouse is true (the
--   default), and MagicFocus is in use when changing focus with the mouse.
--   
--   This eventHook does nothing when there are floating windows on the
--   current workspace.
promoteWarp :: Event -> X All

-- | promoteWarp' allows you to specify an arbitrary pair of arguments to
--   pass to <a>updatePointer</a> when the mouse enters another window.
promoteWarp' :: (Rational, Rational) -> (Rational, Rational) -> Event -> X All

-- | Another event hook to override the focusFollowsMouse and make the
--   pointer only follow if a given condition is satisfied. This could be
--   used to disable focusFollowsMouse only for given workspaces or
--   layouts. Beware that your focusFollowsMouse setting is ignored if you
--   use this event hook.
followOnlyIf :: X Bool -> Event -> X All

-- | Disables focusFollow on the given workspaces:
disableFollowOnWS :: [WorkspaceId] -> X Bool
data MagicFocus a
instance GHC.Read.Read (XMonad.Layout.MagicFocus.MagicFocus a)
instance GHC.Show.Show (XMonad.Layout.MagicFocus.MagicFocus a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.MagicFocus.MagicFocus Graphics.X11.Types.Window


-- | Updates the focus on mouse move in unfocused windows.
module XMonad.Actions.UpdateFocus

-- | Changes the focus if the mouse is moved within an unfocused window.
focusOnMouseMove :: Event -> X All

-- | Adjusts the event mask to pick up pointer movements.
adjustEventInput :: X ()

-- | Focus the window under the mouse pointer, unless we're currently
--   changing focus with the mouse or dragging. This is the inverse to
--   <a>XMonad.Actions.UpdatePointer</a>: instead of moving the mouse
--   pointer to match the focus, we change the focus to match the mouse
--   pointer.
--   
--   This is meant to be used together with <a>updatePointer</a> in
--   individual key bindings. Bindings that change focus should invoke
--   <a>updatePointer</a> at the end, bindings that switch workspaces or
--   change layouts should call <a>focusUnderPointer</a> at the end.
--   Neither should go to <a>logHook</a>, as that would override the other.
--   
--   This is more finicky to set up than <a>focusOnMouseMove</a>, but
--   ensures that focus is updated immediately, without having to touch the
--   mouse.
focusUnderPointer :: X ()


-- | Provides an action that allows you to change the position of windows
--   by dragging them around.
module XMonad.Actions.TiledWindowDragging

-- | Create a mouse binding for this to be able to drag your windows
--   around. You need <a>XMonad.Layout.DraggingVisualizer</a> for this to
--   look good.
dragWindow :: Window -> X ()


-- | Rotate all windows except the master window and keep the focus in
--   place.
module XMonad.Actions.RotSlaves

-- | The actual rotation, as a pure function on the window stack.
rotSlaves' :: ([a] -> [a]) -> Stack a -> Stack a

-- | Rotate the windows in the current stack, excluding the first one
--   (master).
rotSlavesUp :: X ()

-- | Rotate the windows in the current stack, excluding the first one
--   (master).
rotSlavesDown :: X ()

-- | The actual rotation, as a pure function on the window stack.
rotAll' :: ([a] -> [a]) -> Stack a -> Stack a

-- | Rotate all the windows in the current stack.
rotAllUp :: X ()

-- | Rotate all the windows in the current stack.
rotAllDown :: X ()
rotUp :: [a] -> [a]
rotDown :: [a] -> [a]


-- | Manipulate screens ordered by physical location instead of ID
module XMonad.Actions.PhysicalScreens

-- | The type of the index of a screen by location
newtype PhysicalScreen
P :: Int -> PhysicalScreen

-- | Translate a physical screen index to a <a>ScreenId</a>
getScreen :: ScreenComparator -> PhysicalScreen -> X (Maybe ScreenId)

-- | Switch to a given physical screen
viewScreen :: ScreenComparator -> PhysicalScreen -> X ()

-- | Send the active window to a given physical screen
sendToScreen :: ScreenComparator -> PhysicalScreen -> X ()

-- | Apply operation on a WindowSet with the WorkspaceId of the next screen
--   in the physical order as parameter.
onNextNeighbour :: ScreenComparator -> (WorkspaceId -> WindowSet -> WindowSet) -> X ()

-- | Apply operation on a WindowSet with the WorkspaceId of the previous
--   screen in the physical order as parameter.
onPrevNeighbour :: ScreenComparator -> (WorkspaceId -> WindowSet -> WindowSet) -> X ()

-- | orders screens by the upper-left-most corner, from left-to-right
horizontalScreenOrderer :: ScreenComparator

-- | orders screens by the upper-left-most corner, from top-to-bottom
verticalScreenOrderer :: ScreenComparator

-- | A ScreenComparator allow to compare two screen based on their
--   coordonate and Xinerama Id
newtype ScreenComparator
ScreenComparator :: ((ScreenId, Rectangle) -> (ScreenId, Rectangle) -> Ordering) -> ScreenComparator
getScreenIdAndRectangle :: Screen i l a ScreenId ScreenDetail -> (ScreenId, Rectangle)

-- | Compare screen only by their Xinerama id
screenComparatorById :: (ScreenId -> ScreenId -> Ordering) -> ScreenComparator

-- | Compare screen only by their coordonate
screenComparatorByRectangle :: (Rectangle -> Rectangle -> Ordering) -> ScreenComparator
instance GHC.Real.Real XMonad.Actions.PhysicalScreens.PhysicalScreen
instance GHC.Real.Integral XMonad.Actions.PhysicalScreens.PhysicalScreen
instance GHC.Num.Num XMonad.Actions.PhysicalScreens.PhysicalScreen
instance GHC.Enum.Enum XMonad.Actions.PhysicalScreens.PhysicalScreen
instance GHC.Read.Read XMonad.Actions.PhysicalScreens.PhysicalScreen
instance GHC.Show.Show XMonad.Actions.PhysicalScreens.PhysicalScreen
instance GHC.Classes.Ord XMonad.Actions.PhysicalScreens.PhysicalScreen
instance GHC.Classes.Eq XMonad.Actions.PhysicalScreens.PhysicalScreen
instance Data.Default.Class.Default XMonad.Actions.PhysicalScreens.ScreenComparator


-- | Control workspaces on different screens (in xinerama mode).
module XMonad.Actions.OnScreen

-- | Run any function that modifies the stack on a given screen. This
--   function will also need to know which Screen to focus after the
--   function has been run.
onScreen :: (WindowSet -> WindowSet) -> Focus -> ScreenId -> WindowSet -> WindowSet

-- | A variation of <tt>onScreen</tt> which will take any <tt>X ()</tt>
--   function and run it on the given screen. Warning: This function will
--   change focus even if the function it's supposed to run doesn't
--   succeed.
onScreen' :: X () -> Focus -> ScreenId -> X ()

-- | Focus data definitions
data Focus

-- | always focus the new screen
FocusNew :: Focus

-- | always keep the focus on the current screen
FocusCurrent :: Focus

-- | always focus tag i on the new stack
FocusTag :: WorkspaceId -> Focus

-- | focus tag i only if workspace with tag i is visible on the old stack
FocusTagVisible :: WorkspaceId -> Focus

-- | Switch to workspace <tt>i</tt> on screen <tt>sc</tt>. If <tt>i</tt> is
--   visible use <tt>view</tt> to switch focus to the workspace <tt>i</tt>.
viewOnScreen :: ScreenId -> WorkspaceId -> WindowSet -> WindowSet

-- | Switch to workspace <tt>i</tt> on screen <tt>sc</tt>. If <tt>i</tt> is
--   visible use <tt>greedyView</tt> to switch the current workspace with
--   workspace <tt>i</tt>.
greedyViewOnScreen :: ScreenId -> WorkspaceId -> WindowSet -> WindowSet

-- | Switch to workspace <tt>i</tt> on screen <tt>sc</tt>. If <tt>i</tt> is
--   visible do nothing.
onlyOnScreen :: ScreenId -> WorkspaceId -> WindowSet -> WindowSet

-- | <tt>toggleOrView</tt> as in <a>XMonad.Actions.CycleWS</a> for
--   <tt>onScreen</tt> with view
toggleOnScreen :: ScreenId -> WorkspaceId -> WindowSet -> WindowSet

-- | <tt>toggleOrView</tt> from <a>XMonad.Actions.CycleWS</a> for
--   <tt>onScreen</tt> with greedyView
toggleGreedyOnScreen :: ScreenId -> WorkspaceId -> WindowSet -> WindowSet


-- | Alternative to <a>sendMessage</a> that provides knowledge of whether
--   the message was handled, and utility functions based on this facility.
module XMonad.Actions.MessageFeedback

-- | Variant of <a>sendMessage</a>. Accepts <a>SomeMessage</a>; to use
--   <a>Message</a> see <a>sendMessageB</a>. Returns <tt>True</tt> if the
--   message was handled, <tt>False</tt> otherwise. Instead of using
--   <a>sendSomeMessageWithNoRefreshToCurrentB</a> for efficiency this is
--   pretty much an exact copy of the <a>sendMessage</a> code - foregoes
--   the O(n) <a>updateLayout</a>.
sendSomeMessageB :: SomeMessage -> X Bool

-- | Variant of <a>sendSomeMessageB</a> that discards the result.
sendSomeMessage :: SomeMessage -> X ()

-- | Variant of <a>sendMessageWithNoRefresh</a>. Accepts
--   <a>SomeMessage</a>; to use <a>Message</a> see
--   <a>sendMessageWithNoRefreshB</a>. Returns <tt>True</tt> if the message
--   was handled, <tt>False</tt> otherwise.
sendSomeMessageWithNoRefreshB :: SomeMessage -> Workspace WorkspaceId (Layout Window) Window -> X Bool

-- | Variant of <a>sendSomeMessageWithNoRefreshB</a> that discards the
--   result.
sendSomeMessageWithNoRefresh :: SomeMessage -> Workspace WorkspaceId (Layout Window) Window -> X ()

-- | Variant of <a>sendMessageWithNoRefresh</a> that sends the message to
--   the current layout. Accepts <a>SomeMessage</a>; to use <a>Message</a>
--   see <a>sendMessageWithNoRefreshToCurrentB</a>. Returns <tt>True</tt>
--   if the message was handled, <tt>False</tt> otherwise. This function is
--   somewhat of a cross between <a>sendMessage</a> (sends to the current
--   layout) and <a>sendMessageWithNoRefresh</a> (does not refresh).
sendSomeMessageWithNoRefreshToCurrentB :: SomeMessage -> X Bool

-- | Variant of <a>sendSomeMessageWithNoRefreshToCurrentB</a> that discards
--   the result.
sendSomeMessageWithNoRefreshToCurrent :: SomeMessage -> X ()

-- | Variant of <a>sendSomeMessageB</a> which like <a>sendMessage</a>
--   accepts <a>Message</a> rather than <a>SomeMessage</a>. Returns
--   <tt>True</tt> if the message was handled, <tt>False</tt> otherwise.
sendMessageB :: Message a => a -> X Bool

-- | Variant of <a>sendSomeMessageWithNoRefreshB</a> which like
--   <a>sendMessageWithNoRefresh</a> accepts <a>Message</a> rather than
--   <a>SomeMessage</a>. Returns <tt>True</tt> if the message was handled,
--   <tt>False</tt> otherwise.
sendMessageWithNoRefreshB :: Message a => a -> Workspace WorkspaceId (Layout Window) Window -> X Bool

-- | Variant of <a>sendSomeMessageWithNoRefreshToCurrentB</a> which accepts
--   <a>Message</a> rather than <a>SomeMessage</a>. Returns <tt>True</tt>
--   if the message was handled, <tt>False</tt> otherwise.
sendMessageWithNoRefreshToCurrentB :: Message a => a -> X Bool

-- | Variant of <a>sendMessageWithNoRefreshToCurrentB</a> that discards the
--   result.
sendMessageWithNoRefreshToCurrent :: Message a => a -> X ()

-- | Send each <a>SomeMessage</a> to the current layout without refresh
--   (using <a>sendSomeMessageWithNoRefreshToCurrentB</a>) and collect the
--   results. If any message was handled, refresh. If you want to sequence
--   a series of messages that would have otherwise used <a>sendMessage</a>
--   while minimizing refreshes, use this.
sendSomeMessagesB :: [SomeMessage] -> X [Bool]

-- | Variant of <a>sendSomeMessagesB</a> that discards the results.
sendSomeMessages :: [SomeMessage] -> X ()

-- | Variant of <a>sendSomeMessagesB</a> which accepts <a>Message</a>
--   rather than <a>SomeMessage</a>. Use this if all the messages are of
--   the same type.
sendMessagesB :: Message a => [a] -> X [Bool]

-- | Variant of <a>sendMessagesB</a> that discards the results.
sendMessages :: Message a => [a] -> X ()

-- | Apply the dispatch function in order to each message of the list until
--   one is handled. Returns <tt>True</tt> if so, <tt>False</tt> otherwise.
tryInOrderB :: (SomeMessage -> X Bool) -> [SomeMessage] -> X Bool

-- | Variant of <a>tryInOrderB</a> that sends messages to the current
--   layout without refresh using
--   <a>sendSomeMessageWithNoRefreshToCurrentB</a>.
tryInOrderWithNoRefreshToCurrentB :: [SomeMessage] -> X Bool

-- | Variant of <a>tryInOrderWithNoRefreshToCurrent</a> that discards the
--   results.
tryInOrderWithNoRefreshToCurrent :: [SomeMessage] -> X ()

-- | Apply the dispatch function to the first message, and if it was not
--   handled, apply it to the second. Returns <tt>True</tt> if either
--   message was handled, <tt>False</tt> otherwise.
tryMessageB :: (Message a, Message b) => (SomeMessage -> X Bool) -> a -> b -> X Bool

-- | Variant of <a>tryMessageB</a> that sends messages to the current
--   layout without refresh using
--   <a>sendMessageWithNoRefreshToCurrentB</a>.
tryMessageWithNoRefreshToCurrentB :: (Message a, Message b) => a -> b -> X Bool

-- | Variant of <tt>tryMessage</tt> that discards the results.
tryMessageWithNoRefreshToCurrent :: (Message a, Message b) => a -> b -> X ()

-- | Convenience shorthand for <a>SomeMessage</a>.
sm :: Message a => a -> SomeMessage


-- | Focus the nth window of the current workspace.
module XMonad.Actions.FocusNth

-- | Give focus to the nth window of the current workspace.
focusNth :: Int -> X ()
focusNth' :: Int -> Stack a -> Stack a

-- | Swap current window with nth. Focus stays in the same position
swapNth :: Int -> X ()
swapNth' :: Int -> Stack a -> Stack a


-- | Resize floating windows from any corner.
module XMonad.Actions.FlexibleResize

-- | Resize a floating window from whichever corner the mouse is closest
--   to.
mouseResizeWindow :: Window -> X ()

-- | Resize a floating window from whichever corner or edge the mouse is
--   closest to.
mouseResizeEdgeWindow :: Rational -> Window -> X ()


-- | Move and resize floating windows without warping the mouse.
module XMonad.Actions.FlexibleManipulate

-- | Given an interpolation function, implement an appropriate window
--   manipulation action.
mouseWindow :: (Double -> Double) -> Window -> X ()

-- | Manipulate the window based on discrete pick regions; the window is
--   divided into regions by thirds along each axis.
discrete :: Double -> Double

-- | Scale/reposition the window by factors obtained from the mouse
--   position by linear interpolation. Dragging precisely on a corner
--   resizes that corner; dragging precisely in the middle moves the window
--   without resizing; anything else is an interpolation between the two.
linear :: Double -> Double

-- | Only resize the window, based on the window quadrant the mouse is in.
resize :: Double -> Double

-- | Only reposition the window.
position :: Double -> Double


-- | Find an empty workspace.
module XMonad.Actions.FindEmptyWorkspace

-- | Find and view an empty workspace. Do nothing if all workspaces are in
--   use.
viewEmptyWorkspace :: X ()

-- | Tag current window to an empty workspace and view it. Do nothing if
--   all workspaces are in use.
tagToEmptyWorkspace :: X ()

-- | Send current window to an empty workspace. Do nothing if all
--   workspaces are in use.
sendToEmptyWorkspace :: X ()


-- | Dwm-like swap function for xmonad.
--   
--   Swaps focused window with the master window. If focus is in the
--   master, swap it with the next window in the stack. Focus stays in the
--   master.
module XMonad.Actions.DwmPromote

-- | Swap the focused window with the master window. If focus is in the
--   master, swap it with the next window in the stack. Focus stays in the
--   master.
dwmpromote :: X ()


-- | Provides bindings to cycle windows up or down on the current workspace
--   stack while maintaining focus in place.
--   
--   Bindings are available to:
--   
--   <ul>
--   <li>Cycle nearby or nth windows into the focused frame</li>
--   <li>Cycle a window halfway around the stack</li>
--   <li>Cycle windows through the focused position.</li>
--   <li>Cycle unfocused windows.</li>
--   </ul>
--   
--   These bindings are especially useful with layouts that hide some of
--   the windows in the stack, such as Full, <a>XMonad.Layout.TwoPane</a>
--   or when using <a>XMonad.Layout.LimitWindows</a> to only show three or
--   four panes. See also <a>XMonad.Actions.RotSlaves</a> for related
--   actions.
module XMonad.Actions.CycleWindows
cycleRecentWindows :: [KeySym] -> KeySym -> KeySym -> X ()

-- | Cycle through a <i>finite</i> list of window stacks with repeated
--   presses of a key while a modifier key is held down. For best results
--   use the same mod key + key combination as the one used to invoke the
--   "bring from below" action. You could use cycleStacks' with a different
--   stack permutations function to, for example, cycle from one below to
--   one above to two below, etc. instead of in order. You are responsible
--   for having it generate a finite list, though, or xmonad may hang
--   seeking its length.
cycleStacks' :: (Stack Window -> [Stack Window]) -> [KeySym] -> KeySym -> KeySym -> X ()

-- | The opposite rotation on a Stack.
rotOpposite' :: Stack a -> Stack a
rotOpposite :: X ()

-- | The focused rotation on a stack.
rotFocused' :: ([a] -> [a]) -> Stack a -> Stack a

-- | Rotate windows through the focused frame, excluding the "next" window.
--   With, e.g. TwoPane, this allows cycling windows through either the
--   master or slave pane, without changing the other frame. When the
--   master is focused, the window below is skipped, when a non-master
--   window is focused, the master is skipped.
rotFocusedUp :: X ()
rotFocusedDown :: X ()

-- | Given a stack element and a stack, shift or insert the element
--   (window) at the currently focused position.
shiftToFocus' :: (Eq a, Show a, Read a) => a -> Stack a -> Stack a

-- | The unfocused rotation on a stack.
rotUnfocused' :: ([a] -> [a]) -> Stack a -> Stack a
rotUnfocusedUp :: X ()
rotUnfocusedDown :: X ()
rotUp :: [a] -> [a]
rotDown :: [a] -> [a]


-- | This module allows to cycle through the given subset of layouts.
module XMonad.Actions.CycleSelectedLayouts

-- | If the current layout is in the list, cycle to the next layout.
--   Otherwise, apply the first layout from list.
cycleThroughLayouts :: [String] -> X ()


-- | Provides bindings to cycle through most recently used workspaces with
--   repeated presses of a single key (as long as modifier key is held
--   down). This is similar to how many window managers handle window
--   switching.
module XMonad.Actions.CycleRecentWS

-- | Cycle through most recent workspaces with repeated presses of a key,
--   while a modifier key is held down. The recency of workspaces previewed
--   while browsing to the target workspace is not affected. That way a
--   stack of most recently used workspaces is maintained, similarly to how
--   many window managers handle window switching. For best effects use the
--   same modkey+key combination as the one used to invoke this action.
cycleRecentWS :: [KeySym] -> KeySym -> KeySym -> X ()

-- | Like <a>cycleRecentWS</a>, but restricted to non-empty workspaces.
cycleRecentNonEmptyWS :: [KeySym] -> KeySym -> KeySym -> X ()

-- | Cycle through a finite list of workspaces with repeated presses of a
--   key, while a modifier key is held down. For best effects use the same
--   modkey+key combination as the one used to invoke this action.
cycleWindowSets :: (WindowSet -> [WorkspaceId]) -> [KeySym] -> KeySym -> KeySym -> X ()

-- | Switch to the most recent workspace. The stack of most recently used
--   workspaces is updated, so repeated use toggles between a pair of
--   workspaces.
toggleRecentWS :: X ()

-- | Like <a>toggleRecentWS</a>, but restricted to non-empty workspaces.
toggleRecentNonEmptyWS :: X ()

-- | Given some function that generates a list of workspaces from a given
--   <a>WindowSet</a>, switch to the first generated workspace.
toggleWindowSets :: (WindowSet -> [WorkspaceId]) -> X ()

-- | Given a predicate <tt>p</tt> and the current <a>WindowSet</a>
--   <tt>w</tt>, create a list of workspaces to choose from. They are
--   ordered by recency and have to satisfy <tt>p</tt>.
recentWS :: (WindowSpace -> Bool) -> WindowSet -> [WorkspaceId]


-- | A module for fuzzy completion matching in prompts akin to emacs ido
--   mode.
module XMonad.Prompt.FuzzyMatch

-- | Returns True if the first argument is a subsequence of the second
--   argument, that is, it can be obtained from the second sequence by
--   deleting elements.
fuzzyMatch :: String -> String -> Bool

-- | Sort the given set of strings by how well they match. Match quality is
--   measured first by the length of the substring containing the match and
--   second by the positions of the matching characters in the string.
fuzzySort :: String -> [String] -> [String]


-- | A module for setting the default mouse cursor.
--   
--   Some ideas shamelessly stolen from Nils Schweinsberg; thanks!
module XMonad.Util.Cursor

-- | Set the default (root) cursor
setDefaultCursor :: Glyph -> X ()


-- | Customized key bindings.
--   
--   See also <a>XMonad.Util.EZConfig</a> in xmonad-contrib.
module XMonad.Util.CustomKeys

-- | Customize <a>def</a> -- delete needless shortcuts and insert those you
--   will use.
customKeys :: (XConfig Layout -> [(KeyMask, KeySym)]) -> (XConfig Layout -> [((KeyMask, KeySym), X ())]) -> XConfig Layout -> Map (KeyMask, KeySym) (X ())

-- | General variant of <a>customKeys</a>: customize key bindings of
--   third-party configuration.
customKeysFrom :: XConfig l -> (XConfig Layout -> [(KeyMask, KeySym)]) -> (XConfig Layout -> [((KeyMask, KeySym), X ())]) -> XConfig Layout -> Map (KeyMask, KeySym) (X ())


-- | Module to dump window information for diagnostic/debugging purposes.
--   See <a>XMonad.Hooks.DebugEvents</a> and <a>XMonad.Hooks.DebugStack</a>
--   for practical uses.
module XMonad.Util.DebugWindow

-- | Output a window by ID in hex, decimal, its ICCCM resource name and
--   class, its title if available, and EWMH type and state if available.
--   Also indicate override_redirect with an exclamation mark, and wrap in
--   brackets if it is unmapped or withdrawn.
debugWindow :: Window -> X String


-- | Dump the state of the <tt>StackSet</tt>. A <tt>logHook</tt> and
--   <tt>handleEventHook</tt> are also provided.
module XMonad.Hooks.DebugStack

-- | Print the state of the current window stack for the current workspace
--   to <tt>stderr</tt>, which for most installations goes to
--   <tt>~/.xsession-errors</tt>. <a>XMonad.Util.DebugWindow</a> is used to
--   display the individual windows.
debugStack :: X ()

-- | Print the state of the current window stack for all workspaces to
--   <tt>stderr</tt>, which for most installations goes to
--   <tt>~/.xsession-errors</tt>. <a>XMonad.Util.DebugWindow</a> is used to
--   display the individual windows.
debugStackFull :: X ()

-- | Dump the state of the current workspace in the <tt>StackSet</tt> as a
--   multiline <a>String</a>.
debugStackString :: X String

-- | Dump the state of all workspaces in the <tt>StackSet</tt> as a
--   multiline <a>String</a>. @@@ this is in stackset order, which is
--   roughly lru-ish
debugStackFullString :: X String

-- | <a>debugStack</a> packaged as a <a>logHook</a>. (Currently this is
--   identical.)
debugStackLogHook :: X ()

-- | 'debugStackFull packaged as a <a>logHook</a>. (Currently this is
--   identical.)
debugStackFullLogHook :: X ()

-- | <a>debugStack</a> packaged as a <a>handleEventHook</a>. You almost
--   certainly do not want to use this unconditionally, as it will cause
--   massive amounts of output and possibly slow <tt>xmonad</tt> down
--   severely.
debugStackEventHook :: Event -> X All

-- | <a>debugStackFull</a> packaged as a <a>handleEventHook</a>. You almost
--   certainly do not want to use this unconditionally, as it will cause
--   massive amounts of output and possibly slow <tt>xmonad</tt> down
--   severely.
debugStackFullEventHook :: Event -> X All


-- | Module to dump diagnostic information about X11 events received by
--   <tt>xmonad</tt>. This is incomplete due to <a>Event</a> being
--   incomplete and not providing information about a number of events, and
--   enforcing artificial constraints on others (for example
--   <tt>ClientMessage</tt>); the <tt>X11</tt> package will require a
--   number of changes to fix these problems.
module XMonad.Hooks.DebugEvents

-- | Event hook to dump all received events. You should probably not use
--   this unconditionally; it will produce massive amounts of output.
debugEventsHook :: Event -> X All
instance Control.Monad.Reader.Class.MonadReader XMonad.Hooks.DebugEvents.Decode XMonad.Hooks.DebugEvents.Decoder
instance Control.Monad.State.Class.MonadState XMonad.Hooks.DebugEvents.DecodeState XMonad.Hooks.DebugEvents.Decoder
instance Control.Monad.Fail.MonadFail XMonad.Hooks.DebugEvents.Decoder
instance Control.Monad.IO.Class.MonadIO XMonad.Hooks.DebugEvents.Decoder
instance GHC.Base.Monad XMonad.Hooks.DebugEvents.Decoder
instance GHC.Base.Applicative XMonad.Hooks.DebugEvents.Decoder
instance GHC.Base.Functor XMonad.Hooks.DebugEvents.Decoder


-- | Extensible and composable configuration for contrib modules.
--   
--   This is the configuration counterpart of
--   <a>XMonad.Util.ExtensibleState</a>. It allows contrib modules to store
--   custom configuration values inside <a>XConfig</a>. This lets them
--   create custom hooks, ensure they hook into xmonad core only once, and
--   possibly more.
module XMonad.Util.ExtensibleConf

-- | Run-time: Run a monadic action with the value of the custom
--   configuration, if set.
with :: (MonadReader XConf m, Typeable a, Monoid b) => (a -> m b) -> m b

-- | Config-time: Add (append) a piece of custom configuration to an
--   <a>XConfig</a> using the <a>Semigroup</a> instance of the
--   configuration type.
add :: (Semigroup a, Typeable a) => a -> XConfig l -> XConfig l

-- | Config-time: <a>add</a> a piece of custom configuration, and if it's
--   the first piece of this type, also modify the <a>XConfig</a> using the
--   provided function.
--   
--   This can be used to implement a composable interface for modules that
--   must only hook into xmonad core once.
--   
--   (The piece of custom configuration is the last argument as it's
--   expected to come from the user.)
once :: forall a l. (Semigroup a, Typeable a) => (XConfig l -> XConfig l) -> a -> XConfig l -> XConfig l

-- | Config-time: Applicative (monadic) variant of <a>once</a>, useful if
--   the <a>XConfig</a> modification needs to do some <a>IO</a> (e.g.
--   create an <a>IORef</a>).
onceM :: forall a l m. (Applicative m, Semigroup a, Typeable a) => (XConfig l -> m (XConfig l)) -> a -> XConfig l -> m (XConfig l)

-- | Run-time: Run a monadic action with the value of the custom
--   configuration, or the <a>Default</a> value thereof, if absent.
withDef :: (MonadReader XConf m, Typeable a, Default a) => (a -> m b) -> m b

-- | Config-time: Modify a configuration value in <a>XConfig</a>,
--   initializing it to its <a>Default</a> value first if absent. This is
--   an alternative to <a>add</a> for when a <a>Semigroup</a> instance is
--   unavailable or unsuitable.
--   
--   Note that this must <i>not</i> be used together with any variant of
--   <a>once</a>!
modifyDef :: forall a l. (Default a, Typeable a) => (a -> a) -> XConfig l -> XConfig l

-- | Config-time: Applicative (monadic) variant of <a>modifyDef</a>, useful
--   if the configuration value modification needs to do some <a>IO</a>
--   (e.g. create an <a>IORef</a>).
--   
--   Note that this must <i>not</i> be used together with any variant of
--   <a>once</a>!
modifyDefM :: forall a l m. (Applicative m, Default a, Typeable a) => (a -> m a) -> XConfig l -> m (XConfig l)

-- | Run-time: Retrieve a configuration value of the requested type.
ask :: (MonadReader XConf m, Typeable a) => m (Maybe a)

-- | Config-time: Retrieve a configuration value of the requested type.
lookup :: forall a l. Typeable a => XConfig l -> Maybe a

-- | Config-time: Alter a configuration value, or absence thereof.
alter :: forall a l. Typeable a => (Maybe a -> Maybe a) -> XConfig l -> XConfig l

-- | Config-time: Functor variant of <a>alter</a>, useful if the
--   configuration modifications needs to do some <a>IO</a>.
alterF :: forall a l f. (Typeable a, Functor f) => (Maybe a -> f (Maybe a)) -> XConfig l -> f (XConfig l)


-- | Custom hooks for screen (xrandr) configuration changes.
module XMonad.Hooks.Rescreen

-- | Shortcut for <a>rescreenHook</a>.
addAfterRescreenHook :: X () -> XConfig l -> XConfig l

-- | Shortcut for <a>rescreenHook</a>.
addRandrChangeHook :: X () -> XConfig l -> XConfig l

-- | Hook configuration for <a>rescreenHook</a>.
data RescreenConfig
RescreenConfig :: X () -> X () -> RescreenConfig

-- | hook to invoke after <a>rescreen</a>
[afterRescreenHook] :: RescreenConfig -> X ()

-- | hook for other randr changes, e.g. (dis)connects
[randrChangeHook] :: RescreenConfig -> X ()

-- | Attach custom hooks to screen (xrandr) configuration change events.
--   Replaces the built-in rescreen handling of xmonad core with:
--   
--   <ol>
--   <li>listen to <a>RRScreenChangeNotifyEvent</a> in addition to
--   <a>ConfigureEvent</a> on the root window</li>
--   <li>whenever such event is received:</li>
--   <li>clear any other similar events (Xorg server emits them in
--   bunches)</li>
--   <li>if any event was <a>ConfigureEvent</a>, <a>rescreen</a> and invoke
--   <a>afterRescreenHook</a></li>
--   <li>if there was no <a>ConfigureEvent</a>, invoke
--   <a>randrChangeHook</a> only</li>
--   </ol>
--   
--   <a>afterRescreenHook</a> is useful for restarting/repositioning status
--   bars and systray.
--   
--   <a>randrChangeHook</a> may be used to automatically trigger xrandr (or
--   perhaps autorandr) when outputs are (dis)connected.
--   
--   Note that <a>rescreenHook</a> is safe to use several times,
--   <a>rescreen</a> is still done just once and hooks are invoked in
--   sequence, also just once.
rescreenHook :: RescreenConfig -> XConfig l -> XConfig l
instance Data.Default.Class.Default XMonad.Hooks.Rescreen.RescreenConfig
instance GHC.Base.Semigroup XMonad.Hooks.Rescreen.RescreenConfig
instance GHC.Base.Monoid XMonad.Hooks.Rescreen.RescreenConfig


-- | A module for abstracting a font facility over Core fonts and Xft
module XMonad.Util.Font
data XMonadFont
Core :: FontStruct -> XMonadFont
Utf8 :: FontSet -> XMonadFont
Xft :: NonEmpty XftFont -> XMonadFont

-- | When initXMF gets a font name that starts with 'xft:' it switches to
--   the Xft backend Example: 'xft: Sans-10'
initXMF :: String -> X XMonadFont
releaseXMF :: XMonadFont -> X ()

-- | Given a fontname returns the font structure. If the font name is not
--   valid the default font will be loaded and returned.
initCoreFont :: String -> X FontStruct
releaseCoreFont :: FontStruct -> X ()
initUtf8Font :: String -> X FontSet
releaseUtf8Font :: FontSet -> X ()

-- | String position
data Align
AlignCenter :: Align
AlignRight :: Align
AlignLeft :: Align
AlignRightOffset :: Int -> Align

-- | Return the string x and y <a>Position</a> in a <a>Rectangle</a>, given
--   a <a>FontStruct</a> and the <a>Align</a>ment
stringPosition :: (Functor m, MonadIO m) => Display -> XMonadFont -> Rectangle -> Align -> String -> m (Position, Position)
textWidthXMF :: MonadIO m => Display -> XMonadFont -> String -> m Int
textExtentsXMF :: MonadIO m => XMonadFont -> String -> m (Int32, Int32)
printStringXMF :: (Functor m, MonadIO m) => Display -> Drawable -> XMonadFont -> GC -> String -> String -> Position -> Position -> String -> m ()

-- | Get the Pixel value for a named color: if an invalid name is given the
--   black pixel will be returned.
stringToPixel :: (Functor m, MonadIO m) => Display -> String -> m Pixel

-- | Convert a <tt>Pixel</tt> into a <tt>String</tt>.
--   
--   This function removes any alpha channel from the <tt>Pixel</tt>,
--   because X11 mishandles alpha channels and produces black.
pixelToString :: MonadIO m => Display -> Pixel -> m String

-- | Short for <a>fromIntegral</a>.
fi :: (Integral a, Num b) => a -> b
instance GHC.Read.Read XMonad.Util.Font.Align
instance GHC.Show.Show XMonad.Util.Font.Align


-- | This module should not be directly used by users. Its purpose is to
--   facilitate grabbing and ungrabbing keys.
module XMonad.Util.Grab

-- | A more convenient version of <a>grabKey</a>.
grabKP :: KeyMask -> KeyCode -> X ()

-- | A more convenient version of <a>ungrabKey</a>.
ungrabKP :: KeyMask -> KeyCode -> X ()

-- | A convenience function to grab and ungrab keys
grabUngrab :: [(KeyMask, KeySym)] -> [(KeyMask, KeySym)] -> X ()

-- | A convenience function to grab keys. This also ungrabs all previously
--   grabbed keys.
grab :: [(KeyMask, KeySym)] -> X ()

-- | An event hook that runs a custom action to regrab the necessary keys.
customRegrabEvHook :: X () -> Event -> X All


-- | Provides <a>History</a>, a variation on a LIFO stack with a uniqueness
--   property. In order to achieve the desired asymptotics, the data type
--   is implemented as an ordered Map.
module XMonad.Util.History

-- | A history of unique <tt>k</tt>-events with <tt>a</tt>-annotations.
--   
--   <tt>History k a</tt> can be considered a (LIFO) stack of <tt>(k,
--   a)</tt> values with the property that each <tt>k</tt> is unique. From
--   this point of view, <a>event</a> pushes and <a>ledger</a> pops/peeks
--   all.
--   
--   The naive implementation has <i>O(n)</i> <a>event</a> and <a>erase</a>
--   due to the uniqueness condition, but we can still use it as a
--   denotation:
--   
--   <pre>
--   mu :: History k a -&gt; [(k, a)]
--   </pre>
--   
--   As an opaque data type with strict operations, <tt>History k a</tt>
--   values are all finite expressions in the core interface:
--   <a>origin</a>, <a>erase</a> and <a>event</a>. Hence we define
--   <tt>mu</tt> by structural induction on these three cases.
data History k a

-- | <i>O(1)</i>. A history of nothing.
--   
--   <pre>
--   mu origin := []
--   </pre>
origin :: History k a

-- | <i>O(log n)</i>. A new event makes history; its predecessor forgotten.
--   
--   <pre>
--   mu (event k a h) := (k, a) : mu (erase k h)
--   </pre>
event :: Ord k => k -> a -> History k a -> History k a

-- | <i>O(log n)</i>. Erase an event from history.
--   
--   <pre>
--   mu (erase k h) := filter ((k /=) . fst) (mu h)
--   </pre>
erase :: Ord k => k -> History k a -> History k a

-- | <i>O(log n)</i>. Recall an event.
recall :: Ord k => k -> History k a -> Maybe a

-- | <i>O(n)</i>. Read history, starting with the modern day.
--   <tt>ledger</tt> is <tt>mu</tt>.
ledger :: History k a -> [(k, a)]

-- | <i>O(n * log n)</i>. Transcribe a ledger.
transcribe :: Ord k => [(k, a)] -> History k a
instance Data.Traversable.Traversable (XMonad.Util.History.History k)
instance Data.Foldable.Foldable (XMonad.Util.History.History k)
instance GHC.Base.Functor (XMonad.Util.History.History k)
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (XMonad.Util.History.History k a)
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => GHC.Classes.Ord (XMonad.Util.History.History k a)
instance (GHC.Show.Show k, GHC.Show.Show a) => GHC.Show.Show (XMonad.Util.History.History k a)
instance (GHC.Read.Read k, GHC.Read.Read a, GHC.Classes.Ord k) => GHC.Read.Read (XMonad.Util.History.History k a)


-- | Utilities for manipulating [[Bool]] as images
module XMonad.Util.Image

-- | Placement of the icon in the title bar
data Placement

-- | An exact amount of pixels from the upper left corner
OffsetLeft :: Int -> Int -> Placement

-- | An exact amount of pixels from the right left corner
OffsetRight :: Int -> Int -> Placement

-- | Centered in the y-axis, an amount of pixels from the left
CenterLeft :: Int -> Placement

-- | Centered in the y-axis, an amount of pixels from the right
CenterRight :: Int -> Placement

-- | Return the <tt>x</tt> and <tt>y</tt> positions inside a
--   <a>Rectangle</a> to start drawing the image given its <a>Placement</a>
iconPosition :: Rectangle -> Placement -> [[Bool]] -> (Position, Position)

-- | Draw an image into a X surface
drawIcon :: (Functor m, MonadIO m) => Display -> Drawable -> GC -> String -> String -> Position -> Position -> [[Bool]] -> m ()
instance GHC.Read.Read XMonad.Util.Image.Placement
instance GHC.Show.Show XMonad.Util.Image.Placement


-- | A data type to store the layout state
module XMonad.Util.Invisible
newtype Invisible m a
I :: m a -> Invisible m a
whenIJust :: Monad m => Invisible Maybe a -> (a -> m ()) -> m ()
fromIMaybe :: a -> Invisible Maybe a -> a
instance GHC.Base.Functor m => GHC.Base.Functor (XMonad.Util.Invisible.Invisible m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (XMonad.Util.Invisible.Invisible m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (XMonad.Util.Invisible.Invisible m)
instance GHC.Base.Monad m => GHC.Base.Monad (XMonad.Util.Invisible.Invisible m)
instance (GHC.Base.Functor m, GHC.Base.Monad m, Control.Monad.Fail.MonadFail m) => GHC.Read.Read (XMonad.Util.Invisible.Invisible m a)
instance GHC.Base.Monad m => GHC.Show.Show (XMonad.Util.Invisible.Invisible m a)


-- | Stores some common utilities for modules used for window
--   minimizing/maximizing
module XMonad.Util.Minimize
type RectMap = Map Window (Maybe RationalRect)
data Minimized
Minimized :: RectMap -> [Window] -> Minimized
[rectMap] :: Minimized -> RectMap
[minimizedStack] :: Minimized -> [Window]
instance GHC.Show.Show XMonad.Util.Minimize.Minimized
instance GHC.Read.Read XMonad.Util.Minimize.Minimized
instance GHC.Classes.Eq XMonad.Util.Minimize.Minimized
instance XMonad.Core.ExtensionClass XMonad.Util.Minimize.Minimized


-- | This module allows you to associate the X titles of windows with them.
module XMonad.Util.NamedWindows
data NamedWindow
getName :: Window -> X NamedWindow

-- | Get <a>NamedWindow</a> using <a>wM_CLASS</a>
getNameWMClass :: Window -> X NamedWindow
withNamedWindow :: (NamedWindow -> X ()) -> X ()
unName :: NamedWindow -> Window
instance GHC.Classes.Eq XMonad.Util.NamedWindows.NamedWindow
instance GHC.Classes.Ord XMonad.Util.NamedWindows.NamedWindow
instance GHC.Show.Show XMonad.Util.NamedWindows.NamedWindow


-- | Function and manageHook to mark a window to be ignored by EWMH
--   taskbars and pagers.
module XMonad.Util.NoTaskbar

-- | A <a>ManageHook</a> to mark a window to not be shown in pagers or
--   taskbars.
noTaskbar :: ManageHook

-- | An <a>X</a> action to mark a window to not be shown in pagers or
--   taskbars.
markNoTaskbar :: Window -> X ()


-- | A small wrapper around the <a>ReadP</a> parser combinator in
--   <tt>base</tt>, providing a more intuitive behaviour. While it's
--   theoretically nice that <a>ReadP</a> is actually commutative, this
--   makes a lot of parsing operations rather awkward—more often than not,
--   one only wants the argument that's parsed "first".
--   
--   Due to the left-biased nature of the chosen semigroup implementation,
--   using functions like <a>many</a> or <a>optional</a> from
--   <a>Control.Applicative</a> now yields more consistent behaviour with
--   other parser combinator libraries.
module XMonad.Util.Parser
data Parser a

-- | Run a parser on a given string.
runParser :: Parser a -> String -> Maybe a

-- | Always fails
pfail :: Parser a

-- | Succeeds if and only if we are at the end of input.
eof :: Parser ()

-- | Parse an integral number.
num :: (Read a, Integral a) => Parser a

-- | Parse and return the specified character.
char :: Char -> Parser Char

-- | Parse and return the specified string.
string :: String -> Parser String

-- | Skip all whitespace.
skipSpaces :: Parser ()

-- | Consume and return the next character. Fails if there is no input
--   left.
get :: Parser Char

-- | Look-ahead: return the part of the input that is left, without
--   consuming it.
look :: Parser String

-- | Transform a parser into one that does the same, but in addition
--   returns the exact characters read.
--   
--   <pre>
--   &gt;&gt;&gt; runParser (         string "* " $&gt; True) "* hi"
--   Just True
--   
--   &gt;&gt;&gt; runParser (gather $ string "* " $&gt; True) "* hi"
--   Just ("* ",True)
--   </pre>
gather :: forall a. Parser a -> Parser (String, a)

-- | Consume and return the next character if it satisfies the specified
--   predicate.
satisfy :: (Char -> Bool) -> Parser Char

-- | Combine all parsers in the given list in a left-biased way.
choice :: [Parser a] -> Parser a

-- | <tt>count n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt> in
--   sequence and returns a list of results.
count :: Int -> Parser a -> Parser [a]

-- | <tt>between open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and finally <tt>close</tt>. Only the value of <tt>p</tt> is
--   returned.
between :: Parser open -> Parser close -> Parser a -> Parser a

-- | <tt>option def p</tt> will try to parse <tt>p</tt> and, if it fails,
--   simply return <tt>def</tt> without consuming any input.
option :: a -> Parser a -> Parser a

-- | <tt>optionally p</tt> optionally parses <tt>p</tt> and always returns
--   <tt>()</tt>.
optionally :: Parser a -> Parser ()

-- | Like <a>many</a>, but discard the result.
skipMany :: Parser a -> Parser ()

-- | Like <a>many1</a>, but discard the result.
skipMany1 :: Parser a -> Parser ()

-- | Parse one or more occurrences of the given parser.
many1 :: Parser a -> Parser [a]

-- | <tt>sepBy p sep</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>sep</tt>. Returns a list of values returned by
--   <tt>p</tt>.
sepBy :: Parser a -> Parser sep -> Parser [a]

-- | <tt>sepBy1 p sep</tt> parses one or more occurrences of <tt>p</tt>,
--   separated by <tt>sep</tt>. Returns a list of values returned by
--   <tt>p</tt>.
sepBy1 :: Parser a -> Parser sep -> Parser [a]

-- | <tt>endBy p sep</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated and ended by <tt>sep</tt>.
endBy :: Parser a -> Parser sep -> Parser [a]

-- | <tt>endBy p sep</tt> parses one or more occurrences of <tt>p</tt>,
--   separated and ended by <tt>sep</tt>.
endBy1 :: Parser a -> Parser sep -> Parser [a]

-- | Parse the first zero or more characters satisfying the predicate.
--   Always succeeds; returns an empty string if the predicate returns
--   <tt>False</tt> on the first character of input.
munch :: (Char -> Bool) -> Parser String

-- | Parse the first one or more characters satisfying the predicate. Fails
--   if none, else succeeds exactly once having consumed all the
--   characters.
munch1 :: (Char -> Bool) -> Parser String

-- | <tt>chainr p op x</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>op</tt>. Returns a value produced by a <i>right</i>
--   associative application of all functions returned by <tt>op</tt>. If
--   there are no occurrences of <tt>p</tt>, <tt>x</tt> is returned.
chainr :: Parser a -> Parser (a -> a -> a) -> a -> Parser a

-- | Like <a>chainr</a>, but parses one or more occurrences of <tt>p</tt>.
chainr1 :: forall a. Parser a -> Parser (a -> a -> a) -> Parser a

-- | <tt>chainl p op x</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>op</tt>. Returns a value produced by a <i>left</i>
--   associative application of all functions returned by <tt>op</tt>. If
--   there are no occurrences of <tt>p</tt>, <tt>x</tt> is returned.
chainl :: Parser a -> Parser (a -> a -> a) -> a -> Parser a

-- | Like <a>chainl</a>, but parses one or more occurrences of <tt>p</tt>.
chainl1 :: forall a. Parser a -> Parser (a -> a -> a) -> Parser a

-- | <tt>manyTill p end</tt> parses zero or more occurrences of <tt>p</tt>,
--   until <tt>end</tt> succeeds. Returns a list of values returned by
--   <tt>p</tt>.
manyTill :: forall a end. Parser a -> Parser end -> Parser [a]
instance GHC.Base.Monad XMonad.Util.Parser.Parser
instance GHC.Base.Applicative XMonad.Util.Parser.Parser
instance GHC.Base.Functor XMonad.Util.Parser.Parser
instance GHC.Base.Semigroup (XMonad.Util.Parser.Parser a)
instance GHC.Base.Monoid (XMonad.Util.Parser.Parser a)
instance GHC.Base.Alternative XMonad.Util.Parser.Parser
instance (a GHC.Types.~ GHC.Base.String) => Data.String.IsString (XMonad.Util.Parser.Parser a)


-- | This module should not be directly used by users, it's just common
--   code for other modules.
module XMonad.Util.Process

-- | Get the parent process id (PPID) of a given process.
getPPIDOf :: ProcessID -> IO (Maybe ProcessID)

-- | Get the chain of parent processes of a given pid. Starts with the
--   given pid and continues up until the parent of all.
getPPIDChain :: ProcessID -> IO [ProcessID]


-- | Unlike the opaque <tt>IO</tt> actions that <tt>X</tt> actions can
--   wrap, regular reads from the <a>XConf</a> and modifications to the
--   <a>XState</a> are fundamentally pure—contrary to the current treatment
--   of such actions in most xmonad code. Pure modifications to the
--   <a>WindowSet</a> can be readily composed, but due to the need for
--   those modifications to be properly handled by <a>windows</a>, other
--   pure changes to the <tt>XState</tt> cannot be interleaved with those
--   changes to the <tt>WindowSet</tt> without superfluous refreshes, hence
--   breaking composability.
--   
--   This module aims to rectify that situation by drawing attention to it
--   and providing <a>PureX</a>: a pure type with the same monadic
--   interface to state as <tt>X</tt>. The <a>XLike</a> typeclass enables
--   writing actions generic over the two monads; if pure, existing
--   <tt>X</tt> actions can be generalised with only a change to the type
--   signature. Various other utilities are provided, in particular the
--   <a>defile</a> function which is needed by end-users.
module XMonad.Util.PureX

-- | The <tt>PureX</tt> newtype over <tt>ReaderT XConf (State XState)
--   a</tt>.
data PureX a

-- | The <tt>XLike</tt> typeclass over monads reading <tt>XConf</tt> values
--   and tracking <tt>XState</tt> state.
class (MonadReader XConf m, MonadState XState m) => XLike m
toX :: XLike m => m a -> X a

-- | A version of <tt>windowBracket'</tt> specialised to take a <tt>PureX
--   Any</tt> action and handle windowset changes with a refresh when the
--   <tt>Any</tt> holds <tt>True</tt>. Analogous to <a>windowBracket_</a>.
--   Don't bake this into your action; it's for the end-user.
defile :: PureX Any -> X ()

-- | A generalisation of <a>windowBracket</a>. Handles refreshing for an
--   action that <b>performs no refresh of its own</b> but can indicate
--   that it needs one through a return value that's tested against the
--   supplied predicate. The action can interleave changes to the
--   <tt>WindowSet</tt> with <tt>IO</tt> or changes to the <tt>XState</tt>.
windowBracket' :: XLike m => (a -> Bool) -> m a -> X a

-- | A version of <tt>windowBracket</tt> specialised to take an <tt>X
--   ()</tt> action and perform a refresh handling any changes it makes.
handlingRefresh :: X () -> X ()

-- | Consume a <tt>PureX a</tt>.
runPureX :: PureX a -> XConf -> XState -> (a, XState)

-- | Despite appearing less general, <tt>PureX a</tt> is actually
--   isomorphic to <tt>XLike m =&gt; m a</tt>.
toXLike :: XLike m => PureX a -> m a

-- | A <a>when</a> that accepts a monoidal return value.
when' :: (Monad m, Monoid a) => Bool -> m a -> m a

-- | A <tt>whenX</tt>/<tt>whenM</tt> that accepts a monoidal return value.
whenM' :: (Monad m, Monoid a) => m Bool -> m a -> m a

-- | A <a>whenJust</a> that accepts a monoidal return value.
whenJust' :: (Monad m, Monoid b) => Maybe a -> (a -> m b) -> m b

-- | Akin to <tt>&lt;*</tt>. Discarding the wrapped value in the second
--   argument either way, keep its effects iff the first argument returns
--   <tt>Any True</tt>.
(<?) :: Monad m => m Any -> m a -> m Any
infixl 4 <?

-- | Akin to a low precedence <tt>&lt;&gt;</tt>. Combines applicative
--   effects left-to-right and wrapped <tt>Bool</tt>s with
--   <tt>&amp;&amp;</tt> (instead of <tt>||</tt>).
(&>) :: Applicative f => f Any -> f Any -> f Any
infixl 1 &>

-- | A generalisation of <a>withWindowSet</a>.
withWindowSet' :: XLike m => (WindowSet -> m a) -> m a

-- | If there is a current tag and a focused window, perform an operation
--   with them, otherwise return mempty.
withFocii :: (XLike m, Monoid a) => (WorkspaceId -> Window -> m a) -> m a

-- | A variant of <tt>W.modify</tt> and <tt>W.modify'</tt> handling the
--   <tt>Nothing</tt> and <tt>Just</tt> cases uniformly.
modify'' :: (Maybe (Stack a) -> Maybe (Stack a)) -> StackSet i l a s sd -> StackSet i l a s sd

-- | A generalisation of <a>modifyWindowSet</a>.
modifyWindowSet' :: XLike m => (WindowSet -> WindowSet) -> m ()

-- | Get the stack from the current workspace.
getStack :: XLike m => m (Maybe (Stack Window))

-- | Set the stack on the current workspace.
putStack :: XLike m => Maybe (Stack Window) -> m ()

-- | Get the focused window if there is one.
peek :: XLike m => m (Maybe Window)

-- | A refresh-tracking version of <tt>W.focusWindow</tt>.
focusWindow :: XLike m => Window -> m Any

-- | A refresh-tracking version of
--   <tt>XMonad.Actions.FocusNth.focusNth</tt>.
focusNth :: XLike m => Int -> m Any

-- | A version of <tt>W.view</tt> that tracks the need to refresh.
view :: XLike m => WorkspaceId -> m Any

-- | A version of <tt>W.greedyView</tt> that tracks the need to refresh.
greedyView :: XLike m => WorkspaceId -> m Any

-- | View a workspace if it's not visible. An alternative to <tt>view</tt>
--   and <tt>greedyView</tt> that—rather than changing the current screen
--   or affecting another—opts not to act.
invisiView :: XLike m => WorkspaceId -> m Any

-- | A refresh-tracking version of <tt>W.Shift</tt>.
shift :: XLike m => WorkspaceId -> m Any

-- | A refresh tracking version of <tt>W.shiftWin</tt>.
shiftWin :: XLike m => WorkspaceId -> Window -> m Any

-- | Get the current screen.
curScreen :: XLike m => m WindowScreen

-- | Get the current workspace.
curWorkspace :: XLike m => m WindowSpace

-- | Get the current tag.
curTag :: XLike m => m WorkspaceId

-- | Get the current <tt>ScreenId</tt>.
curScreenId :: XLike m => m ScreenId
instance GHC.Base.Monoid a => GHC.Base.Monoid (XMonad.Util.PureX.PureX a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (XMonad.Util.PureX.PureX a)
instance Control.Monad.State.Class.MonadState XMonad.Core.XState XMonad.Util.PureX.PureX
instance Control.Monad.Reader.Class.MonadReader XMonad.Core.XConf XMonad.Util.PureX.PureX
instance GHC.Base.Monad XMonad.Util.PureX.PureX
instance GHC.Base.Applicative XMonad.Util.PureX.PureX
instance GHC.Base.Functor XMonad.Util.PureX.PureX
instance XMonad.Util.PureX.XLike XMonad.Core.X
instance XMonad.Util.PureX.XLike XMonad.Util.PureX.PureX


-- | Module for storing custom mutable state in xmonad.
module XMonad.Util.ExtensibleState

-- | Add a value to the extensible state field. A previously stored value
--   with the same type will be overwritten. (More precisely: A value whose
--   string representation of its type is equal to the new one's)
put :: (ExtensionClass a, XLike m) => a -> m ()

-- | Apply a function to a stored value of the matching type or the initial
--   value if there is none.
modify :: (ExtensionClass a, XLike m) => (a -> a) -> m ()

-- | Like <a>modify</a> but the result value is forced to WHNF before being
--   stored.
modify' :: (ExtensionClass a, XLike m) => (a -> a) -> m ()

-- | Apply an action to a stored value of the matching type or the initial
--   value if there is none.
modifyM :: (ExtensionClass a, XLike m) => (a -> m a) -> m ()

-- | Like <a>modifyM</a> but the result value is forced to WHNF before
--   being stored.
modifyM' :: (ExtensionClass a, XLike m) => (a -> m a) -> m ()

-- | Remove the value from the extensible state field that has the same
--   type as the supplied argument
remove :: (ExtensionClass a, XLike m) => a -> m ()

-- | Try to retrieve a value of the requested type, return an initial value
--   if there is no such value.
get :: (ExtensionClass a, XLike m) => m a
gets :: (ExtensionClass a, XLike m) => (a -> b) -> m b
modified :: (ExtensionClass a, Eq a, XLike m) => (a -> a) -> m Bool
modifiedM :: (ExtensionClass a, Eq a, XLike m) => (a -> m a) -> m Bool


-- | A utility module to store information about position and size of a
--   window. See <a>XMonad.Layout.PositionStoreFloat</a> for a layout that
--   makes use of this.
module XMonad.Util.PositionStore
getPosStore :: X PositionStore
modifyPosStore :: (PositionStore -> PositionStore) -> X ()
posStoreInsert :: PositionStore -> Window -> Rectangle -> Rectangle -> PositionStore
posStoreMove :: PositionStore -> Window -> Position -> Position -> Rectangle -> Rectangle -> PositionStore
posStoreQuery :: PositionStore -> Window -> Rectangle -> Maybe Rectangle
posStoreRemove :: PositionStore -> Window -> PositionStore
data PositionStore
instance GHC.Show.Show XMonad.Util.PositionStore.PosStoreRectangle
instance GHC.Read.Read XMonad.Util.PositionStore.PosStoreRectangle
instance GHC.Show.Show XMonad.Util.PositionStore.PositionStore
instance GHC.Read.Read XMonad.Util.PositionStore.PositionStore
instance XMonad.Core.ExtensionClass XMonad.Util.PositionStore.PositionStore


-- | A floating layout which has been designed with a dual-head setup in
--   mind. It makes use of <a>XMonad.Util.PositionStore</a> as well as
--   <a>XMonad.Hooks.PositionStoreHooks</a> . Since there is currently no
--   way to move or resize windows with the keyboard alone in this layout,
--   it is adviced to use it in combination with a decoration such as
--   <a>XMonad.Layout.NoFrillsDecoration</a> (to move windows) and the
--   layout modifier <a>XMonad.Layout.BorderResize</a> (to resize windows).
module XMonad.Layout.PositionStoreFloat
positionStoreFloat :: PositionStoreFloat a
data PositionStoreFloat a
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Layout.PositionStoreFloat.PositionStoreFloat a)
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.PositionStoreFloat.PositionStoreFloat a)
instance XMonad.Core.LayoutClass XMonad.Layout.PositionStoreFloat.PositionStoreFloat Graphics.X11.Types.Window


-- | Dynamically declare any window as a scratchpad.

-- | <i>Deprecated: Use the dynamic scratchpad facility of
--   XMonad.Util.NamedScratchpad instead.</i>
module XMonad.Util.DynamicScratchpads

-- | Makes a window a dynamic scratchpad with the given name, or stop a
--   window | from being a dynamic scratchpad, if it already is.
makeDynamicSP :: String -> Window -> X ()

-- | Spawn the specified dynamic scratchpad
spawnDynamicSP :: String -> X ()
instance GHC.Show.Show XMonad.Util.DynamicScratchpads.SPStorage
instance GHC.Read.Read XMonad.Util.DynamicScratchpads.SPStorage
instance XMonad.Core.ExtensionClass XMonad.Util.DynamicScratchpads.SPStorage


-- | Put XMonad actions in the queue to be executed in either the
--   <tt>logHook</tt> or another hook of your choice.
module XMonad.Util.ActionQueue
data ActionQueue

-- | Every time the <tt>logHook</tt> runs, execute all actions in the
--   queue.
actionQueue :: XConfig l -> XConfig l

-- | Enqueue an action.
enqueue :: X () -> X ()

-- | Execute every action in the queue.
exequeue :: X ()
instance GHC.Base.Semigroup XMonad.Util.ActionQueue.ActionQueueHooked
instance XMonad.Core.ExtensionClass XMonad.Util.ActionQueue.ActionQueue


-- | Want to customize border width, for each window on all layouts? Want
--   specific window have no border on all layouts? Try this.
module XMonad.Hooks.BorderPerWindow
defineBorderWidth :: Dimension -> ManageHook

-- | Every time the <tt>logHook</tt> runs, execute all actions in the
--   queue.
actionQueue :: XConfig l -> XConfig l


-- | This module provides a way to have "cycling" actions. This means that
--   you can define an <tt>X ()</tt> action that cycles through a list of
--   actions, advancing every time it is executed. This may for exapmle be
--   useful for toggle-style keybindings.
module XMonad.Util.ActionCycle

-- | Generate an <tt>X ()</tt> action that cycles through a list of
--   actions, advancing every time the action is called.
cycleAction :: String -> [X ()] -> X ()

-- | Another version of <a>cycleAction</a> that returns the result of the
--   actions. To allow for this, we must make sure that the list of actions
--   is non-empty.
cycleActionWithResult :: String -> NonEmpty (X a) -> X a
instance XMonad.Core.ExtensionClass XMonad.Util.ActionCycle.ActionCycleState


-- | Keeps track of workspace viewing order.
module XMonad.Hooks.WorkspaceHistory

-- | A <a>logHook</a> that keeps track of the order in which workspaces
--   have been viewed.
workspaceHistoryHook :: X ()

-- | Like <a>workspaceHistoryHook</a>, but with the ability to exclude
--   certain workspaces.
workspaceHistoryHookExclude :: [WorkspaceId] -> X ()

-- | A list of workspace tags in the order they have been viewed, with the
--   most recent first. No duplicates are present, but not all workspaces
--   are guaranteed to appear, and there may be workspaces that no longer
--   exist.
workspaceHistory :: X [WorkspaceId]
workspaceHistoryByScreen :: X [(ScreenId, [WorkspaceId])]
workspaceHistoryWithScreen :: X [(ScreenId, WorkspaceId)]
workspaceHistoryTransaction :: X () -> X ()

-- | Modify a the workspace history with a given pure function.
workspaceHistoryModify :: ([(ScreenId, WorkspaceId)] -> [(ScreenId, WorkspaceId)]) -> X ()
instance Control.DeepSeq.NFData XMonad.Hooks.WorkspaceHistory.WorkspaceHistory
instance GHC.Show.Show XMonad.Hooks.WorkspaceHistory.WorkspaceHistory
instance GHC.Read.Read XMonad.Hooks.WorkspaceHistory.WorkspaceHistory
instance XMonad.Core.ExtensionClass XMonad.Hooks.WorkspaceHistory.WorkspaceHistory


-- | Cycle through previously viewed workspaces in the order they were
--   viewed most recently on the screen where cycling is taking place.
module XMonad.Actions.CycleWorkspaceByScreen

-- | Like <a>cycleRecentWS</a>, but only cycle through the most recent
--   workspaces on the given screen.
cycleWorkspaceOnScreen :: ScreenId -> [KeySym] -> KeySym -> KeySym -> X ()

-- | Like <a>cycleWorkspaceOnScreen</a>, but supply the currently focused
--   screen as the <tt>screenId</tt>.
cycleWorkspaceOnCurrentScreen :: [KeySym] -> KeySym -> KeySym -> X ()
handleKeyEvent :: EventType -> KeySym -> X () -> EventType -> KeySym -> Maybe (X ())

-- | <i>Deprecated: Use XMonad.Actions.Repeatable.repeatable</i>
repeatableAction :: [KeySym] -> KeySym -> (EventType -> KeySym -> X ()) -> X ()


-- | Log hook which changes the wallpapers depending on visible workspaces.
module XMonad.Hooks.WallpaperSetter

-- | Add this to your log hook with the workspace configuration as
--   argument.
wallpaperSetter :: WallpaperConf -> X ()

-- | Complete wallpaper configuration passed to the hook
data WallpaperConf
WallpaperConf :: FilePath -> WallpaperList -> WallpaperConf

-- | Where the wallpapers reside (if empty, will look in ~/.wallpapers/)
[wallpaperBaseDir] :: WallpaperConf -> FilePath

-- | List of the wallpaper associations for workspaces
[wallpapers] :: WallpaperConf -> WallpaperList

-- | Represents a wallpaper
data Wallpaper

-- | Single, fixed wallpaper
WallpaperFix :: FilePath -> Wallpaper

-- | Random wallpaper from this subdirectory
WallpaperDir :: FilePath -> Wallpaper
newtype WallpaperList
WallpaperList :: [(WorkspaceId, Wallpaper)] -> WallpaperList

-- | default configuration. looks in ~/.wallpapers/ for WORKSPACEID.jpg
defWallpaperConf :: WallpaperConf

-- | Return the default association list (maps <tt>name</tt> to
--   <tt>name.jpg</tt>, non-alphanumeric characters are omitted)
defWPNamesJpg :: [WorkspaceId] -> WallpaperList

-- | Like <a>defWPNamesJpg</a>, but map <tt>name</tt> to <tt>name.png</tt>
--   instead.
defWPNamesPng :: [WorkspaceId] -> WallpaperList

-- | <i>Deprecated: Use defWPNamesJpg instead</i>
defWPNames :: [WorkspaceId] -> WallpaperList
instance GHC.Read.Read XMonad.Hooks.WallpaperSetter.Wallpaper
instance GHC.Show.Show XMonad.Hooks.WallpaperSetter.Wallpaper
instance GHC.Classes.Eq XMonad.Hooks.WallpaperSetter.Wallpaper
instance GHC.Read.Read XMonad.Hooks.WallpaperSetter.WallpaperList
instance GHC.Show.Show XMonad.Hooks.WallpaperSetter.WallpaperList
instance GHC.Read.Read XMonad.Hooks.WallpaperSetter.WallpaperConf
instance GHC.Show.Show XMonad.Hooks.WallpaperSetter.WallpaperConf
instance Data.Default.Class.Default XMonad.Hooks.WallpaperSetter.WallpaperConf
instance GHC.Base.Semigroup XMonad.Hooks.WallpaperSetter.WallpaperList
instance GHC.Base.Monoid XMonad.Hooks.WallpaperSetter.WallpaperList
instance XMonad.Core.ExtensionClass XMonad.Hooks.WallpaperSetter.WCState


-- | Hook and keybindings for toggling hook behavior.
module XMonad.Hooks.ToggleHook

-- | This <a>ManageHook</a> will selectively apply a hook as set by
--   <a>hookNext</a> and <a>hookAllNew</a>.
toggleHook :: String -> ManageHook -> ManageHook
toggleHook' :: String -> ManageHook -> ManageHook -> ManageHook

-- | <tt>hookNext name True</tt> arranges for the next spawned window to
--   have the hook <tt>name</tt> applied, <tt>hookNext name False</tt>
--   cancels it.
hookNext :: String -> Bool -> X ()
toggleHookNext :: String -> X ()

-- | <tt>hookAllNew name True</tt> arranges for new windows to have the
--   hook <tt>name</tt> applied, <tt>hookAllNew name False</tt> cancels it
hookAllNew :: String -> Bool -> X ()
toggleHookAllNew :: String -> X ()

-- | Query what will happen at the next ManageHook call for the hook
--   <tt>name</tt>.
willHook :: String -> X Bool

-- | Whether the next window will trigger the hook <tt>name</tt>.
willHookNext :: String -> X Bool

-- | Whether new windows will trigger the hook <tt>name</tt>.
willHookAllNew :: String -> X Bool
willHookNextPP :: String -> (String -> String) -> X (Maybe String)
willHookAllNewPP :: String -> (String -> String) -> X (Maybe String)
runLogHook :: X ()
instance GHC.Show.Show XMonad.Hooks.ToggleHook.HookState
instance GHC.Read.Read XMonad.Hooks.ToggleHook.HookState
instance XMonad.Core.ExtensionClass XMonad.Hooks.ToggleHook.HookState


-- | Hook and keybindings for automatically sending the next spawned
--   window(s) to the floating layer.
module XMonad.Hooks.FloatNext

-- | This <a>ManageHook</a> will selectively float windows as set by
--   <a>floatNext</a> and <a>floatAllNew</a>.
floatNextHook :: ManageHook

-- | <tt>floatNext True</tt> arranges for the next spawned window to be
--   sent to the floating layer, <tt>floatNext False</tt> cancels it.
floatNext :: Bool -> X ()
toggleFloatNext :: X ()

-- | <tt>floatAllNew True</tt> arranges for new windows to be sent to the
--   floating layer, <tt>floatAllNew False</tt> cancels it
floatAllNew :: Bool -> X ()
toggleFloatAllNew :: X ()

-- | Whether the next window will be set floating
willFloatNext :: X Bool

-- | Whether new windows will be set floating
willFloatAllNew :: X Bool
willFloatNextPP :: (String -> String) -> X (Maybe String)
willFloatAllNewPP :: (String -> String) -> X (Maybe String)
runLogHook :: X ()


-- | Run <tt>X ()</tt> actions by touching the edge of your screen with
--   your mouse.
module XMonad.Hooks.ScreenCorners
data ScreenCorner
SCUpperLeft :: ScreenCorner
SCUpperRight :: ScreenCorner
SCLowerLeft :: ScreenCorner
SCLowerRight :: ScreenCorner
SCTop :: ScreenCorner
SCBottom :: ScreenCorner
SCLeft :: ScreenCorner
SCRight :: ScreenCorner

-- | Add one single <tt>X ()</tt> action to a screen corner
addScreenCorner :: ScreenCorner -> X () -> X ()

-- | Add a list of <tt>(ScreenCorner, X ())</tt> tuples
addScreenCorners :: [(ScreenCorner, X ())] -> X ()

-- | Handle screen corner events
screenCornerEventHook :: Event -> X All
screenCornerLayoutHook :: l a -> ModifiedLayout ScreenCornerLayout l a
instance GHC.Show.Show XMonad.Hooks.ScreenCorners.ScreenCorner
instance GHC.Classes.Ord XMonad.Hooks.ScreenCorners.ScreenCorner
instance GHC.Classes.Eq XMonad.Hooks.ScreenCorners.ScreenCorner
instance GHC.Show.Show (XMonad.Hooks.ScreenCorners.ScreenCornerLayout a)
instance GHC.Read.Read (XMonad.Hooks.ScreenCorners.ScreenCornerLayout a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Hooks.ScreenCorners.ScreenCornerLayout a
instance XMonad.Core.ExtensionClass XMonad.Hooks.ScreenCorners.ScreenCornerState


-- | One-shot and permanent ManageHooks that can be updated at runtime.
module XMonad.Hooks.DynamicHooks

-- | Master <a>ManageHook</a> that must be in your <tt>xmonad.hs</tt>
--   <a>ManageHook</a>.
dynamicMasterHook :: ManageHook

-- | Appends the given <a>ManageHook</a> to the permanent dynamic
--   <a>ManageHook</a>.
addDynamicHook :: ManageHook -> X ()

-- | Modifies the permanent <a>ManageHook</a> with an arbitrary function.
updateDynamicHook :: (ManageHook -> ManageHook) -> X ()

-- | Creates a one-shot <a>ManageHook</a>. Note that you have to specify
--   the two parts of the <a>ManageHook</a> separately. Where you would
--   usually write:
--   
--   <pre>
--   className =? "example" --&gt; doFloat
--   </pre>
--   
--   you must call <a>oneShotHook</a> as
--   
--   <pre>
--   oneShotHook dynHooksRef (className =? "example) doFloat
--   </pre>
oneShotHook :: Query Bool -> ManageHook -> X ()
instance XMonad.Core.ExtensionClass XMonad.Hooks.DynamicHooks.DynamicHooks


-- | Ensures that the windows of the current workspace are always in front
--   of windows that are located on other visible screens. This becomes
--   important if you use decoration and drag windows from one screen to
--   another. Using this module, the dragged window will always be in front
--   of other windows.
module XMonad.Hooks.CurrentWorkspaceOnTop
currentWorkspaceOnTop :: X ()
instance XMonad.Core.ExtensionClass XMonad.Hooks.CurrentWorkspaceOnTop.CWOTState


-- | A workscreen permits to display a set of workspaces on several
--   screens. In xinerama mode, when a workscreen is viewed, workspaces
--   associated to all screens are visible.
--   
--   The first workspace of a workscreen is displayed on first screen,
--   second on second screen, etc. Workspace position can be easily
--   changed. If the current workscreen is called again, workspaces are
--   shifted.
--   
--   This also permits to see all workspaces of a workscreen even if just
--   one screen is present, and to move windows from workspace to
--   workscreen.
module XMonad.Actions.Workscreen

-- | Initial configuration of workscreens
configWorkscreen :: [Workscreen] -> X ()

-- | View workscreen of index <tt>WorkscreenId</tt>. If current workscreen
--   is asked workscreen, workscreen's workspaces are shifted.
viewWorkscreen :: WorkscreenId -> X ()
data Workscreen
Workscreen :: Int -> [WorkspaceId] -> Workscreen
[workscreenId] :: Workscreen -> Int
[workspaces] :: Workscreen -> [WorkspaceId]

-- | Shift a window on the first workspace of workscreen
--   <tt>WorkscreenId</tt>.
shiftToWorkscreen :: WorkscreenId -> X ()

-- | Create workscreen list from workspace list. Group workspaces to
--   packets of screens number size.
fromWorkspace :: Int -> [WorkspaceId] -> [Workscreen]

-- | Helper to group workspaces. Multiply workspace by screens number.
expandWorkspace :: Int -> [WorkspaceId] -> [WorkspaceId]
type WorkscreenId = Int
instance GHC.Show.Show XMonad.Actions.Workscreen.Workscreen
instance GHC.Show.Show XMonad.Actions.Workscreen.WorkscreenStorage
instance XMonad.Core.ExtensionClass XMonad.Actions.Workscreen.WorkscreenStorage


-- | Module for tracking master window history per workspace, and
--   associated functions for manipulating the stack using such history.
module XMonad.Actions.SwapPromote

-- | Mapping from workspace tag to master history list. The current master
--   is the head of the list, the previous master the second element, and
--   so on. Without history, the list is empty.
newtype MasterHistory
MasterHistory :: Map WorkspaceId [Window] -> MasterHistory
[getMasterHistory] :: MasterHistory -> Map WorkspaceId [Window]

-- | Return the master history map from the state.
getMasterHistoryMap :: X (Map WorkspaceId [Window])

-- | Return the master history list of a given tag. The master history list
--   may be empty. An invalid tag will also result in an empty list.
getMasterHistoryFromTag :: WorkspaceId -> X [Window]

-- | Return the master history list of the current workspace.
getMasterHistoryCurrent :: X [Window]

-- | Return the master history list of the workspace containing the given
--   window. Return an empty list if the window is not in the stackset.
getMasterHistoryFromWindow :: Window -> X [Window]

-- | Modify the master history list of a given workspace, or the empty list
--   of no such workspace is mapped. The result is then re-inserted into
--   the master history map.
modifyMasterHistoryFromTag :: WorkspaceId -> ([Window] -> [Window]) -> X ()

-- | Modify the master history list of the current workspace. While the
--   current workspace is guaranteed to exist; its master history may not.
--   For more information see <a>modifyMasterHistoryFromTag</a>.
modifyMasterHistoryCurrent :: ([Window] -> [Window]) -> X ()

-- | A <a>logHook</a> to update the master history mapping. Non-existent
--   workspaces are removed, and the master history list for the current
--   workspaces is updated. See <a>masterHistoryHook'</a>.
masterHistoryHook :: X ()

-- | Backend for <a>masterHistoryHook</a>.
masterHistoryHook' :: Bool -> ([Window] -> [Window] -> [Window]) -> X ()

-- | Given the current master history list and an integrated stack, return
--   the new master history list. The current master is either moved (if it
--   exists within the history) or added to the head of the list, and all
--   missing (i.e. closed) windows are removed.
updateMasterHistory :: [Window] -> [Window] -> [Window]

-- | Wrap <a>swapPromoteStack</a>; see also <a>swapApply</a>.
swapPromote :: Bool -> X Bool

-- | Like <a>swapPromote'</a> but discard the result.
swapPromote' :: Bool -> X ()

-- | Wrap <a>swapInStack</a>; see also <a>swapApply</a>.
swapIn :: Bool -> X Bool

-- | Like <a>swapIn'</a> but discard the result.
swapIn' :: Bool -> X ()

-- | Wrap <a>swapHybridStack</a>; see also <a>swapApply</a>.
swapHybrid :: Bool -> X Bool

-- | Like <a>swapHybrid'</a> but discard the result.
swapHybrid' :: Bool -> X ()

-- | Apply the given master history stack modifier to the current stack. If
--   given <tt>True</tt>, all non-focused floating windows will be ignored.
--   Return <tt>True</tt> if insufficient history; if so use <a>whenX</a>
--   to sequence a backup promotion function.
swapApply :: Bool -> (Maybe Window -> Stack Window -> (Bool, Stack Window)) -> X Bool

-- | If the focused window is the master window and there is no previous
--   master, do nothing. Otherwise swap the master with the previous
--   master. If the focused window is not the master window, swap it with
--   the master window. In either case focus follows the original window,
--   i.e. the focused window does not change, only its position.
--   
--   The first argument is the previous master (which may not exist), the
--   second a window stack. Return <tt>True</tt> if the master history
--   hindered the swap; the history is either empty or out-of-sync. Though
--   the latter shouldn't happen this function never changes the stack
--   under such circumstances.
swapPromoteStack :: Maybe Window -> Stack Window -> (Bool, Stack Window)

-- | Perform the same swap as <a>swapPromoteStack</a>. However the new
--   window receives the focus; it appears to "swap into" the position of
--   the original window. Under this model focus follows stack position and
--   the zipper does not move.
--   
--   See <a>swapPromoteStack</a> for more details regarding the parameters.
swapInStack :: Maybe Window -> Stack Window -> (Bool, Stack Window)

-- | If the focused window is the master window, use <a>swapInStack</a>.
--   Otherwise use <a>swapPromoteStack</a>.
--   
--   See <a>swapPromoteStack</a> for more details regarding the parameters.
swapHybridStack :: Maybe Window -> Stack Window -> (Bool, Stack Window)

-- | Cycle a list by the given count. If positive, cycle to the left. If
--   negative, cycle to the right:
--   
--   <pre>
--   &gt;&gt;&gt; cycleN 2 [1,2,3,4,5]
--   [3,4,5,1,2]
--   
--   &gt;&gt;&gt; cycleN (-2) [1,2,3,4,5]
--   [4,5,1,2,3]
--   </pre>
cycleN :: Int -> [a] -> [a]

-- | Wrap <a>split'</a> with an initial index of <tt>0</tt>, discarding the
--   list's length.
split :: (Num a, Enum a) => (b -> Bool) -> [b] -> ([(a, b)], [b])

-- | Given a predicate, an initial index and a list, return a tuple
--   containing:
--   
--   <ul>
--   <li>List length.</li>
--   <li>Indexed list of elements which satisfy the predicate. An indexed
--   element is a tuple containing the element index (offset by the initial
--   index) and the element.</li>
--   <li>List of elements which do not satisfy the predicate.</li>
--   </ul>
--   
--   The initial index and length of the list simplify chaining calls to
--   this function, such as for zippers of lists.
split' :: (Num a, Enum a) => (b -> Bool) -> a -> [b] -> (a, [(a, b)], [b])

-- | Wrap <a>merge'</a> with an initial virtual index of <tt>0</tt>. Return
--   only the unindexed list with elements from the leftover indexed list
--   appended.
merge :: (Ord a, Num a) => [(a, b)] -> [b] -> [b]

-- | Inverse of <a>split</a>. Merge an indexed list with an unindexed list
--   (see <a>split'</a>). Given a virtual index, an indexed list and an
--   unindexed list, return a tuple containing:
--   
--   <ul>
--   <li>Virtual index <i>after</i> the unindexed list</li>
--   <li>Remainder of the indexed list</li>
--   <li>Merged unindexed list</li>
--   </ul>
--   
--   If the indexed list is empty, this functions consumes the entire
--   unindexed list. If the unindexed list is empty, this function consumes
--   only adjacent indexed elements. For example,
--   <tt>[(10,"ten"),(12,"twelve")]</tt> implies missing unindexed elements
--   and so once <tt>(10,"ten")</tt> is consumed this function concludes.
--   
--   The indexed list is assumed to have been created by <a>split'</a> and
--   not checked for correctness. Indices are assumed to be ascending, i.e.
--   &gt; [(1,"one"),(2,"two"),(4,"four")]
--   
--   The initial and final virtual indices simplify chaining calls to the
--   this function, as as for zippers of lists. Positive values shift the
--   unindexed list towards the tail, as if preceded by that many elements.
merge' :: (Ord a, Num a) => a -> [(a, b)] -> [b] -> (a, [(a, b)], [b])

-- | Remove all elements of the set from the stack. Skip the currently
--   focused member. Return an indexed list of excluded elements and the
--   modified stack. Use <a>stackMerge</a> to re-insert the elements using
--   this list.
stackSplit :: (Num a, Enum a, Ord b) => Stack b -> Set b -> ([(a, b)], Stack b)

-- | Inverse of <a>stackSplit</a>. Given a list of elements and their
--   original indices, re-insert the elements into these same positions
--   within the stack. Skip the currently focused member. Works best if the
--   stack's length hasn't changed, though if shorter any leftover elements
--   will be tacked on.
stackMerge :: (Ord a, Num a) => Stack b -> [(a, b)] -> Stack b
instance GHC.Show.Show XMonad.Actions.SwapPromote.MasterHistory
instance GHC.Read.Read XMonad.Actions.SwapPromote.MasterHistory
instance XMonad.Core.ExtensionClass XMonad.Actions.SwapPromote.MasterHistory


-- | Ability to repeat the last action.
module XMonad.Actions.RepeatAction

-- | Transforms an action into an action that can be remembered and
--   repeated.
rememberAction :: X () -> X ()

-- | Maps <a>rememberAction</a> over a list of key bindings and adds a
--   dedicated key to repeat the last action.
rememberActions :: a -> [(a, X ())] -> [(a, X ())]
infixl 4 `rememberActions`

-- | Runs the last remembered action. <i> Be careful not to include this
--   action in the remembered actions! </i>
repeatLast :: X ()
instance XMonad.Core.ExtensionClass XMonad.Actions.RepeatAction.LastAction


-- | Provides methods for cycling through groups of windows across
--   workspaces, ignoring windows that do not belong to this group. A group
--   consists of all windows matching a user-provided boolean query.
--   
--   Also provides a method for jumping back to the most recently used
--   window in any given group, and predefined groups.
module XMonad.Actions.GroupNavigation

-- | The direction in which to look for the next match
data Direction

-- | Forward from current window or workspace
Forward :: Direction

-- | Backward from current window or workspace
Backward :: Direction

-- | Backward in history
History :: Direction

-- | Focuses the next window that matches the given boolean query. Does
--   nothing if there is no such window. This is the same as
--   <a>nextMatchOrDo</a> with alternate action <tt>return ()</tt>.
nextMatch :: Direction -> Query Bool -> X ()

-- | Focuses the next window that matches the given boolean query. If there
--   is no such window, perform the given action instead.
nextMatchOrDo :: Direction -> Query Bool -> X () -> X ()

-- | Focuses the next window for which the given query produces the same
--   result as the currently focused window. Does nothing if there is no
--   focused window (i.e., the current workspace is empty).
nextMatchWithThis :: Eq a => Direction -> Query a -> X ()

-- | Action that needs to be executed as a logHook to maintain the focus
--   history of all windows as the WindowSet changes.
historyHook :: X ()

-- | A query that matches all windows on visible workspaces. This is useful
--   for configurations with multiple screens, and matches even invisible
--   windows.
isOnAnyVisibleWS :: Query Bool
instance Control.DeepSeq.NFData XMonad.Actions.GroupNavigation.HistoryDB
instance GHC.Generics.Generic XMonad.Actions.GroupNavigation.HistoryDB
instance GHC.Show.Show XMonad.Actions.GroupNavigation.HistoryDB
instance GHC.Read.Read XMonad.Actions.GroupNavigation.HistoryDB
instance XMonad.Core.ExtensionClass XMonad.Actions.GroupNavigation.HistoryDB


-- | Based on the Alt+Tab behaviour common outside of xmonad.
module XMonad.Actions.MostRecentlyUsed

-- | Configure xmonad to support <a>mostRecentlyUsed</a>.
configureMRU :: XConfig l -> XConfig l

-- | An action to browse through the history of focused windows, taking
--   another step back with each tap of the key.
mostRecentlyUsed :: [KeySym] -> KeySym -> X ()

-- | A version of <a>mostRecentlyUsed</a> that allows you to customise
--   exactly what is done with each window you tab through (the default
--   being to visit its previous <a>Location</a> and give it focus).
withMostRecentlyUsed :: [KeySym] -> KeySym -> (Window -> Location -> X ()) -> X ()
data Location
Location :: !WorkspaceId -> !ScreenId -> Location
[workspace] :: Location -> !WorkspaceId
[screen] :: Location -> !ScreenId
instance GHC.Classes.Ord XMonad.Actions.MostRecentlyUsed.Location
instance GHC.Classes.Eq XMonad.Actions.MostRecentlyUsed.Location
instance GHC.Read.Read XMonad.Actions.MostRecentlyUsed.Location
instance GHC.Show.Show XMonad.Actions.MostRecentlyUsed.Location
instance GHC.Read.Read XMonad.Actions.MostRecentlyUsed.WindowHistory
instance GHC.Show.Show XMonad.Actions.MostRecentlyUsed.WindowHistory
instance GHC.Base.Semigroup XMonad.Actions.MostRecentlyUsed.MRU
instance XMonad.Core.ExtensionClass XMonad.Actions.MostRecentlyUsed.WindowHistory


-- | A module for handling pixel rectangles: <a>Rectangle</a>.
module XMonad.Util.Rectangle

-- | Rectangle as two points. What those points mean depends on the
--   conversion function.
data PointRectangle a
PointRectangle :: a -> a -> a -> a -> PointRectangle a

-- | Point nearest to the origin.
[point_x1] :: PointRectangle a -> a
[point_y1] :: PointRectangle a -> a

-- | Point furthest from the origin.
[point_x2] :: PointRectangle a -> a
[point_y2] :: PointRectangle a -> a

-- | There are three possible ways to convert rectangles to pixels:
--   
--   <ul>
--   <li>Consider integers as "gaps" between pixels; pixels range from
--   <tt>(N,N+1)</tt>, exclusively: <tt>(0,1)</tt>, <tt>(1,2)</tt>, and so
--   on. This leads to interval ambiguity: whether an integer endpoint
--   contains a pixel depends on which direction the interval approaches
--   the pixel. Consider the adjacent pixels <tt>(0,1)</tt> and
--   <tt>(1,2)</tt> where <tt>1</tt> can refer to either pixel
--   <tt>(0,1)</tt> or pixel <tt>(1,2)</tt>.</li>
--   <li>Consider integers to demarcate the start of each pixel; pixels
--   range from <tt>[N,N+1)</tt>: <tt>[0,1)</tt>, <tt>[1,2)</tt>, and so on
--   - or equivalently: <tt>(N,N+1]</tt>. This is the most flexible
--   coordinate system, and the convention used by the <a>Rectangle</a>
--   type.</li>
--   <li>Consider integers to demarcate the center of each pixel; pixels
--   range from <tt>[N,N+1]</tt>, as though each real-valued coordinate had
--   been rounded (either down or up) to the nearest integers. So each
--   pixel, from zero, is listed as: <tt>[0,0]</tt>, <tt>[1,1]</tt>,
--   <tt>[2,2]</tt>, and so on. Rather than a coordinate system, this
--   considers pixels as row/column indices. While easiest to reason with,
--   indices are unable to represent zero-dimension rectangles.</li>
--   </ul>
--   
--   Consider pixels as indices. Do not use this on empty rectangles.
pixelsToIndices :: Rectangle -> PointRectangle Integer

-- | Consider pixels as <tt>[N,N+1)</tt> coordinates. Available for empty
--   rectangles.
pixelsToCoordinates :: Rectangle -> PointRectangle Integer

-- | Invert <a>pixelsToIndices</a>.
indicesToRectangle :: PointRectangle Integer -> Rectangle

-- | Invert <a>pixelsToCoordinates</a>.
coordinatesToRectangle :: PointRectangle Integer -> Rectangle

-- | True if either the <a>rect_width</a> or <a>rect_height</a> fields are
--   zero, i.e. the rectangle has no area.
empty :: Rectangle -> Bool

-- | True if the intersection of the set of points comprising each
--   rectangle is not the empty set. Therefore any rectangle containing the
--   initial points of an empty rectangle will never intersect that
--   rectangle - including the same empty rectangle.
intersects :: Rectangle -> Rectangle -> Bool

-- | True if the first rectangle contains at least all the points of the
--   second rectangle. Any rectangle containing the initial points of an
--   empty rectangle will be a superset of that rectangle - including the
--   same empty rectangle.
supersetOf :: Rectangle -> Rectangle -> Bool

-- | Return the smallest set of rectangles resulting from removing all the
--   points of the second rectangle from those of the first, i.e. <tt>r1 -
--   r2</tt>, such that <tt>0 &lt;= l &lt;= 4</tt> where <tt>l</tt> is the
--   length of the resulting list.
difference :: Rectangle -> Rectangle -> [Rectangle]

-- | Fit a <a>Rectangle</a> within the given borders of itself. Given
--   insufficient space, borders are minimized while preserving the ratio
--   of opposite borders. Origin is top-left, and yes, negative borders are
--   allowed.
withBorder :: Integer -> Integer -> Integer -> Integer -> Integer -> Rectangle -> Rectangle

-- | Calculate the center - <tt>(x,y)</tt> - as if the <a>Rectangle</a>
--   were bounded.
center :: Rectangle -> (Ratio Integer, Ratio Integer)

-- | Invert <a>scaleRationalRect</a>. Since that operation is lossy a
--   roundtrip conversion may not result in the original value. The first
--   <a>Rectangle</a> is scaled to the second:
--   
--   <pre>
--   &gt;&gt;&gt; (Rectangle 2 2 6 6) `toRatio` (Rectangle 0 0 10 10)
--   RationalRect (1 % 5) (1 % 5) (3 % 5) (3 % 5)
--   </pre>
toRatio :: Rectangle -> Rectangle -> RationalRect
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Util.Rectangle.PointRectangle a)
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Util.Rectangle.PointRectangle a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (XMonad.Util.Rectangle.PointRectangle a)


-- | Add a configurable amount of space around windows.
--   
--   Note: For space/gaps along edges of the <i>screen</i> see
--   <a>XMonad.Layout.Gaps</a>.
module XMonad.Layout.Spacing

-- | A <a>LayoutModifier</a> providing customizable screen and window
--   borders. Borders are clamped to <tt>[0,Infinity]</tt> before being
--   applied.
data Spacing a
Spacing :: Bool -> Border -> Bool -> Border -> Bool -> Spacing a

-- | When <tt>True</tt> borders are not applied if there fewer than two
--   windows.
[smartBorder] :: Spacing a -> Bool

-- | The screen border.
[screenBorder] :: Spacing a -> Border

-- | Is the screen border enabled?
[screenBorderEnabled] :: Spacing a -> Bool

-- | The window borders.
[windowBorder] :: Spacing a -> Border

-- | Is the window border enabled?
[windowBorderEnabled] :: Spacing a -> Bool

-- | Generate the <a>ModifiedLayout</a>, exposing all initial state of
--   <a>Spacing</a>.
spacingRaw :: Bool -> Border -> Bool -> Border -> Bool -> l a -> ModifiedLayout Spacing l a

-- | Surround all windows by a certain number of pixels of blank space. See
--   <a>spacingRaw</a>.
spacing :: Int -> l a -> ModifiedLayout Spacing l a

-- | Surround all windows by a certain number of pixels of blank space, and
--   additionally adds the same amount of spacing around the edge of the
--   screen. See <a>spacingRaw</a>.
spacingWithEdge :: Int -> l a -> ModifiedLayout Spacing l a

-- | Surrounds all windows with blank space, except when the window is the
--   only visible window on the current workspace. See <a>spacingRaw</a>.
smartSpacing :: Int -> l a -> ModifiedLayout Spacing l a

-- | Surrounds all windows with blank space, and adds the same amount of
--   spacing around the edge of the screen, except when the window is the
--   only visible window on the current workspace. See <a>spacingRaw</a>.
smartSpacingWithEdge :: Int -> l a -> ModifiedLayout Spacing l a

-- | Messages to alter the state of <a>Spacing</a> using the endomorphic
--   function arguments.
data SpacingModifier
ModifySmartBorder :: (Bool -> Bool) -> SpacingModifier
ModifyScreenBorder :: (Border -> Border) -> SpacingModifier
ModifyScreenBorderEnabled :: (Bool -> Bool) -> SpacingModifier
ModifyWindowBorder :: (Border -> Border) -> SpacingModifier
ModifyWindowBorderEnabled :: (Bool -> Bool) -> SpacingModifier

-- | Set <a>smartBorder</a> to the given <a>Bool</a>.
setSmartSpacing :: Bool -> X ()

-- | Set <a>screenBorder</a> to the given <a>Border</a>.
setScreenSpacing :: Border -> X ()

-- | Set <a>screenBorderEnabled</a> to the given <a>Bool</a>.
setScreenSpacingEnabled :: Bool -> X ()

-- | Set <a>windowBorder</a> to the given <a>Border</a>.
setWindowSpacing :: Border -> X ()

-- | Set <a>windowBorderEnabled</a> to the given <a>Bool</a>.
setWindowSpacingEnabled :: Bool -> X ()

-- | Toggle <a>smartBorder</a>.
toggleSmartSpacing :: X ()

-- | Toggle <a>screenBorderEnabled</a>.
toggleScreenSpacingEnabled :: X ()

-- | Toggle <a>windowBorderEnabled</a>.
toggleWindowSpacingEnabled :: X ()

-- | Set all borders to a uniform size; see <a>setWindowSpacing</a> and
--   <a>setScreenSpacing</a>.
setScreenWindowSpacing :: Integer -> X ()

-- | Increment the borders of <a>windowBorder</a> using
--   <a>borderIncrementBy</a>, which preserves border ratios during
--   clamping.
incWindowSpacing :: Integer -> X ()

-- | Increment the borders of <a>screenBorder</a> using
--   <a>borderIncrementBy</a>.
incScreenSpacing :: Integer -> X ()

-- | Inverse of <a>incWindowSpacing</a>, equivalent to applying
--   <a>negate</a>.
decWindowSpacing :: Integer -> X ()

-- | Inverse of <a>incScreenSpacing</a>.
decScreenSpacing :: Integer -> X ()

-- | Increment both screen and window borders; see <a>incWindowSpacing</a>
--   and <a>incScreenSpacing</a>.
incScreenWindowSpacing :: Integer -> X ()

-- | Inverse of <a>incScreenWindowSpacing</a>.
decScreenWindowSpacing :: Integer -> X ()

-- | Represent the borders of a rectangle.
data Border
Border :: Integer -> Integer -> Integer -> Integer -> Border
[top] :: Border -> Integer
[bottom] :: Border -> Integer
[right] :: Border -> Integer
[left] :: Border -> Integer

-- | Map a function over a <a>Border</a>. That is, over the four individual
--   borders.
borderMap :: (Integer -> Integer) -> Border -> Border

-- | Change the border spacing by the provided amount, adjusted so that at
--   least one border field is <tt>&gt;=0</tt>.
borderIncrementBy :: Integer -> Border -> Border
instance GHC.Read.Read XMonad.Layout.Spacing.Border
instance GHC.Show.Show XMonad.Layout.Spacing.Border
instance GHC.Read.Read (XMonad.Layout.Spacing.Spacing a)
instance GHC.Show.Show (XMonad.Layout.Spacing.Spacing a)
instance GHC.Classes.Eq a => XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Spacing.Spacing a
instance XMonad.Core.Message XMonad.Layout.Spacing.SpacingModifier


-- | Make a given layout display without borders. This is useful for
--   full-screen or tabbed layouts, where you don't really want to waste a
--   couple of pixels of real estate just to inform yourself that the
--   visible window has focus.
module XMonad.Layout.NoBorders

-- | Removes all window borders from the specified layout.
noBorders :: LayoutClass l Window => l Window -> ModifiedLayout WithBorder l Window

-- | Removes the borders from a window under one of the following
--   conditions:
--   
--   <ul>
--   <li>There is only one screen and only one window. In this case it's
--   obvious that it has the focus, so no border is needed.</li>
--   <li>A floating window covers the entire screen (e.g. mplayer).</li>
--   </ul>
smartBorders :: LayoutClass l a => l a -> ModifiedLayout SmartBorder l a

-- | Forces a layout to use the specified border width. <a>noBorders</a> is
--   equivalent to <tt><a>withBorder</a> 0</tt>.
withBorder :: LayoutClass l a => Dimension -> l a -> ModifiedLayout WithBorder l a

-- | Apply a datatype that has a SetsAmbiguous instance to provide a list
--   of windows that should not have borders.
--   
--   This gives flexibility over when borders should be drawn, in
--   particular with xinerama setups: <a>Ambiguity</a> has a number of
--   useful <a>SetsAmbiguous</a> instances
lessBorders :: (SetsAmbiguous p, Read p, Show p, LayoutClass l a) => p -> l a -> ModifiedLayout (ConfigurableBorder p) l a

-- | <a>ManageHook</a> for sending <a>HasBorder</a> messages:
--   
--   <pre>
--   title =? "foo" --&gt; hasBorder True
--   </pre>
--   
--   There is no equivalent for <a>ResetBorder</a>.
hasBorder :: Bool -> ManageHook

-- | SetsAmbiguous allows custom actions to generate lists of windows that
--   should not have borders drawn through <a>ConfigurableBorder</a>
--   
--   To add your own (though perhaps those options would better belong as
--   an additional constructor to <a>Ambiguity</a>), you can add the
--   following function. Note that <tt>lr</tt>, the parameter representing
--   the <a>Rectangle</a> of the parent layout, was added to <a>hiddens</a>
--   in 0.14. Update your instance accordingly.
--   
--   <pre>
--   data MyAmbiguity = MyAmbiguity deriving (Read, Show)
--   </pre>
--   
--   <pre>
--   instance SetsAmbiguous MyAmbiguity where
--    hiddens _ wset lr mst wrs = otherHiddens Screen \\ otherHiddens OnlyScreenFloat
--       where otherHiddens p = hiddens p wset lr mst wrs
--   </pre>
--   
--   The above example is redundant, because you can have the same result
--   with:
--   
--   <pre>
--   layoutHook = lessBorders (Combine Difference Screen OnlyScreenFloat) (Tall 1 0.5 0.03 ||| ... )
--   </pre>
--   
--   To get the same result as <a>smartBorders</a>:
--   
--   <pre>
--   layoutHook = lessBorders Never (Tall 1 0.5 0.03 ||| ...)
--   </pre>
--   
--   This indirect method is required to keep the <a>Read</a> and
--   <a>Show</a> for ConfigurableBorder so that xmonad can serialize state.
class SetsAmbiguous p
hiddens :: SetsAmbiguous p => p -> WindowSet -> Rectangle -> Maybe (Stack Window) -> [(Window, Rectangle)] -> [Window]

-- | In order of increasing ambiguity (less borders more frequently), where
--   subsequent constructors add additional cases where borders are not
--   drawn than their predecessors. These behaviors make most sense with
--   with multiple screens: for single screens, <a>Never</a> or
--   <a>smartBorders</a> makes more sense.
data Ambiguity

-- | This constructor is used to combine the borderless windows provided by
--   the SetsAmbiguous instances from two other <a>Ambiguity</a> data
--   types.
Combine :: With -> Ambiguity -> Ambiguity -> Ambiguity

-- | Like <a>OnlyLayoutFloat</a>, but only removes borders if no window
--   stacked below remains visible. Considers all floating windows on the
--   current screen and all visible tiled windows of the child layout. If
--   any such window (that is stacked below) shows in any gap between the
--   parent layout rectangle and the physical screen, the border will
--   remain drawn.
OnlyLayoutFloatBelow :: Ambiguity

-- | Only remove borders on floating windows that exactly cover the parent
--   layout rectangle.
OnlyLayoutFloat :: Ambiguity

-- | Only remove borders on floating windows that cover the whole screen.
OnlyScreenFloat :: Ambiguity

-- | Like <a>OnlyScreenFloat</a>, and also remove borders of tiled windows
--   when not ambiguous: this is the same as <a>smartBorders</a>.
Never :: Ambiguity

-- | Focus in an empty screen does not count as ambiguous.
EmptyScreen :: Ambiguity

-- | No borders on full when all other screens have borders.
OtherIndicated :: Ambiguity

-- | Remove borders on all floating windows; tiling windows of any kinds
--   are not affected.
OnlyFloat :: Ambiguity

-- | Borders are never drawn on singleton screens. With this one you really
--   need another way such as a statusbar to detect focus.
Screen :: Ambiguity

-- | Used to indicate to the <a>SetsAmbiguous</a> instance for
--   <a>Ambiguity</a> how two lists should be combined.
data With

-- | uses <a>union</a>
Union :: With

-- | uses <a>\\</a>
Difference :: With

-- | uses <a>intersect</a>
Intersection :: With
data BorderMessage

-- | If <tt>True</tt>, never remove the border from the specified window.
--   If <tt>False</tt>, always remove the border from the specified window.
HasBorder :: Bool -> Window -> BorderMessage

-- | Reset the effects of any <a>HasBorder</a> messages on the specified
--   window.
ResetBorder :: Window -> BorderMessage

-- | Only necessary with <a>BorderMessage</a> - remove non-existent windows
--   from the <a>alwaysHidden</a> or <a>neverHidden</a> lists.
borderEventHook :: Event -> X All
type SmartBorder = ConfigurableBorder Ambiguity
data WithBorder a
data ConfigurableBorder p w
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.NoBorders.WithBorder a)
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Layout.NoBorders.WithBorder a)
instance (GHC.Show.Show p, GHC.Show.Show w) => GHC.Show.Show (XMonad.Layout.NoBorders.ConfigurableBorder p w)
instance (GHC.Read.Read p, GHC.Read.Read w) => GHC.Read.Read (XMonad.Layout.NoBorders.ConfigurableBorder p w)
instance GHC.Show.Show XMonad.Layout.NoBorders.With
instance GHC.Read.Read XMonad.Layout.NoBorders.With
instance GHC.Show.Show XMonad.Layout.NoBorders.Ambiguity
instance GHC.Read.Read XMonad.Layout.NoBorders.Ambiguity
instance XMonad.Layout.NoBorders.SetsAmbiguous XMonad.Layout.NoBorders.Ambiguity
instance (GHC.Read.Read p, GHC.Show.Show p, XMonad.Layout.NoBorders.SetsAmbiguous p) => XMonad.Layout.LayoutModifier.LayoutModifier (XMonad.Layout.NoBorders.ConfigurableBorder p) Graphics.X11.Types.Window
instance XMonad.Core.Message XMonad.Layout.NoBorders.BorderMessage
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.NoBorders.WithBorder Graphics.X11.Types.Window


-- | Some convenient common instances of the <a>Transformer</a> class, for
--   use with <a>XMonad.Layout.MultiToggle</a>.
module XMonad.Layout.MultiToggle.Instances
data StdTransformers

-- | switch to Full layout
FULL :: StdTransformers

-- | switch to Full with no borders
NBFULL :: StdTransformers

-- | Mirror the current layout.
MIRROR :: StdTransformers

-- | Remove borders.
NOBORDERS :: StdTransformers

-- | Apply smart borders.
SMARTBORDERS :: StdTransformers
instance GHC.Classes.Eq XMonad.Layout.MultiToggle.Instances.StdTransformers
instance GHC.Show.Show XMonad.Layout.MultiToggle.Instances.StdTransformers
instance GHC.Read.Read XMonad.Layout.MultiToggle.Instances.StdTransformers
instance XMonad.Layout.MultiToggle.Transformer XMonad.Layout.MultiToggle.Instances.StdTransformers Graphics.X11.Types.Window


-- | Implements a <tt>--replace</tt> behavior outside of core.
module XMonad.Util.Replace

-- | <tt>replace</tt> must be run before xmonad starts to signals to
--   compliant window managers that they must exit and let xmonad take
--   over.
replace :: IO ()


-- | This module provides several commands to run an external process.
--   Additionally, it provides an abstraction—particularly geared towards
--   programs like terminals or Emacs—to specify these processes from
--   XMonad in a compositional way.
--   
--   Originally, this module was composed of functions formerly defined in
--   <a>XMonad.Util.Dmenu</a> (by Spencer Janssen), <a>XMonad.Util.Dzen</a>
--   (by glasser@mit.edu) and <tt>XMonad.Util.RunInXTerm</tt> (by Andrea
--   Rossato).
module XMonad.Util.Run

-- | Returns the output.
runProcessWithInput :: MonadIO m => FilePath -> [String] -> String -> m String

-- | Wait is in μ (microseconds)
runProcessWithInputAndWait :: MonadIO m => FilePath -> [String] -> String -> Int -> m ()

-- | <a>safeSpawn</a> bypasses <a>spawn</a>, because spawn passes strings
--   to /bin/sh to be interpreted as shell commands. This is often what one
--   wants, but in many cases the passed string will contain shell
--   metacharacters which one does not want interpreted as such (URLs
--   particularly often have shell metacharacters like '&amp;' in them). In
--   this case, it is more useful to specify a file or program to be run
--   and a string to give it as an argument so as to bypass the shell and
--   be certain the program will receive the string as you typed it.
--   
--   Examples:
--   
--   <pre>
--   , ((modm, xK_Print), unsafeSpawn "import -window root $HOME/xwd-$(date +%s)$$.png")
--   , ((modm, xK_d    ), safeSpawn "firefox" [])
--   </pre>
--   
--   Note that the unsafeSpawn example must be unsafe and not safe because
--   it makes use of shell interpretation by relying on <tt>$HOME</tt> and
--   interpolation, whereas the safeSpawn example can be safe because
--   Firefox doesn't need any arguments if it is just being started.
safeSpawn :: MonadIO m => FilePath -> [String] -> m ()

-- | Simplified <a>safeSpawn</a>; only takes a program (and no arguments):
--   
--   <pre>
--   , ((modm, xK_d    ), safeSpawnProg "firefox")
--   </pre>
safeSpawnProg :: MonadIO m => FilePath -> m ()

-- | An alias for <a>spawn</a>; the name emphasizes that one is calling out
--   to a Turing-complete interpreter which may do things one dislikes; for
--   details, see <a>safeSpawn</a>.
unsafeSpawn :: MonadIO m => String -> m ()

-- | Open a terminal emulator. The terminal emulator is specified in the
--   default configuration as xterm by default. It is then asked to pass
--   the shell a command with certain options. This is unsafe in the sense
--   of <a>unsafeSpawn</a>
runInTerm :: String -> String -> X ()

-- | Run a given program in the preferred terminal emulator; see
--   <a>runInTerm</a>. This makes use of <a>safeSpawn</a>.
safeRunInTerm :: String -> String -> X ()

-- | Multiplies by ONE MILLION, for functions that take microseconds.
--   
--   Use like:
--   
--   <pre>
--   (5.5 `seconds`)
--   </pre>
--   
--   In GHC 7 and later, you must either enable the PostfixOperators
--   extension (by adding
--   
--   <pre>
--   {-# LANGUAGE PostfixOperators #-}
--   </pre>
--   
--   to the top of your file) or use seconds in prefix form:
--   
--   <pre>
--   seconds 5.5
--   </pre>
seconds :: Rational -> Int

-- | Launch an external application through the system shell and return a
--   <a>Handle</a> to its standard input. Note that the <a>Handle</a> is a
--   text <a>Handle</a> using the current locale encoding.
spawnPipe :: MonadIO m => String -> m Handle

-- | Same as <a>spawnPipe</a>.
spawnPipeWithLocaleEncoding :: MonadIO m => String -> m Handle

-- | Same as <a>spawnPipe</a>, but forces the UTF-8 encoding regardless of
--   locale.
spawnPipeWithUtf8Encoding :: MonadIO m => String -> m Handle

-- | Same as <a>spawnPipe</a>, but forces the <a>char8</a> encoding, so
--   unicode strings need <a>encodeString</a>. Should never be needed, but
--   some X functions return already encoded Strings, so it may possibly be
--   useful for someone.
spawnPipeWithNoEncoding :: MonadIO m => String -> m Handle

-- | Additional information that might be useful when spawning external
--   programs.
data ProcessConfig
ProcessConfig :: !String -> !FilePath -> !FilePath -> !String -> ProcessConfig

-- | Default editor. Defaults to <tt>"emacsclient -c -a ''"</tt>.
[editor] :: ProcessConfig -> !String

-- | Directory for your custom Emacs lisp files. Probably
--   <tt>user-emacs-directory</tt> or <tt>user-emacs-directory/lisp</tt>.
--   Defaults to <tt>"~/.config/emacs/lisp/"</tt>
[emacsLispDir] :: ProcessConfig -> !FilePath

-- | Directory for all packages from [M,Non-GNU]ELPA; probably
--   <tt>user-emacs-directory/elpa</tt>. Defaults to
--   <tt>"~/.config/emacs/elpa"</tt>.
[emacsElpaDir] :: ProcessConfig -> !FilePath

-- | <i>Standalone</i> Emacs executable; this should not be
--   <tt>emacsclient</tt> since, for example, the client does not support
--   <tt>--batch</tt> mode. Defaults to <tt>"emacs"</tt>.
[emacs] :: ProcessConfig -> !String

-- | Convenient type alias.
type Input = ShowS

-- | Given a <a>ProcessConfig</a>, remember it for spawning external
--   processes later on.
spawnExternalProcess :: ProcessConfig -> XConfig l -> XConfig l

-- | Spawn a completed input.
proc :: X Input -> X ()

-- | Get the completed input string.
getInput :: X Input -> X String

-- | Create an effectful <a>Input</a> from a <a>String</a>.
toInput :: String -> X Input

-- | Use the <a>editor</a>.
inEditor :: X Input

-- | Use the <a>terminal</a>.
inTerm :: X Input

-- | Spawn the <a>terminal</a> in some directory; it must support the
--   <tt>--working-directory</tt> option.
termInDir :: X Input

-- | Use the given program.
inProgram :: String -> X Input

-- | Combine inputs together.
(>->) :: X Input -> X Input -> X Input
infixr 3 >->

-- | Combine an input with an ordinary string.
(>-$) :: X Input -> X String -> X Input
infixr 3 >-$

-- | <tt>a &gt;&amp;&amp;&gt; b</tt> glues the different inputs <tt>a</tt>
--   and <tt>b</tt> by means of <tt>&amp;&amp;</tt>. For example,
--   
--   <pre>
--   pure "do something" &gt;&amp;&amp;&gt; pure "do another thing"
--   </pre>
--   
--   would result in <tt>do something &amp;&amp; do another thing</tt>
--   being executed by a shell.
(>&&>) :: X Input -> X Input -> X Input
infixr 2 >&&>

-- | Like <a>(&gt;&amp;&amp;&gt;)</a>, but with <tt>||</tt>.
(>||>) :: X Input -> X Input -> X Input
infixr 2 >||>

-- | Spawn <i>thing</i> in the current working directory. <i>thing</i> must
--   support a <tt>--working-directory</tt> option.
inWorkingDir :: X Input

-- | Eval(uate) the argument. Current <i>thing</i> must support a
--   <tt>--eval</tt> option.
eval :: String -> X Input

-- | Execute the argument. Current <i>thing</i> must support a <tt>-e</tt>
--   option. For programs such as Emacs, <a>eval</a> may be the safer
--   option; while <tt>emacsclient</tt> supports <tt>-e</tt>, the
--   <tt>emacs</tt> executable itself does not.
--   
--   Note that this function always wraps its argument in single quotes;
--   see <a>executeNoQuote</a> for an alternative.
execute :: String -> X Input

-- | Like <a>execute</a>, but doesn't wrap its argument in single quotes.
executeNoQuote :: String -> X Input

-- | Set the appropriate X class for a window. This will more often than
--   not actually be the <a>instance name</a>.
setXClass :: String -> X Input

-- | Treat an argument as a string; i.e., wrap it with quotes.
--   
--   <pre>
--   &gt;&gt;&gt; asString "string"
--   " \"string\" "
--   </pre>
asString :: String -> String

-- | An Emacs library.
data EmacsLib

-- | A <i>file</i> from <a>emacsLispDir</a>.
OwnFile :: !String -> EmacsLib

-- | A <i>directory</i> in <a>emacsElpaDir</a>.
ElpaLib :: !String -> EmacsLib

-- | Special <i>files</i>; these will not be looked up somewhere, but
--   forwarded verbatim (as a path).
Special :: !String -> EmacsLib

-- | Set a frame name for the <tt>emacsclient</tt>.
--   
--   Note that this uses the <tt>-F</tt> option to set the <a>frame
--   parameters</a> alist, which the <tt>emacs</tt> executable does not
--   support.
setFrameName :: String -> X Input

-- | Load some Emacs libraries. This is useful when executing scripts in
--   batch mode.
withEmacsLibs :: [EmacsLib] -> X Input

-- | Use <a>emacs</a>.
inEmacs :: X Input

-- | Transform the given input into an elisp function; i.e., surround it
--   with parentheses.
--   
--   <pre>
--   &gt;&gt;&gt; elispFun "arxiv-citation URL"
--   " '( arxiv-citation URL )' "
--   </pre>
elispFun :: String -> String

-- | Tell Emacs to enable batch-mode.
asBatch :: X Input

-- | Require a package.
--   
--   <pre>
--   &gt;&gt;&gt; require "arxiv-citation"
--   "(require (quote arxiv-citation))"
--   </pre>
require :: String -> String

-- | Wrap the given commands in a <tt>progn</tt>. The given commands need
--   not be wrapped in parentheses (but can); this will be done by the
--   function. For example:
--   
--   <pre>
--   &gt;&gt;&gt; progn [require "this-lib", "function-from-this-lib arg", "(other-function arg2)"]
--   "(progn (require (quote this-lib)) (function-from-this-lib arg) (other-function arg2))"
--   </pre>
progn :: [String] -> String

-- | Quote a symbol.
--   
--   <pre>
--   &gt;&gt;&gt; quote "new-process"
--   "(quote new-process)"
--   </pre>
quote :: String -> String

-- | Call <tt>find-file</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; findFile "/path/to/file"
--   "(find-file \"/path/to/file\" )"
--   </pre>
findFile :: String -> String

-- | Make a list of the given inputs.
--   
--   <pre>
--   &gt;&gt;&gt; list ["foo", "bar", "baz", "qux"]
--   "(list foo bar baz qux)"
--   </pre>
list :: [String] -> String

-- | Like <a>progn</a>, but with <tt>save-excursion</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; saveExcursion [require "this-lib", "function-from-this-lib arg", "(other-function arg2)"]
--   "(save-excursion (require (quote this-lib)) (function-from-this-lib arg) (other-function arg2))"
--   </pre>
saveExcursion :: [String] -> String

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()

-- | The same as <a>hPutStr</a>, but adds a newline character.
hPutStrLn :: Handle -> String -> IO ()
instance Data.Default.Class.Default XMonad.Util.Run.ProcessConfig


-- | Handy wrapper for dzen. Requires dzen &gt;= 0.2.4.
module XMonad.Util.Dzen

-- | <tt>dzenConfig config s</tt> will display the string <tt>s</tt>
--   according to the configuration <tt>config</tt>. For example, to
--   display the string <tt>"foobar"</tt> with all the default settings,
--   you can simply call
--   
--   <pre>
--   dzenConfig return "foobar"
--   </pre>
--   
--   Or, to set a longer timeout, you could use
--   
--   <pre>
--   dzenConfig (timeout 10) "foobar"
--   </pre>
--   
--   You can combine configurations with the (&gt;=&gt;) operator. To
--   display <tt>"foobar"</tt> for 10 seconds on the first screen, you
--   could use
--   
--   <pre>
--   dzenConfig (timeout 10 &gt;=&gt; xScreen 0) "foobar"
--   </pre>
--   
--   As a final example, you could adapt the above to display
--   <tt>"foobar"</tt> for 10 seconds on the current screen with
--   
--   <pre>
--   dzenConfig (timeout 10 &gt;=&gt; onCurr xScreen) "foobar"
--   </pre>
dzenConfig :: DzenConfig -> String -> X ()
type DzenConfig = (Int, [String]) -> X (Int, [String])

-- | Set the timeout, in seconds. This defaults to 3 seconds if not
--   specified.
timeout :: Rational -> DzenConfig

-- | Specify the font. Check out xfontsel to get the format of the String
--   right; if your dzen supports xft, then you can supply that here, too.
font :: String -> DzenConfig

-- | Start dzen2 on a particular screen. Only works with versions of dzen
--   that support the "-xs" argument.
xScreen :: ScreenId -> DzenConfig

-- | <tt>vCenter height sc</tt> sets the configuration to have the dzen bar
--   appear on screen <tt>sc</tt> with height <tt>height</tt>, vertically
--   centered with respect to the actual size of that screen.
vCenter :: Int -> ScreenId -> DzenConfig

-- | <tt>hCenter width sc</tt> sets the configuration to have the dzen bar
--   appear on screen <tt>sc</tt> with width <tt>width</tt>, horizontally
--   centered with respect to the actual size of that screen.
hCenter :: Int -> ScreenId -> DzenConfig

-- | <tt>center width height sc</tt> sets the configuration to have the
--   dzen bar appear on screen <tt>sc</tt> with width <tt>width</tt> and
--   height <tt>height</tt>, centered both horizontally and vertically with
--   respect to the actual size of that screen.
center :: Int -> Int -> ScreenId -> DzenConfig

-- | Take a screen-specific configuration and supply it with the screen ID
--   of the currently focused screen, according to xmonad. For example,
--   show a 100-pixel wide bar centered within the current screen, you
--   could use
--   
--   <pre>
--   dzenConfig (onCurr (hCenter 100)) "foobar"
--   </pre>
--   
--   Of course, you can still combine these with (&gt;=&gt;); for example,
--   to center the string <tt>"foobar"</tt> both horizontally and
--   vertically in a 100x14 box using the lovely Terminus font, you could
--   use
--   
--   <pre>
--   terminus = "-*-terminus-*-*-*-*-12-*-*-*-*-*-*-*"
--   dzenConfig (onCurr (center 100 14) &gt;=&gt; font terminus) "foobar"
--   </pre>
onCurr :: (ScreenId -> DzenConfig) -> DzenConfig

-- | Put the top of the dzen bar at a particular pixel.
x :: Int -> DzenConfig

-- | Put the left of the dzen bar at a particular pixel.
y :: Int -> DzenConfig

-- | Add raw command-line arguments to the configuration. These will be
--   passed on verbatim to dzen2. The default includes no arguments.
addArgs :: [String] -> DzenConfig

-- | Set the foreground color.
--   
--   Please be advised that <tt>fgColor</tt> and <tt>bgColor</tt> also
--   exist in <a>XMonad.Prompt</a>. If you use both modules, you might have
--   to tell the compiler which one you mean:
--   
--   <pre>
--   import XMonad.Prompt as P
--   import XMonad.Util.Dzen as D
--   
--   dzenConfig (D.fgColor "#f0f0f0") "foobar"
--   </pre>
fgColor :: String -> DzenConfig

-- | Set the background color.
bgColor :: String -> DzenConfig

-- | Set the alignment of the title (main) window content. Note that
--   <tt>AlignRightOffset</tt> is treated as equal to <tt>AlignRight</tt>.
--   
--   <pre>
--   import XMonad.Util.Font (Align(..))
--   
--   dzenConfig (align AlignLeft) "foobar"
--   </pre>
align :: Align -> DzenConfig

-- | Set the alignment of the slave window content. Using this option only
--   makes sense if you also use the <tt>lineCount</tt> parameter.
slaveAlign :: Align -> DzenConfig

-- | Enable slave window and specify the number of lines.
--   
--   Dzen can optionally draw a second window underneath the title window.
--   By default, this window is only displayed if the mouse enters the
--   title window. This option is only useful if the string you want to
--   display contains more than one line.
lineCount :: Int -> DzenConfig

-- | <tt>dzen str timeout</tt> pipes <tt>str</tt> to dzen2 for
--   <tt>timeout</tt> microseconds. Example usage:
--   
--   <pre>
--   dzen "Hi, mom!" (5 `seconds`)
--   </pre>
dzen :: String -> Int -> X ()

-- | <tt>dzenScreen sc str timeout</tt> pipes <tt>str</tt> to dzen2 for
--   <tt>timeout</tt> microseconds, and on screen <tt>sc</tt>. Requires
--   dzen to be compiled with Xinerama support.
dzenScreen :: ScreenId -> String -> Int -> X ()

-- | <tt>dzen str args timeout</tt> pipes <tt>str</tt> to dzen2 for
--   <tt>timeout</tt> seconds, passing <tt>args</tt> to dzen. Example
--   usage:
--   
--   <pre>
--   dzenWithArgs "Hi, dons!" ["-ta", "r"] (5 `seconds`)
--   </pre>
dzenWithArgs :: String -> [String] -> Int -> X ()

-- | Multiplies by ONE MILLION, for functions that take microseconds.
--   
--   Use like:
--   
--   <pre>
--   (5.5 `seconds`)
--   </pre>
--   
--   In GHC 7 and later, you must either enable the PostfixOperators
--   extension (by adding
--   
--   <pre>
--   {-# LANGUAGE PostfixOperators #-}
--   </pre>
--   
--   to the top of your file) or use seconds in prefix form:
--   
--   <pre>
--   seconds 5.5
--   </pre>
seconds :: Rational -> Int

-- | dzen wants exactly one newline at the end of its input, so this can be
--   used for your own invocations of dzen. However, all functions in this
--   module will call this for you.
chomp :: String -> String

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>


-- | A convenient binding to dmenu.
--   
--   Requires the process-1.0 package
module XMonad.Util.Dmenu

-- | Run dmenu to select an option from a list.
dmenu :: MonadIO m => [String] -> m String

-- | Starts dmenu on the current screen. Requires this patch to dmenu:
--   <a>http://www.jcreigh.com/dmenu/dmenu-3.2-xinerama.patch</a>
dmenuXinerama :: [String] -> X String

-- | Run dmenu to select an entry from a map based on the key.
dmenuMap :: MonadIO m => Map String a -> m (Maybe a)

-- | like <a>dmenu</a> but also takes the command to run.
menu :: MonadIO m => String -> [String] -> m String

-- | Like <a>menu</a> but also takes a list of command line arguments.
menuArgs :: MonadIO m => String -> [String] -> [String] -> m String

-- | Like <a>dmenuMap</a> but also takes the command to run.
menuMap :: MonadIO m => String -> Map String a -> m (Maybe a)

-- | Like <a>menuMap</a> but also takes a list of command line arguments.
menuMapArgs :: MonadIO m => String -> [String] -> Map String a -> m (Maybe a)


-- | Allows you to run internal xmonad commands (X () actions) using a
--   dmenu menu in addition to key bindings. Requires dmenu and the Dmenu
--   XMonad.Actions module.
module XMonad.Actions.Commands

-- | Create a <a>Map</a> from <tt>String</tt>s to xmonad actions from a
--   list of pairs.
commandMap :: [(String, X ())] -> Map String (X ())

-- | Given a list of command/action pairs, prompt the user to choose a
--   command using dmenu and return the corresponding action.
runCommand :: [(String, X ())] -> X ()

-- | Given a list of command/action pairs, prompt the user to choose a
--   command using dmenu-compatible launcher and return the corresponding
--   action. See X.U.Dmenu for compatible launchers.
runCommandConfig :: ([String] -> X String) -> [(String, X ())] -> X ()

-- | Given the name of a command from <a>defaultCommands</a>, return the
--   corresponding action (or the null action if the command is not found).
runCommand' :: String -> X ()

-- | Generate a list of commands to switch to/send windows to workspaces.
workspaceCommands :: X [(String, X ())]

-- | Generate a list of commands dealing with multiple screens.
screenCommands :: [(String, X ())]

-- | A nice pre-defined list of commands.
defaultCommands :: X [(String, X ())]


-- | This is an <tt>EventHook</tt> that will receive commands from an
--   external client. Also consider <a>XMonad.Hooks.EwmhDesktops</a>
--   together with <tt>wmctrl</tt>.
--   
--   See <tt>scripts/xmonadctl.hs</tt> for the client.
module XMonad.Hooks.ServerMode

-- | Executes a command of the list when receiving its index via a special
--   ClientMessageEvent (indexing starts at 1). Sending index 0 will ask
--   xmonad to print the list of command numbers in stderr (so that you can
--   read it in <tt>~/.xsession-errors</tt>). Uses
--   <a>XMonad.Actions.Commands#defaultCommands</a> as the default.
--   
--   <pre>
--   main = xmonad def { handleEventHook = serverModeEventHook }
--   </pre>
--   
--   <pre>
--   xmonadctl 0 # tells xmonad to output command list
--   xmonadctl 1 # tells xmonad to switch to workspace 1
--   </pre>
serverModeEventHook :: Event -> X All

-- | serverModeEventHook' additionally takes an action to generate the list
--   of commands.
serverModeEventHook' :: X [(String, X ())] -> Event -> X All

-- | Executes a command of the list when receiving its name via a special
--   ClientMessageEvent. Uses
--   <a>XMonad.Actions.Commands#defaultCommands</a> as the default.
--   
--   <pre>
--   main = xmonad def { handleEventHook = serverModeEventHookCmd }
--   </pre>
--   
--   <pre>
--   xmonadctl run # Tells xmonad to generate a run prompt
--   </pre>
serverModeEventHookCmd :: Event -> X All

-- | Additionally takes an action to generate the list of commands
serverModeEventHookCmd' :: X [(String, X ())] -> Event -> X All

-- | Listens for an atom, then executes a callback function whenever it
--   hears it. A trivial example that prints everything supplied to it on
--   xmonad's standard out:
--   
--   <pre>
--   main = xmonad def { handleEventHook = serverModeEventHookF "XMONAD_PRINT" (io . putStrLn) }
--   </pre>
--   
--   <pre>
--   xmonadctl -a XMONAD_PRINT "hello world"
--   </pre>
serverModeEventHookF :: String -> (String -> X ()) -> Event -> X All


-- | An example external contrib module for XMonad. Provides a simple
--   binding to dzen2 to print the date as a popup menu.
module XMonad.Actions.SimpleDate
date :: X ()


-- | This module has functions to navigate through workspaces in a
--   bidimensional manner. It allows the organization of workspaces in
--   lines, and provides functions to move and shift windows in all four
--   directions (left, up, right and down) possible in a surface.
--   
--   This functionality was inspired by GNOME (finite) and KDE (infinite)
--   keybindings for workspace navigation, and by
--   <a>XMonad.Actions.CycleWS</a> for the idea of applying this approach
--   to XMonad.
module XMonad.Actions.Plane

-- | Direction to go in the plane.
data Direction
ToLeft :: Direction
ToUp :: Direction
ToRight :: Direction
ToDown :: Direction

-- | Defines the behaviour when you're trying to move out of the limits.
data Limits

-- | Ignore the function call, and keep in the same workspace.
Finite :: Limits

-- | Get on the other side, like in the Snake game.
Circular :: Limits

-- | The plan comes as a row, so it goes to the next or prev if the
--   workspaces were numbered.
Linear :: Limits

-- | The number of lines in which the workspaces will be arranged. It's
--   possible to use a number of lines that is not a divisor of the number
--   of workspaces, but the results are better when using a divisor. If
--   it's not a divisor, the last line will have the remaining workspaces.
data Lines

-- | Use <tt>gconftool-2</tt> to find out the number of lines.
GConf :: Lines

-- | Specify the number of lines explicitly.
Lines :: Int -> Lines

-- | This is the way most people would like to use this module. It attaches
--   the <a>KeyMask</a> passed as a parameter with <a>xK_Left</a>,
--   <a>xK_Up</a>, <a>xK_Right</a> and <a>xK_Down</a>, associating it with
--   <a>planeMove</a> to the corresponding <a>Direction</a>. It also
--   associates these bindings with <a>shiftMask</a> to <a>planeShift</a>.
planeKeys :: KeyMask -> Lines -> Limits -> Map (KeyMask, KeySym) (X ())

-- | Shift a window to the next workspace in <a>Direction</a>. Note that
--   this will also move to the next workspace. It's a good idea to use the
--   same <a>Lines</a> and <a>Limits</a> for all the bindings.
planeShift :: Lines -> Limits -> Direction -> X ()

-- | Move to the next workspace in <a>Direction</a>.
planeMove :: Lines -> Limits -> Direction -> X ()
instance GHC.Enum.Enum XMonad.Actions.Plane.Direction
instance GHC.Classes.Eq XMonad.Actions.Plane.Limits


-- | A module for detectiong session startup. Useful to start status bars,
--   compositors and session initialization. This is a more general
--   approach than spawnOnce and allows spawnOn etc.
module XMonad.Util.SessionStart

-- | Use this to only do a part of your hook on session start
doOnce :: X () -> X ()

-- | Query if the current startup is the session start
isSessionStart :: X Bool

-- | This currently has to be added to the end of the startup hook to set
--   the flag.
setSessionStarted :: X ()
instance GHC.Show.Show XMonad.Util.SessionStart.SessionStart
instance GHC.Read.Read XMonad.Util.SessionStart.SessionStart
instance XMonad.Core.ExtensionClass XMonad.Util.SessionStart.SessionStart


-- | A module for spawning a pipe whose <a>Handle</a> lives in the Xmonad
--   state.
module XMonad.Util.SpawnNamedPipe

-- | When <a>spawnNamedPipe</a> is executed with a command <a>String</a>
--   and a name <a>String</a> respectively. The command string is spawned
--   with <a>spawnPipe</a> (as long as the name chosen hasn't been used
--   already) and the <a>Handle</a> returned is saved in Xmonad's state
--   associated with the name <a>String</a>.
spawnNamedPipe :: String -> String -> X ()

-- | Attempts to retrieve a <a>Handle</a> to a pipe previously stored in
--   Xmonad's state associated with the given string via a call to
--   <a>spawnNamedPipe</a>. If the given string doesn't exist in the map
--   stored in Xmonad's state Nothing is returned.
getNamedPipe :: String -> X (Maybe Handle)
instance GHC.Show.Show XMonad.Util.SpawnNamedPipe.NamedPipes
instance XMonad.Core.ExtensionClass XMonad.Util.SpawnNamedPipe.NamedPipes


-- | Utility functions for manipulating <tt>Maybe Stack</tt>s.
module XMonad.Util.Stack
type Zipper a = Maybe (Stack a)
emptyZ :: Zipper a
singletonZ :: a -> Zipper a

-- | Create a stack from a list, and the 0-based index of the focused
--   element. If the index is out of bounds, focus will go to the first
--   element.
fromIndex :: [a] -> Int -> Zipper a

-- | Turn a stack into a list and the index of its focused element.
toIndex :: Zipper a -> ([a], Maybe Int)

-- | Create a stack from a list of <a>Either</a>-tagged values. Focus will
--   go to the first <a>Right</a> value, or if there is none, to the first
--   <a>Left</a> one.
fromTags :: [Either a a] -> Zipper a

-- | Turn a stack into an <a>Either</a>-tagged list. The focused element
--   will be tagged with <a>Right</a>, the others with <a>Left</a>.
toTags :: Zipper a -> [Either a a]

-- | <tt>differentiate zs xs</tt> takes the first <tt>z</tt> from <tt>z2
--   that also belongs to </tt>xs<tt> and turns </tt>xs<tt> into a stack
--   with </tt>z<tt> being the current element. Acts as
--   <a>differentiate</a> if </tt>zs<tt> and </tt>xs@ don't intersect.
zipperFocusedAtFirstOf :: Eq q => [q] -> [q] -> Zipper q

-- | Insert an element before the focused one, and focus it
insertUpZ :: a -> Zipper a -> Zipper a

-- | Insert an element after the focused one, and focus it
insertDownZ :: a -> Zipper a -> Zipper a

-- | Swap the focused element with the previous one
swapUpZ :: Zipper a -> Zipper a

-- | Swap the focused element with the next one
swapDownZ :: Zipper a -> Zipper a

-- | Swap the focused element with the first one
swapMasterZ :: Zipper a -> Zipper a

-- | Move the focus to the previous element
focusUpZ :: Zipper a -> Zipper a

-- | Move the focus to the next element
focusDownZ :: Zipper a -> Zipper a

-- | Move the focus to the first element
focusMasterZ :: Zipper a -> Zipper a

-- | Refocus a <tt>Stack a</tt> on an element satisfying the predicate, or
--   fail to <tt>Nothing</tt>.
findS :: (a -> Bool) -> Stack a -> Maybe (Stack a)

-- | Refocus a <tt>Zipper a</tt> on an element satisfying the predicate, or
--   fail to <tt>Nothing</tt>.
findZ :: (a -> Bool) -> Zipper a -> Zipper a

-- | Get the focused element
getFocusZ :: Zipper a -> Maybe a

-- | Get the element at a given index
getIZ :: Int -> Zipper a -> Maybe a

-- | Sort a stack of elements supporting <a>Ord</a>
sortZ :: Ord a => Zipper a -> Zipper a

-- | Sort a stack with an arbitrary sorting function
sortByZ :: (a -> a -> Ordering) -> Zipper a -> Zipper a

-- | Map a function over a stack. The boolean argument indcates whether the
--   current element is the focused one
mapZ :: (Bool -> a -> b) -> Zipper a -> Zipper b

-- | <a>mapZ</a> without the <a>Bool</a> argument
mapZ_ :: (a -> b) -> Zipper a -> Zipper b

-- | Monadic version of <a>mapZ</a>
mapZM :: Monad m => (Bool -> a -> m b) -> Zipper a -> m (Zipper b)

-- | Monadic version of <a>mapZ_</a>
mapZM_ :: Monad m => (a -> m b) -> Zipper a -> m (Zipper b)

-- | Apply a function to the focused element
onFocusedZ :: (a -> a) -> Zipper a -> Zipper a

-- | Monadic version of <a>onFocusedZ</a>
onFocusedZM :: Monad m => (a -> m a) -> Zipper a -> m (Zipper a)

-- | Apply a function to the element at the given index
onIndexZ :: Int -> (a -> a) -> Zipper a -> Zipper a

-- | Monadic version of <a>onIndexZ</a>
onIndexZM :: Monad m => Int -> (a -> m a) -> Zipper a -> m (Zipper a)

-- | Fiter a stack according to a predicate. The refocusing behavior mimics
--   XMonad's usual one. The boolean argument indicates whether the current
--   element is the focused one.
filterZ :: (Bool -> a -> Bool) -> Zipper a -> Zipper a

-- | <a>filterZ</a> without the <a>Bool</a> argument
filterZ_ :: (a -> Bool) -> Zipper a -> Zipper a

-- | Delete the focused element
deleteFocusedZ :: Zipper a -> Zipper a

-- | Delete the ith element
deleteIndexZ :: Int -> Zipper a -> Zipper a

-- | Analogous to <a>foldr</a>. The <a>Bool</a> argument to the step
--   functions indicates whether the current element is the focused one
foldrZ :: (Bool -> a -> b -> b) -> b -> Zipper a -> b

-- | Analogous to <a>foldl</a>. The <a>Bool</a> argument to the step
--   functions indicates whether the current element is the focused one
foldlZ :: (Bool -> b -> a -> b) -> b -> Zipper a -> b

-- | <a>foldrZ</a> without the <a>Bool</a> argument.
foldrZ_ :: (a -> b -> b) -> b -> Zipper a -> b

-- | <a>foldlZ</a> without the <a>Bool</a> argument.
foldlZ_ :: (b -> a -> b) -> b -> Zipper a -> b

-- | Find whether an element is present in a stack.
elemZ :: Eq a => a -> Zipper a -> Bool

-- | Safe version of <a>!!</a>

-- | <i>Deprecated: Use XMonad.Prelude.(!?) instead.</i>
getI :: Int -> [a] -> Maybe a

-- | Tag the element with <a>Right</a> if the property is true, <a>Left</a>
--   otherwise
tagBy :: (a -> Bool) -> a -> Either a a

-- | Get the <tt>a</tt> from an <tt>Either a a</tt>
fromE :: Either a a -> a

-- | Map a function across both <a>Left</a>s and <a>Right</a>s. The
--   <a>Bool</a> argument is <a>True</a> in a <a>Right</a>, <a>False</a> in
--   a <a>Left</a>.
mapE :: (Bool -> a -> b) -> Either a a -> Either b b
mapE_ :: (a -> b) -> Either a a -> Either b b

-- | Monadic version of <a>mapE</a>
mapEM :: Monad m => (Bool -> a -> m b) -> Either a a -> m (Either b b)
mapEM_ :: Monad m => (a -> m b) -> Either a a -> m (Either b b)

-- | Reverse a <tt>Stack a</tt>; O(1).
reverseS :: Stack a -> Stack a

-- | Reverse a <tt>Zipper a</tt>; O(1).
reverseZ :: Zipper a -> Zipper a


-- | Row layout with individually resizable elements.
module XMonad.Layout.ZoomRow

-- | A layout that arranges its windows in a horizontal row, and allows to
--   change the relative size of each element independently.
data ZoomRow f a

-- | <a>ZoomRow</a> layout for laying out elements which are instances of
--   <a>Eq</a>. Perfect for <a>Window</a>s.
zoomRow :: (Eq a, Show a, Read a) => ZoomRow ClassEQ a

-- | The type of messages accepted by a <a>ZoomRow</a> layout
data ZoomMessage

-- | Multiply the focused window's size factor by the given number.
Zoom :: Rational -> ZoomMessage

-- | Set the focused window's size factor to the given number.
ZoomTo :: Rational -> ZoomMessage

-- | Set whether the focused window should occupy all available space when
--   it has focus
ZoomFull :: Bool -> ZoomMessage

-- | Toggle whether the focused window should occupy all available space
--   when it has focus
ZoomFullToggle :: ZoomMessage

-- | Increase the size of the focused window. Defined as <tt>Zoom 1.5</tt>
zoomIn :: ZoomMessage

-- | Decrease the size of the focused window. Defined as <tt>Zoom
--   (2/3)</tt>
zoomOut :: ZoomMessage

-- | Reset the size of the focused window. Defined as <tt>ZoomTo 1</tt>
zoomReset :: ZoomMessage

-- | ZoomRow layout with a custom equality predicate. It should of course
--   satisfy the laws for <a>Eq</a>, and you should also make sure that the
--   layout never has to handle two "equal" elements at the same time (it
--   won't do any huge damage, but might behave a bit strangely).
zoomRowWith :: (EQF f a, Show (f a), Read (f a), Show a, Read a) => f a -> ZoomRow f a

-- | Class for equivalence relations. Must be transitive, reflexive.
class EQF f a
eq :: EQF f a => f a -> a -> a -> Bool

-- | To use the usual <a>==</a>:
data ClassEQ a
ClassEQ :: ClassEQ a
instance GHC.Classes.Eq (XMonad.Layout.ZoomRow.ClassEQ a)
instance GHC.Read.Read (XMonad.Layout.ZoomRow.ClassEQ a)
instance GHC.Show.Show (XMonad.Layout.ZoomRow.ClassEQ a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (XMonad.Layout.ZoomRow.Elt a)
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Layout.ZoomRow.Elt a)
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.ZoomRow.Elt a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (f a)) => GHC.Classes.Eq (XMonad.Layout.ZoomRow.ZoomRow f a)
instance (GHC.Read.Read a, GHC.Read.Read (f a)) => GHC.Read.Read (XMonad.Layout.ZoomRow.ZoomRow f a)
instance (GHC.Show.Show a, GHC.Show.Show (f a)) => GHC.Show.Show (XMonad.Layout.ZoomRow.ZoomRow f a)
instance GHC.Show.Show XMonad.Layout.ZoomRow.ZoomMessage
instance XMonad.Core.Message XMonad.Layout.ZoomRow.ZoomMessage
instance (XMonad.Layout.ZoomRow.EQF f a, GHC.Show.Show a, GHC.Read.Read a, GHC.Show.Show (f a), GHC.Read.Read (f a), Data.Typeable.Internal.Typeable f) => XMonad.Core.LayoutClass (XMonad.Layout.ZoomRow.ZoomRow f) a
instance GHC.Classes.Eq a => XMonad.Layout.ZoomRow.EQF XMonad.Layout.ZoomRow.ClassEQ a


-- | Two-level layout with windows split in individual layout groups,
--   themselves managed by a user-provided layout.
module XMonad.Layout.Groups

-- | Create a <a>Groups</a> layout.
--   
--   Note that the second parameter (the layout for arranging the groups)
--   is not used on <tt>Windows</tt>, but on <a>Group</a>s. For this
--   reason, you can only use layouts that don't specifically need to
--   manage <a>Window</a>s. This is obvious, when you think about it.
group :: l Window -> l2 (Group l Window) -> Groups l l2 Window

-- | Messages accepted by <a>Groups</a>-based layouts. All other messages
--   are forwarded to the layout of the currently focused subgroup (as if
--   they had been wrapped in <a>ToFocused</a>).
data GroupsMessage

-- | Send a message to the enclosing layout (the one that places the groups
--   themselves)
ToEnclosing :: SomeMessage -> GroupsMessage

-- | Send a message to the layout for nth group (starting at 0)
ToGroup :: Int -> SomeMessage -> GroupsMessage

-- | Send a message to the layout for the focused group
ToFocused :: SomeMessage -> GroupsMessage

-- | Send a message to all the sub-layouts
ToAll :: SomeMessage -> GroupsMessage

-- | Refocus the window which should be focused according to the layout.
Refocus :: GroupsMessage

-- | Modify the ordering/grouping/focusing of windows according to a
--   <a>ModifySpec</a>
Modify :: ModifySpec -> GroupsMessage

-- | Same as <a>Modify</a>, but within the <a>X</a> monad
ModifyX :: ModifySpecX -> GroupsMessage

-- | Type of functions describing modifications to a <a>Groups</a> layout.
--   They are transformations on <a>Zipper</a>s of groups.
--   
--   Things you shouldn't do:
--   
--   <ul>
--   <li>Forge new windows (they will be ignored)</li>
--   <li>Duplicate windows (whatever happens is your problem)</li>
--   <li>Remove windows (they will be added again)</li>
--   <li>Duplicate layouts (only one will be kept, the rest will get the
--   base layout)</li>
--   </ul>
--   
--   Note that <a>ModifySpec</a> is a rank-2 type (indicating that
--   <a>ModifySpec</a>s must be polymorphic in the layout type), so if you
--   define functions taking <a>ModifySpec</a>s as arguments, or returning
--   them, you'll need to write a type signature and add <tt>{-# LANGUAGE
--   Rank2Types #-}</tt> at the beginning
type ModifySpec = forall l. WithID l Window -> Zipper (Group l Window) -> Zipper (Group l Window)

-- | This is the same as <a>ModifySpec</a>, but it allows the function to
--   use actions inside the <a>X</a> monad. This is useful, for example, if
--   the function has to make decisions based on the results of a
--   <a>runQuery</a>.
type ModifySpecX = forall l. WithID l Window -> Zipper (Group l Window) -> X (Zipper (Group l Window))

-- | Swap the focused window with the previous one.
swapUp :: ModifySpec

-- | Swap the focused window with the next one.
swapDown :: ModifySpec

-- | Swap the focused window with the (group's) master window.
swapMaster :: ModifySpec

-- | Move focus to the previous window in the group.
focusUp :: ModifySpec

-- | Move focus to the next window in the group.
focusDown :: ModifySpec

-- | Move focus to the group's master window.
focusMaster :: ModifySpec

-- | Swap the focused group with the previous one.
swapGroupUp :: ModifySpec

-- | Swap the focused group with the next one.
swapGroupDown :: ModifySpec

-- | Swap the focused group with the master group.
swapGroupMaster :: ModifySpec

-- | Move focus to the previous group.
focusGroupUp :: ModifySpec

-- | Move focus to the next group.
focusGroupDown :: ModifySpec

-- | Move focus to the master group.
focusGroupMaster :: ModifySpec

-- | Move the focused window to the previous group. If <a>True</a>, when in
--   the first group, wrap around to the last one. If <a>False</a>, create
--   a new group before it.
moveToGroupUp :: Bool -> ModifySpec

-- | Move the focused window to the next group. If <a>True</a>, when in the
--   last group, wrap around to the first one. If <a>False</a>, create a
--   new group after it.
moveToGroupDown :: Bool -> ModifySpec

-- | Move the focused window to a new group before the current one.
moveToNewGroupUp :: ModifySpec

-- | Move the focused window to a new group after the current one.
moveToNewGroupDown :: ModifySpec

-- | Split the focused group into two at the position of the focused window
--   (below it, unless it's the last window - in that case, above it).
splitGroup :: ModifySpec

-- | The type of our layouts.
data Groups l l2 a

-- | A group of windows and its layout algorithm.
data Group l a
G :: WithID l a -> Zipper a -> Group l a
[gLayout] :: Group l a -> WithID l a
[gZipper] :: Group l a -> Zipper a
onZipper :: (Zipper a -> Zipper a) -> Group l a -> Group l a
onLayout :: (WithID l a -> WithID l a) -> Group l a -> Group l a

-- | Split an infinite list into two. I ended up not needing this, but
--   let's keep it just in case. split :: [a] -&gt; ([a], [a]) split as =
--   snd $ foldr step (True, ([], [])) as where step a (True, (as1, as2)) =
--   (False, (a:as1, as2)) step a (False, (as1, as2)) = (True, (as1,
--   a:as2))
--   
--   Add a unique identity to a layout so we can follow it around.
data WithID l a

-- | Compare the ids of two <a>WithID</a> values
sameID :: WithID l a -> WithID l a -> Bool
instance GHC.Read.Read XMonad.Layout.Groups.Uniq
instance GHC.Show.Show XMonad.Layout.Groups.Uniq
instance GHC.Classes.Eq XMonad.Layout.Groups.Uniq
instance GHC.Read.Read (l a) => GHC.Read.Read (XMonad.Layout.Groups.WithID l a)
instance GHC.Show.Show (l a) => GHC.Show.Show (XMonad.Layout.Groups.WithID l a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (XMonad.Layout.Groups.Group l a)
instance (GHC.Read.Read a, GHC.Read.Read (l a)) => GHC.Read.Read (XMonad.Layout.Groups.Group l a)
instance (GHC.Show.Show a, GHC.Show.Show (l a)) => GHC.Show.Show (XMonad.Layout.Groups.Group l a)
instance (GHC.Show.Show a, GHC.Show.Show (l a), GHC.Show.Show (l2 (XMonad.Layout.Groups.Group l a))) => GHC.Show.Show (XMonad.Layout.Groups.Groups l l2 a)
instance (GHC.Read.Read a, GHC.Read.Read (l a), GHC.Read.Read (l2 (XMonad.Layout.Groups.Group l a))) => GHC.Read.Read (XMonad.Layout.Groups.Groups l l2 a)
instance GHC.Show.Show XMonad.Layout.Groups.GroupsMessage
instance XMonad.Core.Message XMonad.Layout.Groups.GroupsMessage
instance (XMonad.Core.LayoutClass l Graphics.X11.Types.Window, XMonad.Core.LayoutClass l2 (XMonad.Layout.Groups.Group l Graphics.X11.Types.Window)) => XMonad.Core.LayoutClass (XMonad.Layout.Groups.Groups l l2) Graphics.X11.Types.Window
instance GHC.Classes.Eq (XMonad.Layout.Groups.WithID l a)
instance XMonad.Core.LayoutClass l a => XMonad.Core.LayoutClass (XMonad.Layout.Groups.WithID l) a


-- | Utility functions for <a>XMonad.Layout.Groups</a>.
module XMonad.Layout.Groups.Helpers

-- | Swap the focused window with the previous one
swapUp :: X ()

-- | Swap the focused window with the next one
swapDown :: X ()

-- | Swap the focused window with the master window
swapMaster :: X ()

-- | If the focused window is floating, focus the next floating window.
--   otherwise, focus the next non-floating one.
focusUp :: X ()

-- | If the focused window is floating, focus the next floating window.
--   otherwise, focus the next non-floating one.
focusDown :: X ()

-- | Move focus to the master window
focusMaster :: X ()

-- | Move focus between the floating and non-floating layers
toggleFocusFloat :: X ()

-- | Swap the focused group with the previous one
swapGroupUp :: X ()

-- | Swap the focused group with the next one
swapGroupDown :: X ()

-- | Swap the focused group with the master group
swapGroupMaster :: X ()

-- | Move the focus to the previous group
focusGroupUp :: X ()

-- | Move the focus to the next group
focusGroupDown :: X ()

-- | Move the focus to the master group
focusGroupMaster :: X ()

-- | Move the focused window to the previous group. The <a>Bool</a>
--   argument determines what will be done if the focused window is in the
--   very first group: Wrap back to the end (<a>True</a>), or create a new
--   group before it (<a>False</a>).
moveToGroupUp :: Bool -> X ()

-- | Move the focused window to the next group. The <a>Bool</a> argument
--   determines what will be done if the focused window is in the very last
--   group: Wrap back to the beginning (<a>True</a>), or create a new group
--   after it (<a>False</a>).
moveToGroupDown :: Bool -> X ()

-- | Move the focused window to a new group before the current one
moveToNewGroupUp :: X ()

-- | Move the focused window to a new group after the current one
moveToNewGroupDown :: X ()

-- | Split the focused group in two at the position of the focused window.
splitGroup :: X ()


-- | FocusTracking simply holds onto the last true focus it was given and
--   continues to use it as the focus for the transformed layout until it
--   sees another. It can be used to improve the behaviour of a child
--   layout that has not been given the focused window, or equivalently,
--   that of the layout itself when a float has focus.
--   
--   Relevant issues:
--   
--   <ul>
--   <li><a>http://code.google.com/p/xmonad/issues/detail?id=4</a></li>
--   <li><a>http://code.google.com/p/xmonad/issues/detail?id=306</a></li>
--   
--   <li>-------------------------------------------------------------------------------</li>
--   </ul>
module XMonad.Layout.FocusTracking

-- | A <a>LayoutModifier</a> that remembers the last focus it saw.
newtype FocusTracking a
FocusTracking :: Maybe Window -> FocusTracking a

-- | Transform a layout into one that remembers and uses the last focus it
--   saw.
focusTracking :: l a -> ModifiedLayout FocusTracking l a
instance GHC.Show.Show (XMonad.Layout.FocusTracking.FocusTracking a)
instance GHC.Read.Read (XMonad.Layout.FocusTracking.FocusTracking a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.FocusTracking.FocusTracking Graphics.X11.Types.Window


-- | Provides layout modifier <a>UseTransientFor</a>: when a float has
--   focus and is <tt>WM_TRANSIENT_FOR</tt> a tile, run the underlying
--   layout as if that tile had focus.
module XMonad.Layout.TrackFloating

-- | Runs another layout with a remembered focus, provided:
--   
--   <ul>
--   <li>the subset of windows doesn't include the focus in XState</li>
--   <li>it was previously run with a subset that included the XState
--   focus</li>
--   <li>the remembered focus hasn't since been killed</li>
--   </ul>

-- | <i>Deprecated: Use X.L.FocusTracking.focusTracking.</i>
trackFloating :: l a -> ModifiedLayout TrackFloating l a

-- | When focus is on the tiled layer, the underlying layout is run with
--   focus on the window named by the WM_TRANSIENT_FOR property on the
--   floating window.
useTransientFor :: l a -> ModifiedLayout UseTransientFor l a

-- | <i>Deprecated: Use X.L.FocusTracking.FocusTracking.</i>
type TrackFloating = FocusTracking
data UseTransientFor a
instance GHC.Classes.Eq (XMonad.Layout.TrackFloating.UseTransientFor a)
instance GHC.Show.Show (XMonad.Layout.TrackFloating.UseTransientFor a)
instance GHC.Read.Read (XMonad.Layout.TrackFloating.UseTransientFor a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.TrackFloating.UseTransientFor Graphics.X11.Types.Window


-- | Provides StateFull: a stateful form of Full that does not misbehave
--   when floats are focused, and the FocusTracking layout transformer by
--   means of which StateFull is implemented. FocusTracking simply holds
--   onto the last true focus it was given and continues to use it as the
--   focus for the transformed layout until it sees another. It can be used
--   to improve the behaviour of a child layout that has not been given the
--   focused window.

-- | <i>Deprecated: Use X.L.TrackFloating.</i>
module XMonad.Layout.StateFull

-- | A pattern synonym for the primary use case of the
--   <tt>FocusTracking</tt> transformer; using <tt>Full</tt>.
pattern StateFull :: StateFull a

-- | A type synonym to match the <tt>StateFull</tt> pattern synonym.
type StateFull = FocusTracking Full

-- | The <tt>FocusTracking</tt> type for which the <tt>LayoutClass</tt>
--   instance is provided.
type FocusTracking = ModifiedLayout FocusTracking

-- | Transform a layout into one that remembers and uses the last focus it
--   saw.
focusTracking :: l a -> ModifiedLayout FocusTracking l a


-- | BoringWindows is an extension to allow windows to be marked boring
module XMonad.Layout.BoringWindows
boringWindows :: (LayoutClass l a, Eq a) => l a -> ModifiedLayout BoringWindows l a

-- | Mark windows that are not given rectangles as boring
boringAuto :: (LayoutClass l a, Eq a) => l a -> ModifiedLayout BoringWindows l a
markBoring :: X ()

-- | Mark current focused window boring for all layouts. This is useful in
--   combination with the <a>XMonad.Actions.CopyWindow</a> module.
markBoringEverywhere :: X ()
clearBoring :: X ()
focusUp :: X ()
focusDown :: X ()
focusMaster :: X ()
swapUp :: X ()
swapDown :: X ()
siftUp :: X ()
siftDown :: X ()

-- | UpdateBoring is sent before attempting to view another boring window,
--   so that layouts have a chance to mark boring windows.
data UpdateBoring
UpdateBoring :: UpdateBoring
data BoringMessage
Replace :: String -> [Window] -> BoringMessage
Merge :: String -> [Window] -> BoringMessage
data BoringWindows a
instance GHC.Show.Show XMonad.Layout.BoringWindows.BoringMessage
instance GHC.Read.Read XMonad.Layout.BoringWindows.BoringMessage
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Layout.BoringWindows.BoringWindows a)
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.BoringWindows.BoringWindows a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.BoringWindows.BoringWindows Graphics.X11.Types.Window
instance XMonad.Core.Message XMonad.Layout.BoringWindows.UpdateBoring
instance XMonad.Core.Message XMonad.Layout.BoringWindows.BoringMessage


-- | Makes it possible to minimize windows, temporarily removing them from
--   the layout until they are restored.
module XMonad.Layout.Minimize
data Minimize a
minimize :: l Window -> ModifiedLayout Minimize l Window
instance GHC.Show.Show (XMonad.Layout.Minimize.Minimize a)
instance GHC.Read.Read (XMonad.Layout.Minimize.Minimize a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Minimize.Minimize Graphics.X11.Types.Window


-- | Provides hooks and actions that keep track of recently focused windows
--   on a per workspace basis and automatically refocus the last window on
--   loss of the current (if appropriate as determined by user specified
--   criteria).
module XMonad.Hooks.RefocusLast

-- | A log hook recording the current workspace's most recently focused
--   windows into extensible state.
refocusLastLogHook :: X ()

-- | Records a workspace's recently focused windows into extensible state
--   upon relayout. Potentially a less wasteful alternative to
--   <tt>refocusLastLogHook</tt>, as it does not run on <tt>WM_NAME</tt>
--   <tt>propertyNotify</tt> events.
refocusLastLayoutHook :: l a -> ModifiedLayout RefocusLastLayoutHook l a

-- | Given a predicate on the event window determining whether or not to
--   act, construct an event hook that runs iff the core xmonad event
--   handler will unmanage the window, and which shifts focus to the last
--   focused window on the appropriate workspace if desired.
refocusLastWhen :: Query Bool -> Event -> X All

-- | Holds iff refocusing is toggled active.
refocusingIsActive :: Query Bool

-- | Holds iff the event window is a float.
isFloat :: Query Bool

-- | Toggle automatic refocusing at runtime. Has no effect unless the
--   <tt>refocusingIsActive</tt> predicate has been used.
toggleRefocusing :: X ()

-- | Refocuses the previously focused window; acts as a toggle. Is not
--   affected by <tt>toggleRefocusing</tt>.
toggleFocus :: X ()

-- | Swaps the current and previous windows of the current workspace. Is
--   not affected by <tt>toggleRefocusing</tt>.
swapWithLast :: X ()

-- | Given a target workspace and a predicate on its current window,
--   produce a <a>windows</a> suitable function that will refocus that
--   workspace appropriately. Allows you to hook refocusing into any action
--   you can run through <tt>windows</tt>. See the implementation of
--   <tt>shiftRLWhen</tt> for a straight-forward usage example.
refocusWhen :: Query Bool -> WorkspaceId -> X (WindowSet -> WindowSet)

-- | Sends the focused window to the specified workspace, refocusing the
--   last focused window if the predicate holds on the current window. Note
--   that the native version of this, <tt>windows . W.shift</tt>, has a
--   nice property that this does not: shifting a window to another
--   workspace then shifting it back preserves its place in the stack. Can
--   be used in a keybinding like e.g.
--   
--   <pre>
--   windows =&lt;&lt; shiftRLWhen refocusingIsActive "3"
--   </pre>
--   
--   or
--   
--   <pre>
--   (windows &lt;=&lt; shiftRLWhen refocusingIsActive) "3"
--   </pre>
--   
--   where <tt>&lt;=&lt;</tt> is imported from <a>Control.Monad</a>.
shiftRLWhen :: Query Bool -> WorkspaceId -> X (WindowSet -> WindowSet)

-- | Perform an update to the <a>RecentWins</a> for the specified
--   workspace. The RefocusLast log and layout hooks are both implemented
--   trivially in terms of this function. Only exported to aid
--   extensibility.
updateRecentsOn :: WorkspaceId -> X ()

-- | Data type holding onto the previous and current <tt>Window</tt>.
data RecentWins
Recent :: !Window -> !Window -> RecentWins
[previous] :: RecentWins -> !Window
[current] :: RecentWins -> !Window

-- | Newtype wrapper for a <tt>Map</tt> holding the <tt>RecentWins</tt> for
--   each workspace. Is an instance of <tt>ExtensionClass</tt> with
--   persistence of state.
newtype RecentsMap
RecentsMap :: Map WorkspaceId RecentWins -> RecentsMap

-- | A <a>LayoutModifier</a> that updates the <a>RecentWins</a> for a
--   workspace upon relayout.
data RefocusLastLayoutHook a
RefocusLastLayoutHook :: RefocusLastLayoutHook a

-- | A newtype on <tt>Bool</tt> to act as a universal toggle for
--   refocusing.
newtype RefocusLastToggle
RefocusLastToggle :: Bool -> RefocusLastToggle
[refocusing] :: RefocusLastToggle -> Bool

-- | Perform an X action dependent on successful lookup of the RecentWins
--   for the specified workspace, or return a default value.
withRecentsIn :: WorkspaceId -> a -> (Window -> Window -> X a) -> X a
instance GHC.Classes.Eq XMonad.Hooks.RefocusLast.RecentWins
instance GHC.Read.Read XMonad.Hooks.RefocusLast.RecentWins
instance GHC.Show.Show XMonad.Hooks.RefocusLast.RecentWins
instance GHC.Classes.Eq XMonad.Hooks.RefocusLast.RecentsMap
instance GHC.Read.Read XMonad.Hooks.RefocusLast.RecentsMap
instance GHC.Show.Show XMonad.Hooks.RefocusLast.RecentsMap
instance GHC.Read.Read (XMonad.Hooks.RefocusLast.RefocusLastLayoutHook a)
instance GHC.Show.Show (XMonad.Hooks.RefocusLast.RefocusLastLayoutHook a)
instance GHC.Classes.Eq XMonad.Hooks.RefocusLast.RefocusLastToggle
instance GHC.Read.Read XMonad.Hooks.RefocusLast.RefocusLastToggle
instance GHC.Show.Show XMonad.Hooks.RefocusLast.RefocusLastToggle
instance XMonad.Core.ExtensionClass XMonad.Hooks.RefocusLast.RefocusLastToggle
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Hooks.RefocusLast.RefocusLastLayoutHook a
instance XMonad.Core.ExtensionClass XMonad.Hooks.RefocusLast.RecentsMap


-- | Like <a>XMonad.Actions.Plane</a> for an arbitrary number of
--   dimensions.
module XMonad.Actions.WorkspaceCursors
focusDepth :: Cursors t -> Int

-- | makeCursors requires a nonempty string, and each sublist must be
--   nonempty
makeCursors :: [[String]] -> Cursors String

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]

-- | The state is stored in the <a>WorkspaceCursors</a> layout modifier.
--   Put this as your outermost modifier, unless you want different cursors
--   at different times (using <a>XMonad.Layout.MultiToggle</a>)
workspaceCursors :: Cursors String -> l a -> ModifiedLayout WorkspaceCursors l a
data WorkspaceCursors a
getFocus :: Cursors b -> b

-- | <tt>modifyLayer</tt> is used to change the focus at a given depth
modifyLayer :: (Stack (Cursors String) -> Stack (Cursors String)) -> Int -> X ()

-- | example usages are <a>shiftLayer</a> and <a>shiftModifyLayer</a>
modifyLayer' :: (Stack (Cursors String) -> X (Stack (Cursors String))) -> Int -> X ()

-- | <tt>shiftModifyLayer</tt> is the same as <a>modifyLayer</a>, but also
--   shifts the currently focused window to the new workspace
shiftModifyLayer :: (Stack (Cursors String) -> Stack (Cursors WorkspaceId)) -> Int -> X ()

-- | <tt>shiftLayer</tt> is the same as <a>shiftModifyLayer</a>, but the
--   focus remains on the current workspace.
shiftLayer :: (Stack (Cursors String) -> Stack (Cursors WorkspaceId)) -> Int -> X ()
focusNth' :: Int -> Stack a -> Stack a

-- | non-wrapping version of <a>focusUp'</a>
noWrapUp :: Stack t -> Stack t

-- | non-wrapping version of <a>focusDown'</a>
noWrapDown :: Stack t -> Stack t
data Cursors a
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Actions.WorkspaceCursors.Cursors a)
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Actions.WorkspaceCursors.Cursors a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (XMonad.Actions.WorkspaceCursors.Cursors a)
instance GHC.Show.Show (XMonad.Actions.WorkspaceCursors.WorkspaceCursors a)
instance GHC.Read.Read (XMonad.Actions.WorkspaceCursors.WorkspaceCursors a)
instance XMonad.Core.Message XMonad.Actions.WorkspaceCursors.ChangeCursors
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Actions.WorkspaceCursors.WorkspaceCursors a
instance Data.Foldable.Foldable XMonad.Actions.WorkspaceCursors.Cursors
instance GHC.Base.Functor XMonad.Actions.WorkspaceCursors.Cursors


-- | Functions for sifting windows up and down. Sifts behave identically to
--   swaps (i.e. <tt>swapUp</tt> and <tt>swapDown</tt> from
--   <a>XMonad.StackSet</a>), except in the wrapping case: rather than
--   rotating the entire stack by one position like a swap would, a sift
--   causes the windows at either end of the stack to trade positions.
module XMonad.Actions.Sift

-- | siftUp, siftDown. Exchange the focused window with its neighbour in
--   the stack ordering, wrapping if we reach the end. Unlike
--   <tt>swapUp</tt> and <tt>swapDown</tt>, wrapping is handled by trading
--   positions with the window at the other end of the stack.
siftUp :: StackSet i l a s sd -> StackSet i l a s sd

-- | siftUp, siftDown. Exchange the focused window with its neighbour in
--   the stack ordering, wrapping if we reach the end. Unlike
--   <tt>swapUp</tt> and <tt>swapDown</tt>, wrapping is handled by trading
--   positions with the window at the other end of the stack.
siftDown :: StackSet i l a s sd -> StackSet i l a s sd


-- | Functions for rotating some elements around the stack while keeping
--   others anchored in place. Useful in combination with layouts that
--   dictate window visibility based on stack position, such as
--   <a>XMonad.Layout.LimitWindows</a>.
module XMonad.Actions.RotateSome

-- | Treating the focused window and any unshown windows as a ring that can
--   be rotated through the focused position, surface the next element in
--   the ring.
surfaceNext :: X ()

-- | Like <a>surfaceNext</a> in reverse.
surfacePrev :: X ()

-- | <tt><a>rotateSome</a> p stack</tt> treats the elements of
--   <tt>stack</tt> that satisfy predicate <tt>p</tt> as a ring that can be
--   rotated, while all other elements remain anchored in place.
rotateSome :: (a -> Bool) -> Stack a -> Stack a


-- | Internal utility functions for storing Strings with the root window.
--   
--   Used for global state like IORefs with string keys, but more latency,
--   persistent between xmonad restarts.
module XMonad.Util.StringProp
type StringProp = String

-- | Get the name of a string property and returns it as a <a>Maybe</a>.
getStringProp :: MonadIO m => Display -> StringProp -> m (Maybe [Char])

-- | Set the value of a string property.
setStringProp :: MonadIO m => Display -> StringProp -> [Char] -> m ()

-- | Given a property name, returns its contents as a list. It uses the
--   empty list as default value.
getStringListProp :: MonadIO m => Display -> StringProp -> m [String]

-- | Given a property name and a list, sets the value of this property with
--   the list given as argument.
setStringListProp :: MonadIO m => Display -> StringProp -> [String] -> m ()


-- | A module for setting up timers
module XMonad.Util.Timer

-- | Start a timer, which will send a ClientMessageEvent after some time
--   (in seconds).
startTimer :: Rational -> X TimerId

-- | Given a <a>TimerId</a> and an <a>Event</a>, run an action when the
--   <a>Event</a> has been sent by the timer specified by the
--   <a>TimerId</a>
handleTimer :: TimerId -> Event -> X (Maybe a) -> X (Maybe a)
type TimerId = Int


-- | <a>Zipper</a> over the <a>Data.Tree</a> data structure. This module is
--   based on <a>rosezipper</a>.
module XMonad.Util.TreeZipper

-- | A <a>Zipper</a> over the <a>Data.Tree</a> data structure.
--   
--   Very crappy visualization of the <a>TreeZipper</a> data structure
--   
--   <pre>
--                (tz_parents)
--          ([*],       *, [*])
--          ([*, *],    *, [])
--          ([],        *                  [*,   *])
--                      |                   |    |
--     +-------+--------+-------+------+  +-*-+  *
--     |       |        |       |      |  |   |
--    (tz_before) (tz_current) (tz_after) *   *
--     |       |                |      |
--   +-*-+     *                *      *
--   |   |
--   *   *
--   </pre>
data TreeZipper a
TreeZipper :: Tree a -> Forest a -> Forest a -> [(Forest a, a, Forest a)] -> TreeZipper a

-- | the currently focused sub-tree under the cursor
[tz_current] :: TreeZipper a -> Tree a

-- | all sub-tree's to the <i>left</i> of the cursor that have the same
--   parent
[tz_before] :: TreeZipper a -> Forest a

-- | all sub-tree's to the <i>right</i> of the cursor that have the same
--   parent
[tz_after] :: TreeZipper a -> Forest a

-- | list zippers for each parent level, the first element is the current
--   parent
[tz_parents] :: TreeZipper a -> [(Forest a, a, Forest a)]

-- | Get the highlighted value
cursor :: TreeZipper a -> a

-- | Create a <a>TreeZipper</a> from a list of <a>Tree</a>s focused on the
--   first element
fromForest :: Forest a -> TreeZipper a

-- | Convert the entire zipper back to a <a>Forest</a>
toForest :: TreeZipper a -> Forest a

-- | Create a <a>Forest</a> from all the children of the current parent
getSubForest :: TreeZipper a -> Forest a

-- | Go to the upper most node such that nothing is before nor above the
--   cursor
rootNode :: TreeZipper a -> TreeZipper a

-- | Move to the parent node
parent :: TreeZipper a -> Maybe (TreeZipper a)

-- | Move the cursor one level down to the first node
children :: TreeZipper a -> Maybe (TreeZipper a)

-- | Go to the next child node
nextChild :: TreeZipper a -> Maybe (TreeZipper a)

-- | Go to the previous child node
previousChild :: TreeZipper a -> Maybe (TreeZipper a)

-- | How many nodes are above this one?
nodeDepth :: TreeZipper a -> Int

-- | How many nodes are before the cursor? (on the current level)
nodeIndex :: TreeZipper a -> Int

-- | follow a Path specified by the list of nodes
followPath :: Eq b => (a -> b) -> [b] -> TreeZipper a -> Maybe (TreeZipper a)

-- | go to the first node next to the cursor that matches
findChild :: (a -> Bool) -> TreeZipper a -> Maybe (TreeZipper a)

-- | Check whenther this is a leaf node
isLeaf :: TreeZipper a -> Bool

-- | Check whenther this is a leaf node
isRoot :: TreeZipper a -> Bool

-- | Check whenther this the last child
isLast :: TreeZipper a -> Bool

-- | Check whenther this the first child
isFirst :: TreeZipper a -> Bool


-- | TreeSelect displays your workspaces or actions in a Tree-like format.
--   You can select the desired workspace/action with the cursor or hjkl
--   keys.
--   
--   This module is fully configurable and very useful if you like to have
--   a lot of workspaces.
--   
--   Only the nodes up to the currently selected are displayed. This will
--   be configurable in the near future by changing <a>ts_hidechildren</a>
--   to <tt>False</tt>, this is not yet implemented.
--   
module XMonad.Actions.TreeSelect

-- | Select a workspace and execute a "view" function from
--   <a>XMonad.StackSet</a> on it.
treeselectWorkspace :: TSConfig WorkspaceId -> Forest String -> (WorkspaceId -> WindowSet -> WindowSet) -> X ()

-- | Convert the workspace-tree to a flat list of paths such that XMonad
--   can use them
--   
--   The Nodes will be separated by a dot ('.') character
toWorkspaces :: Forest String -> [WorkspaceId]

-- | Select from a Tree of <a>X</a> actions
--   
--   
--   Each of these actions have to be specified inside a <a>TSNode</a>
--   
--   Example
--   
--   <pre>
--   treeselectAction myTreeConf
--      [ Node (TSNode "Hello"    "displays hello"      (spawn "xmessage hello!")) []
--      , Node (TSNode "Shutdown" "Poweroff the system" (spawn "shutdown")) []
--      , Node (TSNode "Brightness" "Sets screen brightness using xbacklight" (return ()))
--          [ Node (TSNode "Bright" "FULL POWER!!"            (spawn "xbacklight -set 100")) []
--          , Node (TSNode "Normal" "Normal Brightness (50%)" (spawn "xbacklight -set 50"))  []
--          , Node (TSNode "Dim"    "Quite dark"              (spawn "xbacklight -set 10"))  []
--          ]
--      ]
--   </pre>
treeselectAction :: TSConfig (X a) -> Forest (TSNode (X a)) -> X ()
type Pixel = Word64

-- | Extensive configuration for displaying the tree.
--   
--   This class also has a <a>Default</a> instance
data TSConfig a
TSConfig :: Bool -> Pixel -> String -> (Pixel, Pixel) -> (Pixel, Pixel) -> (Pixel, Pixel) -> Pixel -> Int -> Int -> Int -> Int -> Int -> Map (KeyMask, KeySym) (TreeSelect a (Maybe a)) -> TSConfig a

-- | when enabled, only the parents (and their first children) of the
--   current node will be shown (This feature is not yet implemented!)
[ts_hidechildren] :: TSConfig a -> Bool

-- | background color filling the entire screen.
[ts_background] :: TSConfig a -> Pixel

-- | XMF font for drawing the node name extra text
[ts_font] :: TSConfig a -> String

-- | node foreground (text) and background color when not selected
[ts_node] :: TSConfig a -> (Pixel, Pixel)

-- | every other node will use this color instead of <a>ts_node</a>
[ts_nodealt] :: TSConfig a -> (Pixel, Pixel)

-- | node foreground (text) and background color when selected
[ts_highlight] :: TSConfig a -> (Pixel, Pixel)

-- | extra text color
[ts_extra] :: TSConfig a -> Pixel

-- | node width in pixels
[ts_node_width] :: TSConfig a -> Int

-- | node height in pixels
[ts_node_height] :: TSConfig a -> Int

-- | tree X position on the screen in pixels
[ts_originX] :: TSConfig a -> Int

-- | tree Y position on the screen in pixels
[ts_originY] :: TSConfig a -> Int

-- | indentation amount for each level in pixels
[ts_indent] :: TSConfig a -> Int

-- | key bindings for navigating the tree
[ts_navigate] :: TSConfig a -> Map (KeyMask, KeySym) (TreeSelect a (Maybe a))

-- | Default configuration.
--   
--   Using nice alternating blue nodes

-- | <i>Deprecated: Use def (from Data.Default, and re-exported by
--   XMonad.Actions.TreeSelect) instead.</i>
tsDefaultConfig :: TSConfig a

-- | The default value for this type.
def :: Default a => a

-- | Default navigation
--   
--   <ul>
--   <li>navigation using either arrow key or vi style hjkl</li>
--   <li>Return or Space to confirm</li>
--   <li>Escape or Backspace to cancel to</li>
--   </ul>
defaultNavigation :: Map (KeyMask, KeySym) (TreeSelect a (Maybe a))

-- | Quit returning the currently selected node
select :: TreeSelect a (Maybe a)

-- | Quit without returning anything
cancel :: TreeSelect a (Maybe a)

-- | Move the cursor to its parent node
moveParent :: TreeSelect a (Maybe a)

-- | Move the cursor one level down, highlighting its first child-node
moveChild :: TreeSelect a (Maybe a)

-- | Move the cursor to the next child-node
moveNext :: TreeSelect a (Maybe a)

-- | Move the cursor to the previous child-node
movePrev :: TreeSelect a (Maybe a)

-- | Move backwards in history
moveHistBack :: TreeSelect a (Maybe a)

-- | Move forward in history
moveHistForward :: TreeSelect a (Maybe a)

-- | Move to a specific node
moveTo :: [String] -> TreeSelect a (Maybe a)

-- | Tree Node With a name and extra text
data TSNode a
TSNode :: String -> String -> a -> TSNode a
[tsn_name] :: TSNode a -> String

-- | extra text, displayed next to the node name
[tsn_extra] :: TSNode a -> String

-- | value to return when this node is selected
[tsn_value] :: TSNode a -> a

-- | Run Treeselect with a given config and tree. This can be used for
--   selectiong anything
--   
--   <ul>
--   <li>for switching workspaces and moving windows use
--   <a>treeselectWorkspace</a></li>
--   <li>for selecting actions use <a>treeselectAction</a></li>
--   </ul>
treeselect :: TSConfig a -> Forest (TSNode a) -> X (Maybe a)

-- | Same as <a>treeselect</a> but ad a specific starting position
treeselectAt :: TSConfig a -> TreeZipper (TSNode a) -> [[String]] -> X (Maybe a)
instance Control.Monad.IO.Class.MonadIO (XMonad.Actions.TreeSelect.TreeSelect a)
instance Control.Monad.Reader.Class.MonadReader (XMonad.Actions.TreeSelect.TSConfig a) (XMonad.Actions.TreeSelect.TreeSelect a)
instance Control.Monad.State.Class.MonadState (XMonad.Actions.TreeSelect.TSState a) (XMonad.Actions.TreeSelect.TreeSelect a)
instance GHC.Base.Functor (XMonad.Actions.TreeSelect.TreeSelect a)
instance GHC.Base.Applicative (XMonad.Actions.TreeSelect.TreeSelect a)
instance GHC.Base.Monad (XMonad.Actions.TreeSelect.TreeSelect a)
instance Data.Default.Class.Default (XMonad.Actions.TreeSelect.TSConfig a)


-- | Miscellaneous commonly used types.
module XMonad.Util.Types

-- | One-dimensional directions:
data Direction1D
Next :: Direction1D
Prev :: Direction1D

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D
instance GHC.Show.Show XMonad.Util.Types.Direction1D
instance GHC.Read.Read XMonad.Util.Types.Direction1D
instance GHC.Classes.Eq XMonad.Util.Types.Direction1D
instance GHC.Enum.Bounded XMonad.Util.Types.Direction2D
instance GHC.Enum.Enum XMonad.Util.Types.Direction2D
instance GHC.Classes.Ord XMonad.Util.Types.Direction2D
instance GHC.Show.Show XMonad.Util.Types.Direction2D
instance GHC.Read.Read XMonad.Util.Types.Direction2D
instance GHC.Classes.Eq XMonad.Util.Types.Direction2D


-- | Create manually-sized gaps along edges of the screen which will not be
--   used for tiling, along with support for toggling gaps on and off.
--   
--   Note 1: For gaps/space around <i>windows</i> see
--   <a>XMonad.Layout.Spacing</a>.
--   
--   Note 2: <a>XMonad.Hooks.ManageDocks</a> is the preferred solution for
--   leaving space for your dock-type applications (status bars, toolbars,
--   docks, etc.), since it automatically sets up appropriate gaps, allows
--   them to be toggled, etc. However, this module may still be useful in
--   some situations where the automated approach of ManageDocks does not
--   work; for example, to work with a dock-type application that does not
--   properly set the STRUTS property, or to leave part of the screen blank
--   which is truncated by a projector, and so on.
module XMonad.Layout.Gaps

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D

-- | The gap state. The first component is the configuration (which gaps
--   are allowed, and their current size), the second is the gaps which are
--   currently active.
data Gaps a

-- | A manual gap configuration. Each side of the screen on which a gap is
--   enabled is paired with a size in pixels.
type GapSpec = [(Direction2D, Int)]

-- | Add togglable manual gaps to a layout.
gaps :: GapSpec -> l a -> ModifiedLayout Gaps l a

-- | Add togglable manual gaps to a layout, explicitly specifying the
--   initial states.
gaps' :: [((Direction2D, Int), Bool)] -> l a -> ModifiedLayout Gaps l a

-- | Messages which can be sent to a gap modifier.
data GapMessage

-- | Toggle all gaps.
ToggleGaps :: GapMessage

-- | Toggle a single gap.
ToggleGap :: !Direction2D -> GapMessage

-- | Increase a gap by a certain number of pixels.
IncGap :: !Int -> !Direction2D -> GapMessage

-- | Decrease a gap.
DecGap :: !Int -> !Direction2D -> GapMessage

-- | Modify arbitrarily.
ModifyGaps :: (GapSpec -> GapSpec) -> GapMessage

-- | Modifies gaps weakly, for convenience.
weakModifyGaps :: (Direction2D -> Int -> Int) -> GapMessage

-- | Arbitrarily modify a single gap with the given function.
modifyGap :: (Int -> Int) -> Direction2D -> GapMessage

-- | Set the GapSpec.
setGaps :: GapSpec -> GapMessage

-- | Set a gap to the given value.
setGap :: Int -> Direction2D -> GapMessage
instance GHC.Read.Read (XMonad.Layout.Gaps.Gaps a)
instance GHC.Show.Show (XMonad.Layout.Gaps.Gaps a)
instance XMonad.Core.Message XMonad.Layout.Gaps.GapMessage
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Gaps.Gaps a


-- | Three layouts: The first, <a>Spiral</a>, is a reimplementation of
--   <a>spiral</a> with, at least to me, more intuitive semantics. The
--   second, <a>Dwindle</a>, is inspired by a similar layout in awesome and
--   produces the same sequence of decreasing window sizes as Spiral but
--   pushes the smallest windows into a screen corner rather than the
--   centre. The third, <a>Squeeze</a> arranges all windows in one row or
--   in one column, with geometrically decreasing sizes.
module XMonad.Layout.Dwindle

-- | Layouts with geometrically decreasing window sizes. <a>Spiral</a> and
--   <a>Dwindle</a> split the screen into a rectangle for the first window
--   and a rectangle for the remaining windows, which is split recursively
--   to lay out these windows. Both layouts alternate between horizontal
--   and vertical splits.
--   
--   In each recursive step, the split <a>Direction2D</a> determines the
--   placement of the remaining windows relative to the current window: to
--   the left, to the right, above or below. The split direction of the
--   first split is determined by the first layout parameter. The split
--   direction of the second step is rotated 90 degrees relative to the
--   first split direction according to the second layout parameter of type
--   <a>Chirality</a>. So, if the first split is <a>R</a> and the second
--   layout parameter is <a>CW</a>, then the second split is
--   <a>Direction2D</a>.
--   
--   For the <a>Spiral</a> layout, the same <a>Chirality</a> is used for
--   computing the split direction of each step from the split direction of
--   the previous step. For example, parameters <a>R</a> and <a>CW</a>
--   produces the direction sequence <a>R</a>, <a>Direction2D</a>,
--   <a>L</a>, <a>U</a>, <a>R</a>, <a>Direction2D</a>, <a>L</a>, <a>U</a>,
--   ...
--   
--   For the <a>Dwindle</a> layout, the <a>Chirality</a> alternates between
--   <a>CW</a> and <a>CCW</a> in each step. For example, parameters
--   <a>U</a> and <a>CCW</a> produce the direction sequence <a>U</a>,
--   <a>L</a>, <a>U</a>, <a>L</a>, ... because <a>L</a> is the <a>CCW</a>
--   rotation of <a>U</a> and <a>U</a> is the <a>CW</a> rotation of
--   <a>L</a>.
--   
--   In each split, the current rectangle is split so that the ratio
--   between the size of the rectangle allocated to the current window and
--   the size of the rectangle allocated to the remaining windows is the
--   third layout parameter. This ratio can be altered using <a>Expand</a>
--   and <a>Shrink</a> messages. The former multiplies the ratio by the
--   fourth layout parameter. The latter divides the ratio by this
--   parameter.
--   
--   <a>Squeeze</a> does not alternate between horizontal and vertical
--   splits and simply splits in the direction given as its first argument.
--   
--   Parameters for both <a>Dwindle</a> and <a>Spiral</a>:
--   
--   <ul>
--   <li>First split direction</li>
--   <li>First split chirality</li>
--   <li>Size ratio between rectangle allocated to current window and
--   rectangle allocated to remaining windows</li>
--   <li>Factor by which the size ratio is changed in response to
--   <a>Expand</a> or <a>Shrink</a> messages</li>
--   </ul>
--   
--   The parameters for <a>Squeeze</a> are the same, except that there is
--   no <a>Chirality</a> parameter.
data Dwindle a
Dwindle :: !Direction2D -> !Chirality -> !Rational -> !Rational -> Dwindle a
Spiral :: !Direction2D -> !Chirality -> !Rational -> !Rational -> Dwindle a
Squeeze :: !Direction2D -> !Rational -> !Rational -> Dwindle a

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D

-- | Rotation between consecutive split directions
data Chirality
CW :: Chirality
CCW :: Chirality
instance GHC.Show.Show XMonad.Layout.Dwindle.Chirality
instance GHC.Read.Read XMonad.Layout.Dwindle.Chirality
instance GHC.Show.Show (XMonad.Layout.Dwindle.Dwindle a)
instance GHC.Read.Read (XMonad.Layout.Dwindle.Dwindle a)
instance XMonad.Core.LayoutClass XMonad.Layout.Dwindle.Dwindle a


-- | This is a rewrite of <a>XMonad.Layout.WindowNavigation</a>.
--   WindowNavigation lets you assign keys to move up/down/left/right,
--   based on actual cartesian window coordinates, rather than just going
--   j/k on the stack.
--   
--   This module is experimental. You'll have better luck with the
--   original.
--   
--   This module differs from the other in a few ways:
--   
--   <ol>
--   <li>You can go up/down/left/right across multiple screens.</li>
--   <li>It doesn't provide little border colors for your neighboring
--   windows.</li>
--   <li>It doesn't provide the 'Move' action, which seems to be related to
--   the XMonad.Layout.Combo extension.</li>
--   <li>It tries to be slightly smarter about tracking your current
--   position.</li>
--   <li>Configuration is different.</li>
--   </ol>
module XMonad.Actions.WindowNavigation
withWindowNavigation :: (KeySym, KeySym, KeySym, KeySym) -> XConfig l -> IO (XConfig l)
withWindowNavigationKeys :: [((KeyMask, KeySym), WNAction)] -> XConfig l -> IO (XConfig l)
data WNAction
WNGo :: Direction2D -> WNAction
WNSwap :: Direction2D -> WNAction

-- | Focus window in the given direction.
go :: IORef WNState -> Direction2D -> X ()

-- | Swap current window with the window in the given direction. Note:
--   doesn't work with floating windows (don't think it makes much sense to
--   swap floating windows).
swap :: IORef WNState -> Direction2D -> X ()

-- | Version of <a>go</a> not dependent on X monad (needed for testing).
goPure :: Monad x => Direction2D -> WNInput x -> x WNOutput

-- | Version of <a>swap</a> not dependent on X monad (needed for testing).
swapPure :: Monad x => Direction2D -> WNInput x -> x WNOutput

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D
type WNState = Map WorkspaceId Point


-- | Support for simple mouse gestures.
module XMonad.Actions.MouseGestures

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D

-- | <tt><a>mouseGestureH</a> moveHook endHook</tt> is a mouse button event
--   handler. It collects mouse movements, calling <tt>moveHook</tt> for
--   each update; when the button is released, it calls <tt>endHook</tt>.
mouseGestureH :: (Direction2D -> X ()) -> X () -> X ()

-- | A utility function on top of <a>mouseGestureH</a>. It uses a
--   <a>Map</a> to look up the mouse gesture, then executes the
--   corresponding action (if any).
mouseGesture :: Map [Direction2D] (Window -> X ()) -> Window -> X ()

-- | A callback generator for <a>mouseGestureH</a>. <a>mkCollect</a>
--   returns two callback functions for passing to <a>mouseGestureH</a>.
--   The move hook will collect mouse movements (and return the current
--   gesture as a list); the end hook will return a list of the completed
--   gesture, which you can access with <a>&gt;&gt;=</a>.
mkCollect :: (MonadIO m, MonadIO m') => m (Direction2D -> m' [Direction2D], m' [Direction2D])


-- | Move and resize floating windows.
module XMonad.Actions.FloatKeys

-- | <tt>keysMoveWindow (dx, dy)</tt> moves the window by <tt>dx</tt>
--   pixels to the right and <tt>dy</tt> pixels down.
keysMoveWindow :: ChangeDim -> Window -> X ()

-- | <tt>keysMoveWindowTo (x, y) (gx, gy)</tt> moves the window relative
--   point <tt>(gx, gy)</tt> to the point <tt>(x,y)</tt>, where
--   <tt>(gx,gy)</tt> gives a position relative to the window border, i.e.
--   <tt>gx = 0</tt> is the left border, <tt>gx = 1</tt> is the right
--   border, <tt>gy = 0</tt> is the top border, and <tt>gy = 1</tt> the
--   bottom border.
--   
--   For example, on a 1024x768 screen:
--   
--   <pre>
--   keysMoveWindowTo (512,384) (1%2, 1%2) -- center the window on screen
--   keysMoveWindowTo (1024,0) (1, 0)      -- put window in the top right corner
--   </pre>
keysMoveWindowTo :: P -> G -> Window -> X ()

-- | <tt>keysResizeWindow (dx, dy) (gx, gy)</tt> changes the width by
--   <tt>dx</tt> and the height by <tt>dy</tt>, leaving the window-relative
--   point <tt>(gx, gy)</tt> fixed.
--   
--   For example:
--   
--   <pre>
--   keysResizeWindow (10, 0) (0, 0)      -- make the window 10 pixels larger to the right
--   keysResizeWindow (10, 0) (0, 1%2)    -- does the same, unless sizeHints are applied
--   keysResizeWindow (10, 10) (1%2, 1%2) -- add 5 pixels on each side
--   keysResizeWindow (-10, -10) (0, 1)   -- shrink the window in direction of the bottom-left corner
--   </pre>
keysResizeWindow :: ChangeDim -> G -> Window -> X ()

-- | <tt>keysAbsResizeWindow (dx, dy) (ax, ay)</tt> changes the width by
--   <tt>dx</tt> and the height by <tt>dy</tt>, leaving the screen absolute
--   point <tt>(ax, ay)</tt> fixed.
--   
--   For example:
--   
--   <pre>
--   keysAbsResizeWindow (10, 10) (0, 0)   -- enlarge the window; if it is not in the top-left corner it will also be moved down and to the right.
--   </pre>
keysAbsResizeWindow :: ChangeDim -> D -> Window -> X ()

-- | <tt>directionMoveWindow delta dir win</tt> moves the window
--   <tt>win</tt> by <tt>delta</tt> pixels in direction <tt>dir</tt>.
directionMoveWindow :: Int -> Direction2D -> Window -> X ()

-- | <tt>directionResizeWindow delta dir win</tt> resizes the window
--   <tt>win</tt> by <tt>delta</tt> pixels in direction <tt>dir</tt>.
directionResizeWindow :: Int -> Direction2D -> Window -> X ()

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D
type P = (Position, Position)
type G = (Rational, Rational)
type ChangeDim = (Int, Int)


-- | Automatic placement of floating windows.
module XMonad.Hooks.Place

-- | Repositions the focused window according to a placement policy. Works
--   for both "real" floating windows and windows in a
--   <a>WindowArranger</a>-based layout.
placeFocused :: Placement -> X ()

-- | Hook to automatically place windows when they are created.
placeHook :: Placement -> ManageHook

-- | The type of placement policies
data Placement

-- | Try to place windows with as little overlap as possible
smart :: (Rational, Rational) -> Placement
simpleSmart :: Placement

-- | Place windows at a fixed position
fixed :: (Rational, Rational) -> Placement

-- | Place windows under the mouse
underMouse :: (Rational, Rational) -> Placement

-- | Apply the given placement policy, constraining the placed windows
--   inside the screen boundaries.
inBounds :: Placement -> Placement

-- | Same as <a>inBounds</a>, but allows specifying gaps along the screen's
--   edges
withGaps :: (Dimension, Dimension, Dimension, Dimension) -> Placement -> Placement

-- | Compute the new position of a window according to a placement policy.
purePlaceWindow :: Placement -> Rectangle -> [Rectangle] -> (Position, Position) -> Rectangle -> Rectangle
instance GHC.Classes.Eq XMonad.Hooks.Place.Placement
instance GHC.Read.Read XMonad.Hooks.Place.Placement
instance GHC.Show.Show XMonad.Hooks.Place.Placement
instance GHC.Classes.Eq a => GHC.Classes.Eq (XMonad.Hooks.Place.SmartRectangle a)
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Hooks.Place.SmartRectangle a)


-- | Allow releasing xmonad's keyboard grab

-- | <i>Deprecated: Use XMonad.Operations.unGrab instead</i>
module XMonad.Util.Ungrab

-- | Release XMonad's keyboard grab, so other grabbers can do their thing.
--   
--   Start a keyboard action with this if it is going to run something that
--   needs to do a keyboard, pointer, or server grab. For example,
--   
--   <pre>
--   , ((modm .|. controlMask, xK_p), unGrab &gt;&gt; spawn "scrot")
--   </pre>
--   
--   (Other examples are certain screen lockers and "gksu".) This avoids
--   needing to insert a pause/sleep before running the command.
--   
--   XMonad retains the keyboard grab during key actions because if they
--   use a submap, they need the keyboard to be grabbed, and if they had to
--   assert their own grab then the asynchronous nature of X11 allows race
--   conditions between XMonad, other clients, and the X server that would
--   cause keys to sometimes be "leaked" to the focused window.
unGrab :: X ()


-- | Functions for saving per-window data.
module XMonad.Util.WindowState

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Wrapper around <a>Query</a> with phantom type <tt>s</tt>, representing
--   state, saved in window.
newtype StateQuery s a
StateQuery :: Query a -> StateQuery s a
[getQuery] :: StateQuery s a -> Query a

-- | Apply <a>StateQuery</a> to <a>Window</a>.
runStateQuery :: StateQuery s a -> Window -> X a

-- | Lifted to <a>Query</a> version of <a>catchX</a>
catchQuery :: Query a -> Query (Maybe a)
instance GHC.Base.Functor (XMonad.Util.WindowState.StateQuery s)
instance GHC.Base.Applicative (XMonad.Util.WindowState.StateQuery s)
instance Control.Monad.IO.Class.MonadIO (XMonad.Util.WindowState.StateQuery s)
instance GHC.Base.Monad (XMonad.Util.WindowState.StateQuery s)
instance (GHC.Show.Show s, GHC.Read.Read s, Data.Typeable.Internal.Typeable s) => Control.Monad.State.Class.MonadState (GHC.Maybe.Maybe s) (XMonad.Util.WindowState.StateQuery s)


module XMonad.Util.WorkspaceCompare
type WorkspaceCompare = WorkspaceId -> WorkspaceId -> Ordering
type WorkspaceSort = [WindowSpace] -> [WindowSpace]

-- | Transforms a workspace list by filtering out the workspaces that
--   correspond to the given <tt>tag</tt>s. Intended for use with
--   <a>logHook</a>s (see <a>filterOutWsPP</a>) and
--   <a>XMonad.Hooks.EwmhDesktops</a> (see <a>addEwmhWorkspaceSort</a>).
filterOutWs :: [WorkspaceId] -> WorkspaceSort

-- | Lookup the index of a workspace id in the user's config, return
--   Nothing if that workspace does not exist in the config.
getWsIndex :: X (WorkspaceId -> Maybe Int)

-- | A comparison function for WorkspaceId, based on the index of the tags
--   in the user's config.
getWsCompare :: X WorkspaceCompare

-- | A simple comparison function that orders workspaces lexicographically
--   by tag.
getWsCompareByTag :: X WorkspaceCompare

-- | A comparison function like <a>getXineramaWsCompare</a>, but uses
--   physical locations for screens.
getXineramaPhysicalWsCompare :: ScreenComparator -> X WorkspaceCompare

-- | A comparison function for Xinerama based on visibility, workspace and
--   screen id. It produces the same ordering as
--   <a>pprWindowSetXinerama</a>.
getXineramaWsCompare :: X WorkspaceCompare

-- | Create a workspace sorting function from a workspace comparison
--   function.
mkWsSort :: X WorkspaceCompare -> X WorkspaceSort

-- | Sort several workspaces according to their tags' indices in the user's
--   config.
getSortByIndex :: X WorkspaceSort

-- | Sort workspaces lexicographically by tag.
getSortByTag :: X WorkspaceSort

-- | Like <a>getSortByXineramaRule</a>, but allow you to use physical
--   locations for screens.
getSortByXineramaPhysicalRule :: ScreenComparator -> X WorkspaceSort

-- | Sort serveral workspaces for xinerama displays, in the same order
--   produced by <a>pprWindowSetXinerama</a>: first visible workspaces,
--   sorted by screen, then hidden workspaces, sorted by tag.
getSortByXineramaRule :: X WorkspaceSort


-- | Provides bindings to cycle forward or backward through the list of
--   workspaces, to move windows between workspaces, and to cycle between
--   screens. More general combinators provide ways to cycle through
--   workspaces in various orders, to only cycle through some subset of
--   workspaces, and to cycle by more than one workspace at a time.
--   
--   Note that this module now subsumes the functionality of the former
--   <tt>XMonad.Actions.RotView</tt>. Former users of <tt>rotView</tt> can
--   simply replace <tt>rotView True</tt> with <tt>moveTo Next (Not
--   emptyWS)</tt>, and so on.
--   
--   If you want to exactly replicate the action of <tt>rotView</tt>
--   (cycling through workspace in order lexicographically by tag, instead
--   of in the order specified in the config), it can be implemented as:
--   
--   <pre>
--   rotView b  = do t &lt;- findWorkspace getSortByTag (bToDir b) (Not emptyWS) 1
--                   windows . greedyView $ t
--     where bToDir True  = Next
--           bToDir False = Prev
--   </pre>
module XMonad.Actions.CycleWS

-- | Switch to the next workspace.
nextWS :: X ()

-- | Switch to the previous workspace.
prevWS :: X ()

-- | Move the focused window to the next workspace.
shiftToNext :: X ()

-- | Move the focused window to the previous workspace.
shiftToPrev :: X ()

-- | Toggle to the workspace displayed previously.
toggleWS :: X ()

-- | Toggle to the previous workspace while excluding some workspaces.
--   
--   <pre>
--   -- Ignore the scratchpad workspace while toggling:
--   ("M-b", toggleWS' ["NSP"])
--   </pre>
toggleWS' :: [WorkspaceId] -> X ()

-- | <a>greedyView</a> a workspace, or if already there, view the
--   previously displayed workspace ala weechat. Change <tt>greedyView</tt>
--   to <tt>toggleOrView</tt> in your workspace bindings as in the
--   <a>view</a> faq at
--   <a>http://haskell.org/haskellwiki/Xmonad/Frequently_asked_questions</a>.
--   For more flexibility see <a>toggleOrDoSkip</a>.
toggleOrView :: WorkspaceId -> X ()

-- | View next screen
nextScreen :: X ()

-- | View prev screen
prevScreen :: X ()

-- | Move focused window to workspace on next screen
shiftNextScreen :: X ()

-- | Move focused window to workspace on prev screen
shiftPrevScreen :: X ()

-- | Swap current screen with next screen
swapNextScreen :: X ()

-- | Swap current screen with previous screen
swapPrevScreen :: X ()

-- | One-dimensional directions:
data Direction1D
Next :: Direction1D
Prev :: Direction1D

-- | What type of workspaces should be included in the cycle?
data WSType

-- | cycle through empty workspaces

-- | <i>Deprecated: Use emptyWS instead.</i>
EmptyWS :: WSType

-- | cycle through non-empty workspaces

-- | <i>Deprecated: Use Not emptyWS instead.</i>
NonEmptyWS :: WSType

-- | cycle through non-visible workspaces

-- | <i>Deprecated: Use hiddenWS instead.</i>
HiddenWS :: WSType

-- | cycle through non-empty non-visible workspaces

-- | <i>Deprecated: Use hiddenWS :&amp;: Not emptyWS instead.</i>
HiddenNonEmptyWS :: WSType

-- | cycle through empty non-visible workspaces

-- | <i>Deprecated: Use hiddenWS :&amp;: emptyWS instead.</i>
HiddenEmptyWS :: WSType

-- | cycle through all workspaces

-- | <i>Deprecated: Use anyWS instead.</i>
AnyWS :: WSType

-- | cycle through workspaces in the same group, the group name is all
--   characters up to the first separator character or the end of the tag

-- | <i>Deprecated: Use wsTagGroup instead.</i>
WSTagGroup :: Char -> WSType

-- | cycle through workspaces satisfying an arbitrary predicate
WSIs :: X (WindowSpace -> Bool) -> WSType

-- | cycle through workspaces satisfying both predicates.
(:&:) :: WSType -> WSType -> WSType

-- | cycle through workspaces satisfying one of the predicates.
(:|:) :: WSType -> WSType -> WSType

-- | cycle through workspaces not satisfying the predicate
Not :: WSType -> WSType

-- | Cycle through empty workspaces
emptyWS :: WSType

-- | Cycle through non-visible workspaces
hiddenWS :: WSType

-- | Cycle through all workspaces
anyWS :: WSType

-- | Cycle through workspaces in the same group, the group name is all
--   characters up to the first separator character or the end of the tag
wsTagGroup :: Char -> WSType

-- | Cycle through workspaces that are not in the given list. This could,
--   for example, be used for skipping the workspace reserved for
--   <a>XMonad.Util.NamedScratchpad</a>:
--   
--   <pre>
--   moveTo Next $ hiddenWS :&amp;: Not emptyWS :&amp;: ignoringWSs [scratchpadWorkspaceTag]
--   </pre>
ignoringWSs :: [WorkspaceId] -> WSType

-- | Move the currently focused window to the next workspace in the given
--   direction that satisfies the given condition.
shiftTo :: Direction1D -> WSType -> X ()

-- | View the next workspace in the given direction that satisfies the
--   given condition.
moveTo :: Direction1D -> WSType -> X ()

-- | Using the given sort, find the next workspace in the given direction
--   of the given type, and perform the given action on it.
doTo :: Direction1D -> WSType -> X WorkspaceSort -> (WorkspaceId -> X ()) -> X ()

-- | Given a function <tt>s</tt> to sort workspaces, a direction
--   <tt>dir</tt>, a predicate <tt>p</tt> on workspaces, and an integer
--   <tt>n</tt>, find the tag of the workspace which is <tt>n</tt> away
--   from the current workspace in direction <tt>dir</tt> (wrapping around
--   if necessary), among those workspaces, sorted by <tt>s</tt>, which
--   satisfy <tt>p</tt>.
--   
--   For some useful workspace sorting functions, see
--   <a>XMonad.Util.WorkspaceCompare</a>.
--   
--   For ideas of what to do with a workspace tag once obtained, note that
--   <a>moveTo</a> and <a>shiftTo</a> are implemented by applying
--   <tt>(&gt;&gt;= (windows . greedyView))</tt> and <tt>(&gt;&gt;=
--   (windows . shift))</tt>, respectively, to the output of
--   <a>findWorkspace</a>.
findWorkspace :: X WorkspaceSort -> Direction1D -> WSType -> Int -> X WorkspaceId

-- | Allows ignoring listed workspace tags (such as scratchpad's "NSP"),
--   and running other actions such as view, shift, etc. For example:
--   
--   <pre>
--   import qualified XMonad.StackSet as W
--   import XMonad.Actions.CycleWS
--   
--   -- toggleOrView for people who prefer view to greedyView
--   toggleOrView' = toggleOrDoSkip [] W.view
--   
--   -- toggleOrView ignoring scratchpad and named scratchpad workspace
--   toggleOrViewNoSP = toggleOrDoSkip ["NSP"] W.greedyView
--   </pre>
toggleOrDoSkip :: [WorkspaceId] -> (WorkspaceId -> WindowSet -> WindowSet) -> WorkspaceId -> X ()

-- | List difference (<tt>\\</tt>) for workspaces and tags. Removes
--   workspaces matching listed tags from the given workspace list.
skipTags :: Eq i => [Workspace i l a] -> [i] -> [Workspace i l a]

-- | Get the <a>ScreenId</a> <i>d</i> places over. Example usage is a
--   variation of the the default screen keybindings:
--   
--   <pre>
--   -- mod-{w,e}, Switch to previous/next Xinerama screen
--   -- mod-shift-{w,e}, Move client to previous/next Xinerama screen
--   --
--   [((m .|. modm, key), sc &gt;&gt;= screenWorkspace &gt;&gt;= flip whenJust (windows . f))
--       | (key, sc) &lt;- zip [xK_w, xK_e] [(screenBy (-1)),(screenBy 1)]
--       , (f, m) &lt;- [(W.view, 0), (W.shift, shiftMask)]]
--   </pre>
screenBy :: Int -> X ScreenId


-- | Lets you swap workspace tags, so you can keep related ones next to
--   each other, without having to move individual windows.
module XMonad.Actions.SwapWorkspaces

-- | Swaps the currently focused workspace with the given workspace tag,
--   via <tt>swapWorkspaces</tt>.
swapWithCurrent :: Eq i => i -> StackSet i l a s sd -> StackSet i l a s sd

-- | Say <tt>swapTo Next</tt> or <tt>swapTo Prev</tt> to move your current
--   workspace. This is an <tt>X ()</tt> so can be hooked up to your
--   keybindings directly.
swapTo :: Direction1D -> X ()

-- | Takes two workspace tags and an existing XMonad.StackSet and returns a
--   new one with the two corresponding workspaces' tags swapped.
swapWorkspaces :: Eq i => i -> i -> StackSet i l a s sd -> StackSet i l a s sd

-- | One-dimensional directions:
data Direction1D
Next :: Direction1D
Prev :: Direction1D


-- | Remember a dynamically updateable ordering on workspaces, together
--   with tools for using this ordering with <a>XMonad.Actions.CycleWS</a>
--   and <a>XMonad.Hooks.StatusBar.PP</a>.
module XMonad.Actions.DynamicWorkspaceOrder

-- | A comparison function which orders workspaces according to the stored
--   dynamic ordering.
getWsCompareByOrder :: X WorkspaceCompare

-- | Sort workspaces according to the stored dynamic ordering.
getSortByOrder :: X WorkspaceSort

-- | Swap the current workspace with another workspace in the stored
--   dynamic order.
swapWith :: Direction1D -> WSType -> X ()

-- | Swap the given workspace with the current one.
swapWithCurrent :: WorkspaceId -> X ()

-- | Swap the two given workspaces in the dynamic order.
swapOrder :: WorkspaceId -> WorkspaceId -> X ()

-- | Update the name of a workspace in the stored order.
updateName :: WorkspaceId -> WorkspaceId -> X ()

-- | Remove a workspace from the stored order.
removeName :: WorkspaceId -> X ()

-- | View the next workspace of the given type in the given direction,
--   where "next" is determined using the dynamic workspace order.
moveTo :: Direction1D -> WSType -> X ()

-- | Same as <a>moveTo</a>, but using <tt>greedyView</tt> instead of
--   <tt>view</tt>.
moveToGreedy :: Direction1D -> WSType -> X ()

-- | Shift the currently focused window to the next workspace of the given
--   type in the given direction, using the dynamic workspace order.
shiftTo :: Direction1D -> WSType -> X ()

-- | Do something with the nth workspace in the dynamic order after
--   transforming it. The callback is given the workspace's tag as well as
--   the <a>WindowSet</a> of the workspace itself.
withNthWorkspace' :: ([WorkspaceId] -> [WorkspaceId]) -> (String -> WindowSet -> WindowSet) -> Int -> X ()

-- | Do something with the nth workspace in the dynamic order. The callback
--   is given the workspace's tag as well as the <a>WindowSet</a> of the
--   workspace itself.
withNthWorkspace :: (String -> WindowSet -> WindowSet) -> Int -> X ()
instance GHC.Show.Show XMonad.Actions.DynamicWorkspaceOrder.WSOrderStorage
instance GHC.Read.Read XMonad.Actions.DynamicWorkspaceOrder.WSOrderStorage
instance XMonad.Core.ExtensionClass XMonad.Actions.DynamicWorkspaceOrder.WSOrderStorage


-- | A module for accessing and manipulating X Window's mouse selection
--   (the buffer used in copy and pasting). <a>getSelection</a> is an
--   adaptation of Hxsel.hs and Hxput.hs from the XMonad-utils, available:
--   
--   <pre>
--   $ darcs get &lt;http://gorgias.mine.nu/repos/xmonad-utils&gt;
--   </pre>
module XMonad.Util.XSelection

-- | Returns a String corresponding to the current mouse selection in X; if
--   there is none, an empty string is returned.
--   
--   WARNING: this function is fundamentally implemented incorrectly and
--   may, among other possible failure modes, deadlock or crash. For
--   details, see
--   <a>http://code.google.com/p/xmonad/issues/detail?id=573</a>. (These
--   errors are generally very rare in practice, but still exist.)
getSelection :: MonadIO m => m String

-- | A wrapper around <a>getSelection</a>. Makes it convenient to run a
--   program with the current selection as an argument. This is convenient
--   for handling URLs, in particular. For example, in your Config.hs you
--   could bind a key to <tt>promptSelection "firefox"</tt>; this would
--   allow you to highlight a URL string and then immediately open it up in
--   Firefox.
--   
--   <a>promptSelection</a> passes strings through the system shell,
--   /bin/sh; if you do not wish your selected text to be interpreted or
--   mangled by the shell, use <a>safePromptSelection</a>.
--   safePromptSelection will bypass the shell using <a>safeSpawn</a> from
--   <a>XMonad.Util.Run</a>; see its documentation for more details on the
--   advantages and disadvantages of using safeSpawn.
promptSelection :: String -> X ()

-- | A wrapper around <a>getSelection</a>. Makes it convenient to run a
--   program with the current selection as an argument. This is convenient
--   for handling URLs, in particular. For example, in your Config.hs you
--   could bind a key to <tt>promptSelection "firefox"</tt>; this would
--   allow you to highlight a URL string and then immediately open it up in
--   Firefox.
--   
--   <a>promptSelection</a> passes strings through the system shell,
--   /bin/sh; if you do not wish your selected text to be interpreted or
--   mangled by the shell, use <a>safePromptSelection</a>.
--   safePromptSelection will bypass the shell using <a>safeSpawn</a> from
--   <a>XMonad.Util.Run</a>; see its documentation for more details on the
--   advantages and disadvantages of using safeSpawn.
safePromptSelection :: String -> X ()

-- | A wrapper around <a>promptSelection</a> and its safe variant. They
--   take two parameters, the first is a function that transforms strings,
--   and the second is the application to run. The transformer essentially
--   transforms the selection in X. One example is to wrap code, such as a
--   command line action copied out of the browser to be run as <tt>"sudo"
--   ++ cmd</tt> or <tt>"su - -c ""++ cmd ++"""</tt>.
transformPromptSelection :: (String -> String) -> String -> X ()

-- | A wrapper around <a>promptSelection</a> and its safe variant. They
--   take two parameters, the first is a function that transforms strings,
--   and the second is the application to run. The transformer essentially
--   transforms the selection in X. One example is to wrap code, such as a
--   command line action copied out of the browser to be run as <tt>"sudo"
--   ++ cmd</tt> or <tt>"su - -c ""++ cmd ++"""</tt>.
transformSafePromptSelection :: (String -> String) -> String -> X ()


-- | A module for writing graphical prompts for XMonad
module XMonad.Prompt

-- | Creates a prompt given:
--   
--   <ul>
--   <li>a prompt type, instance of the <a>XPrompt</a> class.</li>
--   <li>a prompt configuration (<a>def</a> can be used as a starting
--   point)</li>
--   <li>a completion function (<a>mkComplFunFromList</a> can be used to
--   create a completions function given a list of possible
--   completions)</li>
--   <li>an action to be run: the action must take a string and return
--   <a>X</a> ()</li>
--   </ul>
mkXPrompt :: XPrompt p => p -> XPConfig -> ComplFunction -> (String -> X ()) -> X ()

-- | Same as <a>mkXPrompt</a>, except that the action function can have
--   type <tt>String -&gt; X a</tt>, for any <tt>a</tt>, and the final
--   action returned by <a>mkXPromptWithReturn</a> will have type <tt>X
--   (Maybe a)</tt>. <tt>Nothing</tt> is yielded if the user cancels the
--   prompt (by e.g. hitting Esc or Ctrl-G). For an example of use, see the
--   <a>Input</a> module.
mkXPromptWithReturn :: XPrompt p => p -> XPConfig -> ComplFunction -> (String -> X a) -> X (Maybe a)

-- | Creates a prompt with multiple modes given:
--   
--   <ul>
--   <li>A non-empty list of modes</li>
--   <li>A prompt configuration</li>
--   </ul>
--   
--   The created prompt allows to switch between modes with
--   <a>changeModeKey</a> in <tt>conf</tt>. The modes are instances of
--   XPrompt. See XMonad.Actions.Launcher for more details
--   
--   The argument supplied to the action to execute is always the current
--   highlighted item, that means that this prompt overrides the value
--   <a>alwaysHighlight</a> for its configuration to True.
mkXPromptWithModes :: [XPType] -> XPConfig -> X ()

-- | The default value for this type.
def :: Default a => a
amberXPConfig :: XPConfig
greenXPConfig :: XPConfig
type XPMode = XPType
data XPType
XPT :: p -> XPType
data XPColor
XPColor :: String -> String -> String -> String -> String -> XPColor

-- | Background color
[bgNormal] :: XPColor -> String

-- | Font color
[fgNormal] :: XPColor -> String

-- | Background color of a highlighted completion entry
[bgHighlight] :: XPColor -> String

-- | Font color of a highlighted completion entry
[fgHighlight] :: XPColor -> String

-- | Border color
[border] :: XPColor -> String
data XPPosition
Top :: XPPosition
Bottom :: XPPosition

-- | Prompt will be placed in the center horizontally and in the certain
--   place of screen vertically. If it's in the upper part of the screen,
--   completion window will be placed below (like in <a>Top</a>) and
--   otherwise above (like in <a>Bottom</a>)
CenteredAt :: Rational -> Rational -> XPPosition

-- | Rational between 0 and 1, giving y coordinate of center of the prompt
--   relative to the screen height.
[xpCenterY] :: XPPosition -> Rational

-- | Rational between 0 and 1, giving width of the prompt relative to the
--   screen width.
[xpWidth] :: XPPosition -> Rational
data XPConfig
XPC :: String -> String -> String -> String -> String -> String -> !Dimension -> XPPosition -> !Bool -> !Dimension -> Maybe Dimension -> Maybe Dimension -> !Int -> ([String] -> [String]) -> Map (KeyMask, KeySym) (XP ()) -> (KeyMask, KeySym) -> (KeyMask, KeySym) -> KeySym -> String -> Maybe Int -> Bool -> ComplCaseSensitivity -> (String -> String -> Bool) -> (String -> String) -> (String -> [String] -> [String]) -> XPConfig

-- | Font. For TrueType fonts, use something like
--   <tt>"xft:Hack:pixelsize=1"</tt>. Alternatively, use X Logical Font
--   Description, i.e. something like <tt>"-*-dejavu sans
--   mono-medium-r-normal--*-80-*-*-*-*-iso10646-1"</tt>.
[font] :: XPConfig -> String

-- | Background color
[bgColor] :: XPConfig -> String

-- | Font color
[fgColor] :: XPConfig -> String

-- | Background color of a highlighted completion entry
[bgHLight] :: XPConfig -> String

-- | Font color of a highlighted completion entry
[fgHLight] :: XPConfig -> String

-- | Border color
[borderColor] :: XPConfig -> String

-- | Border width
[promptBorderWidth] :: XPConfig -> !Dimension

-- | Position: <a>Top</a>, <a>Bottom</a>, or <a>CenteredAt</a>
[position] :: XPConfig -> XPPosition

-- | Always highlight an item, overriden to True with multiple modes
[alwaysHighlight] :: XPConfig -> !Bool

-- | Window height
[height] :: XPConfig -> !Dimension

-- | Just x: maximum number of rows to show in completion window
[maxComplRows] :: XPConfig -> Maybe Dimension

-- | Just x: maximum number of columns to show in completion window
[maxComplColumns] :: XPConfig -> Maybe Dimension

-- | The number of history entries to be saved
[historySize] :: XPConfig -> !Int

-- | a filter to determine which history entries to remember
[historyFilter] :: XPConfig -> [String] -> [String]

-- | Mapping from key combinations to actions
[promptKeymap] :: XPConfig -> Map (KeyMask, KeySym) (XP ())

-- | Key to trigger forward completion
[completionKey] :: XPConfig -> (KeyMask, KeySym)

-- | Key to trigger backward completion
[prevCompletionKey] :: XPConfig -> (KeyMask, KeySym)

-- | Key to change mode (when the prompt has multiple modes)
[changeModeKey] :: XPConfig -> KeySym

-- | The text by default in the prompt line
[defaultText] :: XPConfig -> String

-- | Just x: if only one completion remains, auto-select it, and delay by x
--   microseconds
[autoComplete] :: XPConfig -> Maybe Int

-- | Only show list of completions when Tab was pressed
[showCompletionOnTab] :: XPConfig -> Bool

-- | Perform completion in a case-sensitive manner
[complCaseSensitivity] :: XPConfig -> ComplCaseSensitivity

-- | Given the typed string and a possible completion, is the completion
--   valid?
[searchPredicate] :: XPConfig -> String -> String -> Bool

-- | Modifies the prompt given by <a>showXPrompt</a>
[defaultPrompter] :: XPConfig -> String -> String

-- | Used to sort the possible completions by how well they match the
--   search string (see X.P.FuzzyMatch for an example).
[sorter] :: XPConfig -> String -> [String] -> [String]

-- | A class for an abstract prompt. In order for your data type to be a
--   valid prompt you _must_ make it an instance of this class.
--   
--   The minimal complete definition is just <a>showXPrompt</a>, i.e. the
--   name of the prompt. This string will be displayed in the command line
--   window (before the cursor).
--   
--   As an example of a complete <a>XPrompt</a> instance definition, we can
--   look at the <a>Shell</a> prompt from <a>XMonad.Prompt.Shell</a>:
--   
--   <pre>
--   data Shell = Shell
--   
--   instance XPrompt Shell where
--        showXPrompt Shell = "Run: "
--   </pre>
class XPrompt t

-- | This method is used to print the string to be displayed in the command
--   line window.
showXPrompt :: XPrompt t => t -> String

-- | This method is used to generate the next completion to be printed in
--   the command line when tab is pressed, given the string presently in
--   the command line and the list of completion. This function is not used
--   when in multiple modes (because alwaysHighlight in XPConfig is True)
nextCompletion :: XPrompt t => t -> String -> [String] -> String

-- | This method is used to generate the string to be passed to the
--   completion function.
commandToComplete :: XPrompt t => t -> String -> String

-- | This method is used to process each completion in order to generate
--   the string that will be compared with the command presently displayed
--   in the command line. If the prompt is using <a>getNextOfLastWord</a>
--   for implementing <a>nextCompletion</a> (the default implementation),
--   this method is also used to generate, from the returned completion,
--   the string that will form the next command line when tab is pressed.
completionToCommand :: XPrompt t => t -> String -> String

-- | When the prompt has multiple modes, this is the function used to
--   generate the autocompletion list. The argument passed to this function
--   is given by <a>commandToComplete</a> The default implementation shows
--   an error message.
completionFunction :: XPrompt t => t -> ComplFunction

-- | When the prompt has multiple modes (created with mkXPromptWithModes),
--   this function is called when the user picks an item from the
--   autocompletion list. The first argument is the prompt (or mode) on
--   which the item was picked The first string argument is the
--   autocompleted item's text. The second string argument is the query
--   made by the user (written in the prompt's buffer). See
--   XMonad<i>Actions</i>Launcher.hs for a usage example.
modeAction :: XPrompt t => t -> String -> String -> X ()
type XP = StateT XPState IO

-- | Default key bindings for prompts. Click on the "Source" link to the
--   right to see the complete list. See also <a>defaultXPKeymap'</a>.
defaultXPKeymap :: Map (KeyMask, KeySym) (XP ())

-- | A variant of <a>defaultXPKeymap</a> which lets you specify a custom
--   predicate for identifying non-word characters, which affects all the
--   word-oriented commands (move/kill word). The default is
--   <a>isSpace</a>. For example, by default a path like
--   <tt>foo/bar/baz</tt> would be considered as a single word. You could
--   use a predicate like <tt>(\c -&gt; isSpace c || c == '/')</tt> to move
--   through or delete components of the path one at a time.
defaultXPKeymap' :: (Char -> Bool) -> Map (KeyMask, KeySym) (XP ())

-- | A keymap with many emacs-like key bindings. Click on the "Source" link
--   to the right to see the complete list. See also
--   <a>emacsLikeXPKeymap'</a>.
emacsLikeXPKeymap :: Map (KeyMask, KeySym) (XP ())

-- | A variant of <a>emacsLikeXPKeymap</a> which lets you specify a custom
--   predicate for identifying non-word characters, which affects all the
--   word-oriented commands (move/kill word). The default is
--   <a>isSpace</a>. For example, by default a path like
--   <tt>foo/bar/baz</tt> would be considered as a single word. You could
--   use a predicate like <tt>(\c -&gt; isSpace c || c == '/')</tt> to move
--   through or delete components of the path one at a time.
emacsLikeXPKeymap' :: (Char -> Bool) -> Map (KeyMask, KeySym) (XP ())

-- | Vim-ish key bindings. Click on the "Source" link to the right to see
--   the complete list. See also <a>vimLikeXPKeymap'</a>.
vimLikeXPKeymap :: Map (KeyMask, KeySym) (XP ())

-- | A variant of <a>vimLikeXPKeymap</a> with customizable aspects:
vimLikeXPKeymap' :: (XPColor -> XPColor) -> (String -> String) -> (String -> String) -> (Char -> Bool) -> Map (KeyMask, KeySym) (XP ())

-- | Quit.
quit :: XP ()

-- | Initiate a prompt sub-map event loop. Submaps are intended to provide
--   alternate keybindings. Accepts a default action and a mapping from key
--   combinations to actions. If no entry matches, the default action is
--   run.
promptSubmap :: XP () -> Map (KeyMask, KeySym) (XP ()) -> XP ()

-- | Initiate a prompt input buffer event loop. Input is sent to a buffer
--   and bypasses the prompt. The provided function is given the existing
--   buffer and the input keystring. The first field of the result
--   determines whether the input loop continues (if <tt>True</tt>). The
--   second field determines whether the input is appended to the buffer,
--   or dropped (if <tt>False</tt>). If the loop is to stop without keeping
--   input - that is, <tt>(False,False)</tt> - the event is prepended to
--   the event buffer to be processed by the parent loop. This allows loop
--   to process both fixed and indeterminate inputs.
--   
--   Result given <tt>(continue,keep)</tt>:
--   
--   <ul>
--   <li>cont and keep<ul><li>grow input buffer</li></ul></li>
--   <li>stop and keep<ul><li>grow input buffer</li><li>stop
--   loop</li></ul></li>
--   <li>stop and drop<ul><li>buffer event</li><li>stop loop</li></ul></li>
--   <li>cont and drop<ul><li>do nothing</li></ul></li>
--   </ul>
promptBuffer :: (String -> String -> (Bool, Bool)) -> XP String

-- | Move the cursor in the given direction to the first instance of the
--   first character of the given string, assuming the string is not empty.
--   The starting cursor character is not considered, and the cursor is
--   placed over the matching character.
toHeadChar :: Direction1D -> String -> XP ()

-- | Predicate instructing <a>promptBuffer</a> to get (and keep) a single
--   non-empty <a>KeyEvent</a>.
bufferOne :: String -> String -> (Bool, Bool)

-- | Kill the portion of the command before the cursor
killBefore :: XP ()

-- | Kill the portion of the command including and after the cursor
killAfter :: XP ()

-- | Put the cursor at the start of line
startOfLine :: XP ()

-- | Put the cursor at the end of line
endOfLine :: XP ()

-- | Insert a character at the cursor position
insertString :: String -> XP ()

-- | Insert the current X selection string at the cursor position. The X
--   selection is not modified.
pasteString :: XP ()

-- | A variant of <a>pasteString</a> which allows modifying the X selection
--   before pasting.
pasteString' :: (String -> String) -> XP ()

-- | Ensure the cursor remains over the command by shifting left if
--   necessary.
clipCursor :: XP ()

-- | Move the cursor one position.
moveCursor :: Direction1D -> XP ()

-- | Move the cursor one position, but not beyond the command.
moveCursorClip :: Direction1D -> XP ()

-- | Sets the input string to the given value.
setInput :: String -> XP ()

-- | Returns the current input string. Intended for use in custom keymaps
--   where <a>get</a> or similar can't be used to retrieve it.
getInput :: XP String

-- | Returns the offset of the current input string. Intended for use in
--   custom keys where <a>get</a> or similar can't be used to retrieve it.
getOffset :: XP Int

-- | Accessor encapsulating disparate color fields of <a>XPConfig</a> into
--   an <a>XPColor</a> (the configuration provides default values).
defaultColor :: XPConfig -> XPColor

-- | Modify the prompt colors.
modifyColor :: (XPColor -> XPColor) -> XP ()

-- | Set the prompt colors.
setColor :: XPColor -> XP ()

-- | Reset the prompt colors to those from <a>XPConfig</a>.
resetColor :: XP ()

-- | Set the prompt border color.
setBorderColor :: String -> XPColor -> XPColor

-- | Modify the prompter, i.e. for chaining prompters.
modifyPrompter :: ((String -> String) -> String -> String) -> XP ()

-- | Set the prompter.
setPrompter :: (String -> String) -> XP ()

-- | Reset the prompter to the one from <a>XPConfig</a>.
resetPrompter :: XP ()

-- | Return the selected completion, i.e. the <a>String</a> we actually act
--   upon after the user confirmed their selection (by pressing
--   <tt>Enter</tt>).
selectedCompletion :: XPState -> String

-- | Set the current completion list, or <a>Nothing</a> to invalidate the
--   current completions.
setCurrentCompletions :: Maybe [String] -> XP ()

-- | Get the current completion list.
getCurrentCompletions :: XP (Maybe [String])

-- | Move the cursor one word, using <a>isSpace</a> as the default
--   predicate for non-word characters. See <a>moveWord'</a>.
moveWord :: Direction1D -> XP ()

-- | Given a direction, move the cursor to just before the next
--   (predicate,not-predicate) character transition. This means a
--   (not-word,word) transition should be followed by a
--   <a>moveCursorClip</a> action. Always considers the character under the
--   current cursor position. This means a (word,not-word) transition
--   should be preceded by a <a>moveCursorClip</a> action. Calculated as
--   the length of consecutive non-predicate characters starting from the
--   cursor position, plus the length of subsequent consecutive predicate
--   characters, plus when moving backwards the distance of the cursor
--   beyond the input. Reduced by one to avoid jumping off either end of
--   the input, when present.
--   
--   Use these identities to retain the pre-0.14 behavior:
--   
--   <pre>
--   (oldMoveWord' p Prev) = (moveCursor Prev &gt;&gt; moveWord' p Prev)
--   </pre>
--   
--   <pre>
--   (oldMoveWord' p Next) = (moveWord' p Next &gt;&gt; moveCursor Next)
--   </pre>
moveWord' :: (Char -> Bool) -> Direction1D -> XP ()

-- | Kill the next/previous word, using <a>isSpace</a> as the default
--   predicate for non-word characters. See <a>killWord'</a>.
killWord :: Direction1D -> XP ()

-- | Kill the next/previous word, given a predicate to identify non-word
--   characters. First delete any consecutive non-word characters; then
--   delete consecutive word characters, stopping just before the next
--   non-word character.
--   
--   For example, by default (using <a>killWord</a>) a path like
--   <tt>foo/bar/baz</tt> would be deleted in its entirety. Instead you can
--   use something like <tt>killWord' (\c -&gt; isSpace c || c == '/')</tt>
--   to delete the path one component at a time.
killWord' :: (Char -> Bool) -> Direction1D -> XP ()

-- | From Vim's <tt>:help cw</tt>:
--   
--   <ul>
--   <li>Special case: When the cursor is in a word, "cw" and "cW" do not
--   include the white space after a word, they only change up to the end
--   of the word.</li>
--   </ul>
changeWord :: (Char -> Bool) -> XP ()

-- | Remove a character at the cursor position
deleteString :: Direction1D -> XP ()

-- | Set the prompt's input to an entry further up or further down the
--   history stack. Use <tt>Stack</tt> functions from <a>StackSet</a>, i.e.
--   <tt>focusUp'</tt> or <tt>focusDown'</tt>.
moveHistory :: (Stack String -> Stack String) -> XP ()

-- | Set <tt>True</tt> to save the prompt's entry to history and run it via
--   the provided action.
setSuccess :: Bool -> XP ()

-- | Set <tt>True</tt> to leave all event loops, no matter how nested.
setDone :: Bool -> XP ()

-- | Set <tt>True</tt> to leave the current event loop, i.e. submaps.
setModeDone :: Bool -> XP ()

-- | One-dimensional directions:
data Direction1D
Next :: Direction1D
Prev :: Direction1D
type ComplFunction = String -> IO [String]
data ComplCaseSensitivity
CaseSensitive :: ComplCaseSensitivity
CaseInSensitive :: ComplCaseSensitivity

-- | Creates a window with the attribute override_redirect set to True.
--   Windows Managers should not touch this kind of windows.
mkUnmanagedWindow :: Display -> Screen -> Window -> Position -> Position -> Dimension -> Dimension -> IO Window

-- | Fills a <a>Drawable</a> with a rectangle and a border
fillDrawable :: Display -> Drawable -> GC -> Pixel -> Pixel -> Dimension -> Dimension -> Dimension -> IO ()

-- | This function takes a list of possible completions and returns a
--   completions function to be used with <a>mkXPrompt</a>
mkComplFunFromList :: XPConfig -> [String] -> String -> IO [String]

-- | This function takes a list of possible completions and returns a
--   completions function to be used with <a>mkXPrompt</a>. If the string
--   is null it will return all completions.
mkComplFunFromList' :: XPConfig -> [String] -> String -> IO [String]

-- | Given the prompt type, the command line and the completion list,
--   return the next completion in the list for the last word of the
--   command line. This is the default <a>nextCompletion</a>
--   implementation.
getNextOfLastWord :: XPrompt t => t -> String -> [String] -> String

-- | An alternative <a>nextCompletion</a> implementation: given a command
--   and a completion list, get the next completion in the list matching
--   the whole command line.
getNextCompletion :: String -> [String] -> String

-- | Gets the last word of a string or the whole string if formed by only
--   one word
getLastWord :: String -> String

-- | Skips the last word of the string, if the string is composed by more
--   then one word. Otherwise returns the string.
skipLastWord :: String -> String

-- | Given a maximum length, splits a list into sublists

-- | <i>Deprecated: Use XMonad.Prelude.chunksOf instead.</i>
splitInSubListsAt :: Int -> [a] -> [[a]]
breakAtSpace :: String -> (String, String)

-- | Sort a list and remove duplicates. Like <a>deleteAllDuplicates</a>,
--   but trades off laziness and stability for efficiency.
uniqSort :: Ord a => [a] -> [a]

-- | <a>historyCompletion</a> provides a canned completion function much
--   like <tt>getShellCompl</tt>; you pass it to mkXPrompt, and it will
--   make completions work from the query history stored in the XMonad
--   cache directory.
historyCompletion :: XPConfig -> X ComplFunction

-- | Like <a>historyCompletion</a> but only uses history data from Prompts
--   whose name satisfies the given predicate.
historyCompletionP :: XPConfig -> (String -> Bool) -> X ComplFunction

-- | Functions to be used with the <a>historyFilter</a> setting.
--   <a>deleteAllDuplicates</a> will remove all duplicate entries.
--   <a>deleteConsecutive</a> will only remove duplicate elements
--   immediately next to each other.
deleteAllDuplicates :: [String] -> [String]

-- | Functions to be used with the <a>historyFilter</a> setting.
--   <a>deleteAllDuplicates</a> will remove all duplicate entries.
--   <a>deleteConsecutive</a> will only remove duplicate elements
--   immediately next to each other.
deleteConsecutive :: [String] -> [String]
data HistoryMatches

-- | Initializes a new HistoryMatches structure to be passed to
--   historyUpMatching
initMatches :: (Functor m, MonadIO m) => m HistoryMatches

-- | Retrieve the next history element that starts with the current input.
--   Pass it the result of initMatches when creating the prompt. Example:
--   
--   <pre>
--   ..
--   ((modMask,xK_p), shellPrompt . myPrompt =&lt;&lt; initMatches)
--   ..
--   myPrompt ref = def
--     { promptKeymap = M.union [((0,xK_Up), historyUpMatching ref)
--                              ,((0,xK_Down), historyDownMatching ref)]
--                              (promptKeymap def)
--     , .. }
--   </pre>
historyUpMatching :: HistoryMatches -> XP ()

-- | Retrieve the next history element that starts with the current input.
--   Pass it the result of initMatches when creating the prompt. Example:
--   
--   <pre>
--   ..
--   ((modMask,xK_p), shellPrompt . myPrompt =&lt;&lt; initMatches)
--   ..
--   myPrompt ref = def
--     { promptKeymap = M.union [((0,xK_Up), historyUpMatching ref)
--                              ,((0,xK_Down), historyDownMatching ref)]
--                              (promptKeymap def)
--     , .. }
--   </pre>
historyDownMatching :: HistoryMatches -> XP ()
data XPState
instance GHC.Read.Read XMonad.Prompt.XPPosition
instance GHC.Show.Show XMonad.Prompt.XPPosition
instance GHC.Classes.Eq XMonad.Prompt.ComplWindowDim
instance Data.Default.Class.Default XMonad.Prompt.XPConfig
instance Data.Default.Class.Default XMonad.Prompt.XPColor
instance GHC.Show.Show XMonad.Prompt.XPType
instance XMonad.Prompt.XPrompt XMonad.Prompt.XPType


-- | A version of <a>XMonad.Prompt.Shell</a> that lets you access the
--   awesome power of Zsh completions in your xmonad prompt
module XMonad.Prompt.Zsh
data Zsh
Zsh :: Zsh
zshPrompt :: XPConfig -> FilePath -> X ()
getZshCompl :: FilePath -> String -> IO [String]

-- | Removes the argument description from the zsh completion
stripZsh :: String -> String
instance XMonad.Prompt.XPrompt XMonad.Prompt.Zsh.Zsh


-- | A prompt for running XMonad commands
module XMonad.Prompt.XMonad
xmonadPrompt :: XPConfig -> X ()

-- | An xmonad prompt with a custom command list
xmonadPromptC :: [(String, X ())] -> XPConfig -> X ()

-- | An xmonad prompt with a custom command list and a custom title
xmonadPromptCT :: String -> [(String, X ())] -> XPConfig -> X ()
data XMonad
instance XMonad.Prompt.XPrompt XMonad.Prompt.XMonad.XMonad


-- | A workspace prompt for XMonad
module XMonad.Prompt.Workspace
workspacePrompt :: XPConfig -> (String -> X ()) -> X ()
newtype Wor
Wor :: String -> Wor
instance XMonad.Prompt.XPrompt XMonad.Prompt.Workspace.Wor


-- | A prompt for searching unicode characters by name and inserting them
--   into the clipboard.
--   
--   The provided <tt>unicodePrompt</tt> and <tt>typeUnicodePrompt</tt> use
--   <tt>xsel</tt> and <tt>xdotool</tt> respectively.
module XMonad.Prompt.Unicode

-- | Prompt the user for a Unicode character to be inserted into the paste
--   buffer of the X server.
unicodePrompt :: String -> XPConfig -> X ()

-- | Prompt the user for a Unicode character to be typed by
--   <tt>xdotool</tt>.
typeUnicodePrompt :: String -> XPConfig -> X ()
mkUnicodePrompt :: String -> [String] -> String -> XPConfig -> X ()
instance GHC.Show.Show XMonad.Prompt.Unicode.UnicodeData
instance GHC.Read.Read XMonad.Prompt.Unicode.UnicodeData
instance XMonad.Core.ExtensionClass XMonad.Prompt.Unicode.UnicodeData
instance XMonad.Prompt.XPrompt XMonad.Prompt.Unicode.Unicode


-- | A ssh prompt for XMonad
module XMonad.Prompt.Ssh
sshPrompt :: XPConfig -> X ()
data Ssh
instance XMonad.Prompt.XPrompt XMonad.Prompt.Ssh.Ssh


-- | A shell prompt for XMonad
module XMonad.Prompt.Shell
data Shell
Shell :: Shell
shellPrompt :: XPConfig -> X ()
safePrompt :: FilePath -> XPConfig -> X ()

-- | Like <a>safePrompt</a>, but optimized for the use-case of a program
--   that needs a file as an argument.
--   
--   For example, a prompt for <a>dragon</a> that always starts searching
--   in your home directory would look like
--   
--   <pre>
--   safeDirPrompt "dragon" def "~/"
--   </pre>
--   
--   This is especially useful when using something like <a>fuzzyMatch</a>
--   from <a>XMonad.Prompt.FuzzyMatch</a> as your prompt's
--   <tt>searchPredicate</tt>.
safeDirPrompt :: FilePath -> XPConfig -> String -> X ()
unsafePrompt :: FilePath -> XPConfig -> X ()
prompt :: FilePath -> XPConfig -> X ()
compgenDirectories :: ComplCaseSensitivity -> String -> IO String
compgenFiles :: ComplCaseSensitivity -> String -> IO String
getCommands :: IO [String]

-- | Ask the shell what browser the user likes. If the user hasn't defined
--   any $BROWSER, defaults to returning "firefox", since that seems to be
--   the most common X web browser. Note that if you don't specify a GUI
--   browser but a textual one, that'll be a problem as <a>getBrowser</a>
--   will be called by functions expecting to be able to just execute the
--   string or pass it to a shell; so in that case, define $BROWSER as
--   something like "xterm -e elinks" or as the name of a shell script
--   doing much the same thing.
getBrowser :: IO String

-- | Like <a>getBrowser</a>, but should be of a text editor. This gets the
--   $EDITOR variable, defaulting to "emacs".
getEditor :: IO String
getShellCompl :: [String] -> Predicate -> String -> IO [String]
getShellCompl' :: ComplCaseSensitivity -> [String] -> Predicate -> String -> IO [String]
split :: Eq a => a -> [a] -> [[a]]
instance XMonad.Prompt.XPrompt XMonad.Prompt.Shell.Shell


-- | Defines a few convenient operations for raising (traveling to) windows
--   based on XMonad's Query monad, such as <a>runOrRaise</a>. runOrRaise
--   will run a shell command unless it can find a specified window; you
--   would use this to automatically travel to your Firefox or Emacs
--   session, or start a new one (for example), instead of trying to
--   remember where you left it or whether you still have one running.
module XMonad.Actions.WindowGo

-- | See <a>raiseMaybe</a>. If the Window can't be found, quietly give up
--   and do nothing.
raise :: Query Bool -> X ()

-- | See <a>raise</a> and <a>raiseNextMaybe</a>. Version that allows
--   cycling through matches.
raiseNext :: Query Bool -> X ()

-- | <tt>action</tt> is an executable to be run via <a>safeSpawnProg</a>
--   (of <a>XMonad.Util.Run</a>) if the Window cannot be found. Presumably
--   this executable is the same one that you were looking for. Note that
--   this does not go through the shell. If you wish to run an arbitrary IO
--   action (such as <tt>spawn</tt>, which will run its String argument
--   through the shell), then you will want to use <a>raiseMaybe</a>
--   directly.
runOrRaise :: String -> Query Bool -> X ()

-- | See <a>runOrRaise</a> and <a>raiseNextMaybe</a>. Version that allows
--   cycling through matches.
runOrRaiseNext :: String -> Query Bool -> X ()

-- | <a>raiseMaybe</a> queries all Windows based on a boolean provided by
--   the user. Currently, there are 3 such useful booleans defined in
--   <a>XMonad.ManageHook</a>: <a>title</a>, <a>resource</a>,
--   <a>className</a>. Each one tests based pretty much as you would think.
--   ManageHook also defines several operators, the most useful of which is
--   (=?). So a useful test might be finding a <tt>Window</tt> whose class
--   is Firefox. Firefox 3 declares the class "Firefox", so you'd want to
--   pass in a boolean like <tt>(className =? "Firefox")</tt>.
--   
--   If the boolean returns <tt>True</tt> on one or more windows, then
--   XMonad will quickly make visible the first result. If no
--   <tt>Window</tt> meets the criteria, then the first argument comes into
--   play.
--   
--   The first argument is an arbitrary IO function which will be executed
--   if the tests fail. This is what enables <a>runOrRaise</a> to use
--   <a>raiseMaybe</a>: it simply runs the desired program if it isn't
--   found. But you don't have to do that. Maybe you want to do nothing if
--   the search fails (the definition of <a>raise</a>), or maybe you want
--   to write to a log file, or call some prompt function, or something
--   crazy like that. This hook gives you that flexibility. You can do some
--   cute things with this hook. Suppose you want to do the same thing for
--   Mutt which you just did for Firefox - but Mutt runs inside a terminal
--   window? No problem: you search for a terminal window calling itself
--   "mutt", and if there isn't you run a terminal with a command to run
--   Mutt! Here's an example (borrowing <tt>runInTerm</tt> from
--   <a>XMonad.Util.Run</a>):
--   
--   <pre>
--   , ((modm, xK_m), raiseMaybe (runInTerm "-title mutt" "mutt") (title =? "mutt"))
--   </pre>
raiseMaybe :: X () -> Query Bool -> X ()

-- | See <a>raiseMaybe</a>. <a>raiseNextMaybe</a> is an alternative version
--   that allows cycling through the matching windows. If the focused
--   window matches the query the next matching window is raised. If no
--   matches are found the function f is executed.
raiseNextMaybe :: X () -> Query Bool -> X ()

-- | See <a>raiseMaybe</a> and <a>raiseNextMaybe</a>. In addition to all of
--   the options offered by <a>raiseNextMaybe</a>
--   <a>raiseNextMaybeCustomFocus</a> allows the user to supply the
--   function that should be used to shift the focus to any window that is
--   found.
raiseNextMaybeCustomFocus :: (Window -> WindowSet -> WindowSet) -> X () -> Query Bool -> X ()

-- | <a>raiseBrowser</a> and <a>raiseEditor</a> grab $BROWSER and $EDITOR
--   respectively and they either take you to the specified program's
--   window, or they try to run it. This is most useful if your variables
--   are simple and look like "firefox" or "emacs".
raiseBrowser :: X ()

-- | <a>raiseBrowser</a> and <a>raiseEditor</a> grab $BROWSER and $EDITOR
--   respectively and they either take you to the specified program's
--   window, or they try to run it. This is most useful if your variables
--   are simple and look like "firefox" or "emacs".
raiseEditor :: X ()

-- | If a window matching the second argument is found, the window is
--   focused and the third argument is called; otherwise, the first
--   argument is called.
runOrRaiseAndDo :: String -> Query Bool -> (Window -> X ()) -> X ()

-- | If the window is found the window is focused and set to master
--   otherwise, action is run.
--   
--   <pre>
--   runOrRaiseMaster "firefox" (className =? "Firefox")) 
--   </pre>
runOrRaiseMaster :: String -> Query Bool -> X ()

-- | If the window is found the window is focused and the third argument is
--   called otherwise, the first argument is called See <a>raiseMaster</a>
--   for an example.
raiseAndDo :: X () -> Query Bool -> (Window -> X ()) -> X ()

-- | if the window is found the window is focused and set to master
--   otherwise, the first argument is called.
--   
--   <pre>
--   raiseMaster (runInTerm "-title ghci"  "zsh -c 'ghci'") (title =? "ghci") 
--   </pre>
raiseMaster :: X () -> Query Bool -> X ()

-- | If windows that satisfy the query exist, apply the supplied function
--   to them, otherwise run the action given as second parameter.
ifWindows :: Query Bool -> ([Window] -> X ()) -> X () -> X ()

-- | The same as ifWindows, but applies a ManageHook to the first match
--   instead and discards the other matches
ifWindow :: Query Bool -> ManageHook -> X () -> X ()

-- | A manage hook that raises the window.
raiseHook :: ManageHook


-- | A prompt for XMonad which will run a program, open a file, or raise an
--   already running program, depending on context.
module XMonad.Prompt.RunOrRaise
runOrRaisePrompt :: XPConfig -> X ()
data RunOrRaisePrompt
instance XMonad.Prompt.XPrompt XMonad.Prompt.RunOrRaise.RunOrRaisePrompt


-- | A thin wrapper around the standard <tt>pass(1)</tt> UNIX utility.
--   
--   This module provides several prompts to ease password manipulation
--   (generate, read, edit, remove); all of them benefit from the
--   completion system provided by <a>XMonad.Prompt</a>. Specifically, we
--   provide
--   
--   <ul>
--   <li>various functions to lookup passwords in the password-store:+
--   <a>passPrompt</a> copies the password directly to the clipboard.+
--   <a>passOTPPrompt</a> copies a one-time-password to the clipboard (this
--   uses <a>pass-otp</a>).+ <a>passTypePrompt</a> and
--   <a>passOTPTypePrompt</a> work like the above, respectively, but use
--   <tt>xdotool</tt> to type out the password.</li>
--   <li><a>passGeneratePrompt</a> generates a password for a given
--   password label that the user inputs.</li>
--   <li><a>passEditPrompt</a> edits a password for a given password label
--   that the user inputs.</li>
--   <li><a>passRemovePrompt</a> deletes a stored password for a given
--   password label that the user inputs.</li>
--   </ul>
--   
--   The password store is setup through an environment variable
--   <tt>$PASSWORD_STORE_DIR</tt>, or <tt>$HOME/.password-store</tt> if it
--   is unset. The editor is determined from the environment variable
--   <tt>$EDITOR</tt>.
--   
--   Source:
--   
--   <ul>
--   <li>The <a>password store</a> implementation is <a>here</a>.</li>
--   <li>Inspired by
--   <a>http://babushk.in/posts/combining-xmonad-and-pass.html</a></li>
--   </ul>
module XMonad.Prompt.Pass

-- | A prompt to retrieve a password from a given entry.
passPrompt :: XPConfig -> X ()

-- | The same as <a>passPrompt</a> but with a user-specified prompt.
passPrompt' :: String -> XPConfig -> X ()

-- | A prompt to type in a password for a given entry. This doesn't touch
--   the clipboard.
passTypePrompt :: XPConfig -> X ()

-- | A prompt to edit a given entry. This doesn't touch the clipboard.
passEditPrompt :: XPConfig -> X ()

-- | The same as <a>passEditPrompt</a> but with a user-specified prompt.
passEditPrompt' :: String -> XPConfig -> X ()

-- | A prompt to remove a password for a given entry. (Beware that no
--   confirmation is asked)
passRemovePrompt :: XPConfig -> X ()

-- | The same as <a>passRemovePrompt</a> but with a user-specified prompt.
passRemovePrompt' :: String -> XPConfig -> X ()

-- | A prompt to generate a password for a given entry. This can be used to
--   override an already stored entry. (Beware that no confirmation is
--   asked)
passGeneratePrompt :: XPConfig -> X ()

-- | The same as <a>passGeneratePrompt</a> but with a user-specified
--   prompt.
passGeneratePrompt' :: String -> XPConfig -> X ()

-- | A prompt to generate a password for a given entry and immediately copy
--   it to the clipboard. This can be used to override an already stored
--   entry. (Beware that no confirmation is asked)
passGenerateAndCopyPrompt :: XPConfig -> X ()

-- | The same as <a>passGenerateAndCopyPrompt</a> but with a user-specified
--   prompt.
passGenerateAndCopyPrompt' :: String -> XPConfig -> X ()

-- | A prompt to retrieve a OTP from a given entry. Note that you will need
--   to use the <a>pass-otp</a> extension for this to work.
passOTPPrompt :: XPConfig -> X ()

-- | A prompt to retrieve a OTP from a given entry. Note that you will need
--   to use the <a>pass-otp</a> extension for this to work.
passOTPTypePrompt :: XPConfig -> X ()
instance XMonad.Prompt.XPrompt XMonad.Prompt.Pass.Pass


-- | A prompt for interacting with <a>org-mode</a>. This can be seen as an
--   org-specific version of <a>XMonad.Prompt.AppendFile</a>, allowing for
--   more interesting interactions with that particular file type.
--   
--   It can be used to quickly save TODOs, NOTEs, and the like with the
--   additional capability to schedule/deadline a task, add a priority,
--   refile to some existing heading, and use the system's clipboard
--   (really: the primary selection) as the contents of the note.
--   
--   A blog post highlighting some features of this module can be found
--   <a>here</a>.
module XMonad.Prompt.OrgMode

-- | Prompt for interacting with <tt>org-mode</tt>.
orgPrompt :: XPConfig -> String -> FilePath -> X ()

-- | Like <a>orgPrompt</a> (which see for the other arguments), but offer
--   to refile the entered note afterwards.
--   
--   Note that refiling is done by shelling out to Emacs, hence an
--   <tt>emacs</tt> binary must be in <tt>$PATH</tt>. One may customise
--   this by following the instructions in <a>XMonad.Util.Run#g:EDSL</a>;
--   more specifically, by changing the <a>emacs</a> field of
--   <a>ProcessConfig</a>.
orgPromptRefile :: XPConfig -> String -> FilePath -> X ()

-- | Like <a>orgPromptRefile</a>, but with a fixed heading for refiling; no
--   prompt will appear to query for a target.
--   
--   Heading names may omit tags, but generally need to be prefixed by the
--   correct todo keywords; e.g.,
--   
--   <pre>
--   orgPromptRefileTo def "PROJECT Work" "TODO" "~/todos.org"
--   </pre>
--   
--   Will refile the created note <tt>"TODO <a>text</a>"</tt> to the
--   <tt>"PROJECT Work"</tt> heading, even with the actual name is
--   <tt>"PROJECT Work :work:other_tags:"</tt>. Just entering
--   <tt><a>Work</a></tt> will not work, as Emacs doesn't recognise
--   <tt><a>PROJECT</a></tt> as an Org keyword by default (i.e. when
--   started in batch-mode).
orgPromptRefileTo :: XPConfig -> String -> String -> FilePath -> X ()

-- | Like <a>orgPrompt</a>, but additionally make use of the primary
--   selection. If it is a URL, then use an org-style link
--   <tt>[[primary-selection][entered message]]</tt> as the heading.
--   Otherwise, use the primary selection as the content of the note.
--   
--   The prompt will display a little <tt>+ PS</tt> in the window after the
--   type of note.
orgPromptPrimary :: XPConfig -> String -> FilePath -> X ()

-- | Whether we should use a clipboard and which one to use.
data ClipboardSupport
PrimarySelection :: ClipboardSupport
NoClpSupport :: ClipboardSupport
data OrgMode
instance GHC.Classes.Eq XMonad.Prompt.OrgMode.TimeOfDay
instance GHC.Classes.Eq XMonad.Prompt.OrgMode.OrgTime
instance GHC.Show.Show XMonad.Prompt.OrgMode.DayOfWeek
instance GHC.Classes.Ord XMonad.Prompt.OrgMode.DayOfWeek
instance GHC.Classes.Eq XMonad.Prompt.OrgMode.DayOfWeek
instance GHC.Show.Show XMonad.Prompt.OrgMode.Date
instance GHC.Classes.Ord XMonad.Prompt.OrgMode.Date
instance GHC.Classes.Eq XMonad.Prompt.OrgMode.Date
instance GHC.Show.Show XMonad.Prompt.OrgMode.Time
instance GHC.Classes.Eq XMonad.Prompt.OrgMode.Time
instance GHC.Show.Show XMonad.Prompt.OrgMode.Priority
instance GHC.Classes.Eq XMonad.Prompt.OrgMode.Priority
instance GHC.Show.Show XMonad.Prompt.OrgMode.Note
instance GHC.Classes.Eq XMonad.Prompt.OrgMode.Note
instance GHC.Enum.Enum XMonad.Prompt.OrgMode.DayOfWeek
instance GHC.Show.Show XMonad.Prompt.OrgMode.OrgTime
instance GHC.Show.Show XMonad.Prompt.OrgMode.TimeOfDay
instance XMonad.Prompt.XPrompt XMonad.Prompt.OrgMode.RefilePrompt
instance XMonad.Prompt.XPrompt XMonad.Prompt.OrgMode.OrgMode


-- | A manual page prompt for XMonad window manager.
--   
--   TODO
--   
--   <ul>
--   <li>narrow completions by section number, if the one is specified
--   (like <tt>/etc/bash_completion</tt> does)</li>
--   </ul>
module XMonad.Prompt.Man

-- | Query for manual page to be displayed.
manPrompt :: XPConfig -> X ()

-- | Run a command using shell and return its output.
--   
--   XXX Merge into <a>XMonad.Util.Run</a>?
--   
--   (Ask "gurus" whether <tt>evaluate (length ...)</tt> approach is
--   better/more idiomatic.)
getCommandOutput :: String -> IO String
data Man
instance XMonad.Prompt.XPrompt XMonad.Prompt.Man.Man


-- | A layout-selection prompt for XMonad
module XMonad.Prompt.Layout
layoutPrompt :: XPConfig -> X ()


-- | A generic framework for prompting the user for input and passing it
--   along to some other action.
module XMonad.Prompt.Input

-- | Given a prompt configuration and some prompt text, create an X action
--   which pops up a prompt waiting for user input, and returns whatever
--   they type. Note that the type of the action is <tt>X (Maybe
--   String)</tt>, which reflects the fact that the user might cancel the
--   prompt (resulting in <tt>Nothing</tt>), or enter an input string
--   <tt>s</tt> (resulting in <tt>Just s</tt>).
inputPrompt :: XPConfig -> String -> X (Maybe String)

-- | The same as <a>inputPrompt</a>, but with a completion function. The
--   type <tt>ComplFunction</tt> is <tt>String -&gt; IO [String]</tt>, as
--   defined in <a>XMonad.Prompt</a>. The <a>mkComplFunFromList</a> utility
--   function, also defined in <a>XMonad.Prompt</a>, is useful for creating
--   such a function from a known list of possibilities.
inputPromptWithCompl :: XPConfig -> String -> ComplFunction -> X (Maybe String)

-- | A combinator for hooking up an input prompt action to a function which
--   can take the result of the input prompt and produce another action. If
--   the user cancels the input prompt, the second function will not be
--   run.
--   
--   The astute student of types will note that this is actually a very
--   general combinator and has nothing in particular to do with input
--   prompts. If you find a more general use for it and want to move it to
--   a different module, be my guest.
(?+) :: Monad m => m (Maybe a) -> (a -> m ()) -> m ()
infixr 1 ?+
data InputPrompt
instance XMonad.Prompt.XPrompt XMonad.Prompt.Input.InputPrompt


-- | A prompt for sending quick, one-line emails, via the standard GNU
--   'mail' utility (which must be in your $PATH). This module is intended
--   mostly as an example of using <a>XMonad.Prompt.Input</a> to build an
--   action requiring user input.
module XMonad.Prompt.Email

-- | Prompt the user for a recipient, subject, and body, and send an email
--   via the GNU 'mail' utility. The second argument is a list of addresses
--   for autocompletion.
emailPrompt :: XPConfig -> [String] -> X ()


-- | A directory prompt for XMonad
module XMonad.Prompt.Directory
directoryPrompt :: XPConfig -> String -> (String -> X ()) -> X ()

-- | A <tt>XPType</tt> entry suitable for using with
--   <tt>mkXPromptWithModes</tt>.
directoryMultipleModes :: String -> (String -> X ()) -> XPType

-- | Like <tt>directoryMultipleModes</tt> with a parameter for completion
--   case-sensitivity.
directoryMultipleModes' :: ComplCaseSensitivity -> String -> (String -> X ()) -> XPType
data Dir
instance XMonad.Prompt.XPrompt XMonad.Prompt.Directory.Dir


-- | A directory file executables prompt for XMonad. This might be useful
--   if you don't want to have scripts in your PATH environment variable
--   (same executable names, different behavior) - otherwise you might want
--   to use <a>XMonad.Prompt.Shell</a> instead - but you want to have easy
--   access to these executables through the xmonad's prompt.
module XMonad.Prompt.DirExec

-- | Function <a>dirExecPrompt</a> starts the prompt with list of all
--   executable files in directory specified by <a>FilePath</a>. The name
--   of the prompt is taken from the last element of the path. If you
--   specify root directory - <tt>/</tt> - as the path, name <tt>Root:</tt>
--   will be used as the name of the prompt instead. The <a>XPConfig</a>
--   parameter can be used to customize visuals of the prompt. The runner
--   parameter specifies the function used to run the program - see usage
--   for more information
dirExecPrompt :: XPConfig -> (String -> X ()) -> FilePath -> X ()

-- | Function <a>dirExecPromptNamed</a> does the same as
--   <a>dirExecPrompt</a> except the name of the prompt is specified by
--   <a>String</a> parameter.
dirExecPromptNamed :: XPConfig -> (String -> X ()) -> FilePath -> String -> X ()
data DirExec
instance XMonad.Prompt.XPrompt XMonad.Prompt.DirExec.DirExec


-- | A module for setting up simple confirmation prompts for keybindings.
module XMonad.Prompt.ConfirmPrompt

-- | Prompt the user to confirm a given action. We offer no completion and
--   simply ask to confirm (ENTER) or cancel (ESCAPE). The actual key
--   handling is done by mkXPrompt.
confirmPrompt :: XPConfig -> String -> X () -> X ()

-- | A class for an abstract prompt. In order for your data type to be a
--   valid prompt you _must_ make it an instance of this class.
--   
--   The minimal complete definition is just <a>showXPrompt</a>, i.e. the
--   name of the prompt. This string will be displayed in the command line
--   window (before the cursor).
--   
--   As an example of a complete <a>XPrompt</a> instance definition, we can
--   look at the <a>Shell</a> prompt from <a>XMonad.Prompt.Shell</a>:
--   
--   <pre>
--   data Shell = Shell
--   
--   instance XPrompt Shell where
--        showXPrompt Shell = "Run: "
--   </pre>
class XPrompt t

-- | This method is used to print the string to be displayed in the command
--   line window.
showXPrompt :: XPrompt t => t -> String
data XPConfig

-- | Creates a prompt given:
--   
--   <ul>
--   <li>a prompt type, instance of the <a>XPrompt</a> class.</li>
--   <li>a prompt configuration (<a>def</a> can be used as a starting
--   point)</li>
--   <li>a completion function (<a>mkComplFunFromList</a> can be used to
--   create a completions function given a list of possible
--   completions)</li>
--   <li>an action to be run: the action must take a string and return
--   <a>X</a> ()</li>
--   </ul>
mkXPrompt :: XPrompt p => p -> XPConfig -> ComplFunction -> (String -> X ()) -> X ()

-- | This function takes a list of possible completions and returns a
--   completions function to be used with <a>mkXPrompt</a>
mkComplFunFromList :: XPConfig -> [String] -> String -> IO [String]

-- | Customized <a>XPrompt</a> prompt that will ask to confirm the given
--   string
data EnterPrompt
instance XMonad.Prompt.XPrompt XMonad.Prompt.ConfirmPrompt.EnterPrompt


-- | A prompt for appending a single line of text to a file. Useful for
--   keeping a file of notes, things to remember for later, and so on---
--   using a keybinding, you can write things down just about as quickly as
--   you think of them, so it doesn't have to interrupt whatever else
--   you're doing.
--   
--   Who knows, it might be useful for other purposes as well!
module XMonad.Prompt.AppendFile

-- | Given an XPrompt configuration and a file path, prompt the user for a
--   line of text, and append it to the given file.
appendFilePrompt :: XPConfig -> FilePath -> X ()

-- | Given an XPrompt configuration, string transformation function and a
--   file path, prompt the user for a line of text, transform it and append
--   the result to the given file.
appendFilePrompt' :: XPConfig -> (String -> String) -> FilePath -> X ()
data AppendFile
instance XMonad.Prompt.XPrompt XMonad.Prompt.AppendFile.AppendFile


-- | A module for launch applicationes that receive parameters in the
--   command line. The launcher call a prompt to get the parameters.
module XMonad.Prompt.AppLauncher

-- | Get the user's response to a prompt an launch an application using the
--   input as command parameters of the application.
launchApp :: XPConfig -> Application -> X ()

-- | A class for an abstract prompt. In order for your data type to be a
--   valid prompt you _must_ make it an instance of this class.
--   
--   The minimal complete definition is just <a>showXPrompt</a>, i.e. the
--   name of the prompt. This string will be displayed in the command line
--   window (before the cursor).
--   
--   As an example of a complete <a>XPrompt</a> instance definition, we can
--   look at the <a>Shell</a> prompt from <a>XMonad.Prompt.Shell</a>:
--   
--   <pre>
--   data Shell = Shell
--   
--   instance XPrompt Shell where
--        showXPrompt Shell = "Run: "
--   </pre>
class XPrompt t

-- | This method is used to print the string to be displayed in the command
--   line window.
showXPrompt :: XPrompt t => t -> String
data XPConfig

-- | Creates a prompt given:
--   
--   <ul>
--   <li>a prompt type, instance of the <a>XPrompt</a> class.</li>
--   <li>a prompt configuration (<a>def</a> can be used as a starting
--   point)</li>
--   <li>a completion function (<a>mkComplFunFromList</a> can be used to
--   create a completions function given a list of possible
--   completions)</li>
--   <li>an action to be run: the action must take a string and return
--   <a>X</a> ()</li>
--   </ul>
mkXPrompt :: XPrompt p => p -> XPConfig -> ComplFunction -> (String -> X ()) -> X ()
type Application = String
data AppPrompt
instance XMonad.Prompt.XPrompt XMonad.Prompt.AppLauncher.AppPrompt


-- | WorkspaceDir is an extension to set the current directory in a
--   workspace.
--   
--   Actually, it sets the current directory in a layout, since there's no
--   way I know of to attach a behavior to a workspace. This means that any
--   terminals (or other programs) pulled up in that workspace (with that
--   layout) will execute in that working directory. Sort of handy, I
--   think.
--   
--   Note this extension requires the <tt>directory</tt> package to be
--   installed.
module XMonad.Layout.WorkspaceDir
workspaceDir :: LayoutClass l a => String -> l a -> ModifiedLayout WorkspaceDir l a
changeDir :: XPConfig -> X ()
data WorkspaceDir a
newtype Chdir
Chdir :: String -> Chdir
instance GHC.Show.Show (XMonad.Layout.WorkspaceDir.WorkspaceDir a)
instance GHC.Read.Read (XMonad.Layout.WorkspaceDir.WorkspaceDir a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.WorkspaceDir.WorkspaceDir Graphics.X11.Types.Window
instance XMonad.Core.Message XMonad.Layout.WorkspaceDir.Chdir


-- | Functions for tagging windows and selecting them by tags.
module XMonad.Actions.TagWindows

-- | add a tag to the existing ones
addTag :: String -> Window -> X ()

-- | remove a tag from a window, if it exists
delTag :: String -> Window -> X ()

-- | remove all tags
unTag :: Window -> X ()

-- | set multiple tags for a window at once (overriding any previous tags)
setTags :: [String] -> Window -> X ()

-- | read all tags of a window reads from the "_XMONAD_TAGS" window
--   property
getTags :: Window -> X [String]

-- | check a window for the given tag
hasTag :: String -> Window -> X Bool

-- | apply a pure function to windows with a tag
withTaggedP :: String -> (Window -> WindowSet -> WindowSet) -> X ()

-- | apply a pure function to windows with a tag
withTaggedGlobalP :: String -> (Window -> WindowSet -> WindowSet) -> X ()
withFocusedP :: (Window -> WindowSet -> WindowSet) -> X ()
withTagged :: String -> (Window -> X ()) -> X ()
withTaggedGlobal :: String -> (Window -> X ()) -> X ()

-- | Move the focus in a group of windows, which share the same given tag.
--   The Global variants move through all workspaces, whereas the other
--   ones operate only on the current workspace
focusUpTagged :: String -> X ()

-- | Move the focus in a group of windows, which share the same given tag.
--   The Global variants move through all workspaces, whereas the other
--   ones operate only on the current workspace
focusUpTaggedGlobal :: String -> X ()

-- | Move the focus in a group of windows, which share the same given tag.
--   The Global variants move through all workspaces, whereas the other
--   ones operate only on the current workspace
focusDownTagged :: String -> X ()

-- | Move the focus in a group of windows, which share the same given tag.
--   The Global variants move through all workspaces, whereas the other
--   ones operate only on the current workspace
focusDownTaggedGlobal :: String -> X ()
shiftHere :: (Ord a, Eq s, Eq i) => a -> StackSet i l a s sd -> StackSet i l a s sd
shiftToScreen :: (Ord a, Eq s, Eq i) => s -> a -> StackSet i l a s sd -> StackSet i l a s sd
tagPrompt :: XPConfig -> (String -> X ()) -> X ()
tagDelPrompt :: XPConfig -> X ()
data TagPrompt
instance XMonad.Prompt.XPrompt XMonad.Actions.TagWindows.TagPrompt


-- | EDSL for specifying window properties; various utilities related to
--   window properties.
module XMonad.Util.WindowProperties

-- | Most of the property constructors are quite self-explaining.
data Property
Title :: String -> Property
ClassName :: String -> Property
Resource :: String -> Property

-- | WM_WINDOW_ROLE property
Role :: String -> Property

-- | WM_CLIENT_MACHINE property
Machine :: String -> Property
And :: Property -> Property -> Property
Or :: Property -> Property -> Property
Not :: Property -> Property
Const :: Bool -> Property

-- | Tagged via <a>XMonad.Actions.TagWindows</a>
Tagged :: String -> Property
infixr 9 `And`
infixr 8 `Or`

-- | Does given window have this property?
hasProperty :: Property -> Window -> X Bool

-- | Does the focused window have this property?
focusedHasProperty :: Property -> X Bool

-- | Find all existing windows with specified property
allWithProperty :: Property -> X [Window]

-- | Convert property to <a>Query</a> <a>Bool</a> (see
--   <a>XMonad.ManageHook</a>)
propertyToQuery :: Property -> Query Bool

-- | Get a window property from atom
getProp32 :: Atom -> Window -> X (Maybe [CLong])

-- | Get a window property from string
getProp32s :: String -> Window -> X (Maybe [CLong])
instance GHC.Show.Show XMonad.Util.WindowProperties.Property
instance GHC.Read.Read XMonad.Util.WindowProperties.Property


-- | This module implements a proper way of finding out whether the window
--   is remote or local.
--   
--   Just checking for a hostname and WM_CLIENT_MACHINE being equal is
--   often not enough because the hostname is a changing subject (without
--   any established notification mechanisms), and thus WM_CLIENT_MACHINE
--   and the hostname can diverge even for a local window.
--   
--   This module solves the problem. As soon as there is a new window
--   created, we check the hostname and WM_CLIENT_MACHINE, and then we
--   cache the result into the XMONAD_REMOTE property.
--   
--   Notice that XMonad itself does not know anything about hostnames, nor
--   does it have any dependency on Network.* modules. For this module it
--   is not a problem: you can provide a mean to get the hostname through
--   your config file (see usage). Or, if you don't like the hassle of
--   handling dynamic hostnames (suppose your hostname never changes), it
--   is also fine: this module will fallback to using environment
--   variables.
module XMonad.Util.RemoteWindows

-- | Given a window, tell if it is a local or a remote process. Normally,
--   it checks XMONAD_REMOTE property. If it does not exist (i.e. the
--   manageRemote hook was not deployed in user's config), it falls back to
--   checking environment variables and assuming that hostname never
--   changes.
isLocalWindow :: Window -> X Bool

-- | Use this hook to let XMonad properly track remote/local windows. For
--   example, <tt>manageHook = manageRemote =&lt;&lt; io getHostName</tt>.
manageRemote :: String -> ManageHook

-- | Use this hook if you want to manage XMONAD_REMOTE properties, but
--   don't want to use an external getHostName in your config. That way you
--   are retreating to environment variables.
manageRemoteG :: ManageHook


-- | This module implements a special kind of layout modifier, which when
--   applied to a layout, causes xmonad to stop all non-visible processes.
--   In a way, this is a sledge-hammer for applications that drain power.
--   For example, given a web browser on a stoppable workspace, once the
--   workspace is hidden the web browser will be stopped.
--   
--   Note that the stopped application won't be able to communicate with
--   X11 clipboard. For this, the module actually stops applications after
--   a certain delay, giving a chance for a user to complete copy-paste
--   sequence. By default, the delay equals to 15 seconds, it is
--   configurable via <a>Stoppable</a> constructor.
--   
--   The stoppable modifier prepends a mark (by default equals to
--   "Stoppable") to the layout description (alternatively, you can choose
--   your own mark and use it with <a>Stoppable</a> constructor). The
--   stoppable layout (identified by a mark) spans to multiple workspaces,
--   letting you to create groups of stoppable workspaces that only stop
--   processes when none of the workspaces are visible, and conversely,
--   unfreezing all processes even if one of the stoppable workspaces are
--   visible.
--   
--   To stop the process we use signals, which works for most cases. For
--   processes that tinker with signal handling (debuggers), another
--   (Linux-centric) approach may be used. See
--   <a>https://www.kernel.org/doc/Documentation/cgroups/freezer-subsystem.txt</a>
--   
--   <ul>
--   <li>Note This module doesn't work on programs that do fancy things
--   with processes (such as Chromium) and programs that do not set
--   _NET_WM_PID.</li>
--   </ul>
module XMonad.Layout.Stoppable

-- | Data type for ModifiedLayout. The constructor lets you to specify a
--   custom mark/description modifier and a delay. You can also use
--   <a>stoppable</a> helper function.
data Stoppable a
Stoppable :: String -> Rational -> Maybe TimerId -> Stoppable a
[mark] :: Stoppable a -> String
[delay] :: Stoppable a -> Rational
[timer] :: Stoppable a -> Maybe TimerId

-- | Convert a layout to a stoppable layout using the default mark
--   ("Stoppable") and a delay of 15 seconds.
stoppable :: l a -> ModifiedLayout Stoppable l a
instance GHC.Read.Read (XMonad.Layout.Stoppable.Stoppable a)
instance GHC.Show.Show (XMonad.Layout.Stoppable.Stoppable a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Stoppable.Stoppable Graphics.X11.Types.Window


-- | A <a>LayoutModifier</a> that sorts the windows in another layout,
--   given a list of properties. The order of properties in the list
--   determines the order of windows in the final layout. Any unmatched
--   windows go to the end of the order.
module XMonad.Layout.SortedLayout

-- | Modify a layout using a list of properties to sort its windows.
sorted :: [Property] -> l a -> ModifiedLayout SortedLayout l a

-- | Most of the property constructors are quite self-explaining.
data Property
Title :: String -> Property
ClassName :: String -> Property
Resource :: String -> Property

-- | WM_WINDOW_ROLE property
Role :: String -> Property

-- | WM_CLIENT_MACHINE property
Machine :: String -> Property
And :: Property -> Property -> Property
Or :: Property -> Property -> Property
Not :: Property -> Property
Const :: Bool -> Property

-- | Tagged via <a>XMonad.Actions.TagWindows</a>
Tagged :: String -> Property
infixr 9 `And`
infixr 8 `Or`
instance GHC.Read.Read XMonad.Layout.SortedLayout.WindowDescriptor
instance GHC.Show.Show XMonad.Layout.SortedLayout.WindowDescriptor
instance GHC.Read.Read (XMonad.Layout.SortedLayout.SortedLayout a)
instance GHC.Show.Show (XMonad.Layout.SortedLayout.SortedLayout a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.SortedLayout.SortedLayout Graphics.X11.Types.Window
instance GHC.Classes.Eq XMonad.Layout.SortedLayout.WindowDescriptor
instance GHC.Classes.Ord XMonad.Layout.SortedLayout.WindowDescriptor


-- | A layout combinator that sends a specified number of windows to one
--   rectangle and the rest to another. Each of these rectangles are given
--   a layout that is used within them. This can be chained to provide an
--   arbitrary number of rectangles. The layout combinator allows
--   overlapping rectangles, but such layouts does not work well together
--   with hinting (<a>XMonad.Layout.LayoutHints</a>,
--   <a>XMonad.Layout.HintedGrid</a> etc.)
module XMonad.Layout.LayoutBuilder

-- | Use the specified layout in the described area for N windows and send
--   the rest of the windows to the next layout in the chain. It is
--   possible to supply an alternative area that will then be used instead,
--   if there are no windows to send to the next layout.
layoutN :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a, LayoutClass l3 a) => Int -> SubBox -> Maybe SubBox -> l1 a -> LayoutB l2 l3 p a -> LayoutB l1 (LayoutB l2 l3 p) () a

-- | As layoutN, but the number of windows is given relative to the total
--   number of windows remaining to be handled. The first argument is how
--   much to change the ratio when using IncLayoutN, and the second is the
--   initial ratio.
layoutR :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a, LayoutClass l3 a) => Rational -> Rational -> SubBox -> Maybe SubBox -> l1 a -> LayoutB l2 l3 p a -> LayoutB l1 (LayoutB l2 l3 p) p a

-- | Use the specified layout in the described area windows that match
--   given predicate and send the rest of the windows to the next layout in
--   the chain. It is possible to supply an alternative area that will then
--   be used instead, if there are no windows to send to the next layout.
layoutP :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a, LayoutClass l3 a, Predicate p a, Predicate p' a) => p -> SubBox -> Maybe SubBox -> l1 a -> LayoutB l2 l3 p' a -> LayoutB l1 (LayoutB l2 l3 p') p a

-- | Use the specified layout in the described area for all remaining
--   windows.
layoutAll :: (Read a, Eq a, LayoutClass l1 a) => SubBox -> l1 a -> LayoutB l1 Full () a

-- | Type class for predicates. This enables us to manage not only Windows,
--   but any objects, for which instance Predicate is defined.
--   
--   Another instance exists in XMonad.Util.WindowPropertiesRE in
--   xmonad-extras
class Predicate p w
alwaysTrue :: Predicate p w => Proxy w -> p
checkPredicate :: Predicate p w => p -> w -> X Bool

-- | Contains no actual data, but is needed to help select the correct
--   instance of <a>Predicate</a>
data Proxy a
Proxy :: Proxy a

-- | Change the number of windows handled by the focused layout.
newtype IncLayoutN
IncLayoutN :: Int -> IncLayoutN

-- | The absolute or relative measures used to describe the area a layout
--   should be placed in. For negative absolute values the total remaining
--   space will be added. For sizes, the remaining space will also be added
--   for zeroes. Relative values are applied on the remaining space after
--   the top-left corner of the box have been removed.
data SubMeasure
Abs :: Int -> SubMeasure
Rel :: Rational -> SubMeasure

-- | A box to place a layout in. The stored values are xpos, ypos, width
--   and height.
data SubBox
SubBox :: SubMeasure -> SubMeasure -> SubMeasure -> SubMeasure -> SubBox

-- | Create a box with only absolute measurements. If the values are
--   negative, the total remaining space will be added. For sizes it will
--   also be added for zeroes.
absBox :: Int -> Int -> Int -> Int -> SubBox

-- | Create a box with only relative measurements.
relBox :: Rational -> Rational -> Rational -> Rational -> SubBox

-- | Use one layout in the specified area for a number of windows and
--   possibly let another layout handle the rest.
data LayoutB l1 l2 p a

-- | A variant of <a>LayoutB</a> that can't use <a>layoutP</a>. For
--   backwards compatibility with previous versions of LayoutBuilder.
type LayoutN l1 l2 a = LayoutB l1 l2 () a
instance GHC.Read.Read p => GHC.Read.Read (XMonad.Layout.LayoutBuilder.Limit p)
instance GHC.Show.Show p => GHC.Show.Show (XMonad.Layout.LayoutBuilder.Limit p)
instance GHC.Read.Read XMonad.Layout.LayoutBuilder.SubMeasure
instance GHC.Show.Show XMonad.Layout.LayoutBuilder.SubMeasure
instance GHC.Read.Read XMonad.Layout.LayoutBuilder.SubBox
instance GHC.Show.Show XMonad.Layout.LayoutBuilder.SubBox
instance (GHC.Read.Read a, GHC.Read.Read p, GHC.Read.Read (l1 a), GHC.Read.Read (l2 a)) => GHC.Read.Read (XMonad.Layout.LayoutBuilder.LayoutB l1 l2 p a)
instance (GHC.Show.Show a, GHC.Show.Show p, GHC.Show.Show (l1 a), GHC.Show.Show (l2 a)) => GHC.Show.Show (XMonad.Layout.LayoutBuilder.LayoutB l1 l2 p a)
instance (XMonad.Core.LayoutClass l1 a, XMonad.Core.LayoutClass l2 a, GHC.Read.Read a, GHC.Show.Show a, GHC.Show.Show p, Data.Typeable.Internal.Typeable p, GHC.Classes.Eq a, Data.Typeable.Internal.Typeable a, XMonad.Layout.LayoutBuilder.Predicate p a) => XMonad.Core.LayoutClass (XMonad.Layout.LayoutBuilder.LayoutB l1 l2 p) a
instance XMonad.Core.Message XMonad.Layout.LayoutBuilder.IncLayoutN
instance XMonad.Layout.LayoutBuilder.Predicate () a
instance XMonad.Layout.LayoutBuilder.Predicate XMonad.Util.WindowProperties.Property Graphics.X11.Types.Window


-- | Layout modfier suitable for workspace with multi-windowed instant
--   messenger (like Psi or Tkabber).
module XMonad.Layout.IM

-- | Most of the property constructors are quite self-explaining.
data Property
Title :: String -> Property
ClassName :: String -> Property
Resource :: String -> Property

-- | WM_WINDOW_ROLE property
Role :: String -> Property

-- | WM_CLIENT_MACHINE property
Machine :: String -> Property
And :: Property -> Property -> Property
Or :: Property -> Property -> Property
Not :: Property -> Property
Const :: Bool -> Property

-- | Tagged via <a>XMonad.Actions.TagWindows</a>
Tagged :: String -> Property
infixr 9 `And`
infixr 8 `Or`

-- | This is for compatibility with old configs only and will be removed in
--   future versions!
data IM a
IM :: Rational -> Property -> IM a

-- | Modifier which converts given layout to IM-layout (with dedicated
--   space for roster and original layout for chat windows)
withIM :: LayoutClass l a => Rational -> Property -> l a -> ModifiedLayout AddRoster l a

-- | IM layout modifier applied to the Grid layout
gridIM :: Rational -> Property -> ModifiedLayout AddRoster Grid a

-- | Data type for LayoutModifier which converts given layout to IM-layout
--   (with dedicated space for the roster and original layout for chat
--   windows)
data AddRoster a
instance GHC.Show.Show (XMonad.Layout.IM.AddRoster a)
instance GHC.Read.Read (XMonad.Layout.IM.AddRoster a)
instance GHC.Show.Show (XMonad.Layout.IM.IM a)
instance GHC.Read.Read (XMonad.Layout.IM.IM a)
instance XMonad.Core.LayoutClass XMonad.Layout.IM.IM Graphics.X11.Types.Window
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.IM.AddRoster Graphics.X11.Types.Window


-- | A layout modifier that puts some windows in a "drawer" which retracts
--   and expands depending on whether any window in it has focus.
--   
--   Useful for music players, tool palettes, etc.
module XMonad.Layout.Drawer

-- | Construct a drawer with a simple layout of the windows inside
simpleDrawer :: Rational -> Rational -> Property -> Drawer Tall a

-- | Construct a drawer with an arbitrary layout for windows inside
drawer :: Rational -> Rational -> Property -> l a -> Drawer l a
onLeft :: Drawer l a -> l' a -> ModifiedLayout (Drawer l) l' a
onTop :: Drawer l a -> l' a -> Mirror (ModifiedLayout (Drawer l) (Mirror l')) a
onRight :: Drawer l a -> l' a -> Reflected (ModifiedLayout (Drawer l) (Reflected l')) a
onBottom :: Drawer l a -> l' a -> Reflected (Mirror (ModifiedLayout (Drawer l) (Mirror (Reflected l')))) a
data Drawer l a
type Reflected l = ModifiedLayout Reflect l
instance GHC.Show.Show (l a) => GHC.Show.Show (XMonad.Layout.Drawer.Drawer l a)
instance GHC.Read.Read (l a) => GHC.Read.Read (XMonad.Layout.Drawer.Drawer l a)
instance (XMonad.Core.LayoutClass l Graphics.X11.Types.Window, GHC.Read.Read (l Graphics.X11.Types.Window)) => XMonad.Layout.LayoutModifier.LayoutModifier (XMonad.Layout.Drawer.Drawer l) Graphics.X11.Types.Window


-- | This module provides helper functions to be used in
--   <tt>manageHook</tt>. Here's how you might use this:
--   
--   <pre>
--   import XMonad.Hooks.ManageHelpers
--   main =
--       xmonad def{
--           ...
--           manageHook = composeOne [
--               isKDETrayWindow -?&gt; doIgnore,
--               transience,
--               isFullscreen -?&gt; doFullFloat,
--               resource =? "stalonetray" -?&gt; doIgnore
--           ],
--           ...
--       }
--   </pre>
--   
--   Here's how you can define more helpers like the ones from this module:
--   
--   <pre>
--   -- some function you want to transform into an infix operator
--   f :: a -&gt; b -&gt; Bool
--   
--   -- a new helper
--   q ***? x = fmap (\a -&gt; f a x) q   -- or: (\b -&gt; f x b)
--   -- or
--   q ***? x = fmap (`f` x) q         -- or: (x `f`)
--   </pre>
--   
--   Any existing operator can be "lifted" in the same way:
--   
--   <pre>
--   q ++? x = fmap (++ x) q
--   </pre>
module XMonad.Hooks.ManageHelpers

-- | Denotes a side of a screen. <tt>S</tt> stands for South, <tt>NE</tt>
--   for Northeast etc. <tt>C</tt> stands for Center.
data Side
SC :: Side
NC :: Side
CE :: Side
CW :: Side
SE :: Side
SW :: Side
NE :: Side
NW :: Side
C :: Side

-- | An alternative <a>ManageHook</a> composer. Unlike <a>composeAll</a> it
--   stops as soon as a candidate returns a <a>Just</a> value, effectively
--   running only the first match (whereas <a>composeAll</a> continues and
--   executes all matching rules).
composeOne :: (Monoid a, Monad m) => [m (Maybe a)] -> m a

-- | A helper operator for use in <a>composeOne</a>. It takes a condition
--   and an action; if the condition fails, it returns <a>Nothing</a> from
--   the <a>Query</a> so <a>composeOne</a> will go on and try the next
--   rule.
(-?>) :: (Functor m, Monad m) => m Bool -> m a -> m (Maybe a)
infixr 0 -?>

-- | q /=? x. if the result of q equals x, return False
(/=?) :: (Eq a, Functor m) => m a -> a -> m Bool

-- | q ^? x. if the result of <tt>x <a>isPrefixOf</a> q</tt>, return True
(^?) :: (Eq a, Functor m) => m [a] -> [a] -> m Bool

-- | q ~? x. if the result of <tt>x <a>isInfixOf</a> q</tt>, return True
(~?) :: (Eq a, Functor m) => m [a] -> [a] -> m Bool

-- | q $? x. if the result of <tt>x <a>isSuffixOf</a> q</tt>, return True
($?) :: (Eq a, Functor m) => m [a] -> [a] -> m Bool

-- | q &lt;==? x. if the result of q equals x, return True grouped with q
(<==?) :: (Eq a, Functor m) => m a -> a -> m (Match a)

-- | q &lt;/=? x. if the result of q notequals x, return True grouped with
--   q
(</=?) :: (Eq a, Functor m) => m a -> a -> m (Match a)

-- | A helper operator for use in <a>composeAll</a>. It takes a condition
--   and a function taking a grouped datum to action. If <tt>p</tt> is
--   true, it executes the resulting action.
(-->>) :: (Monoid b, Monad m) => m (Match a) -> (a -> m b) -> m b
infixr 0 -->>

-- | A helper operator for use in <a>composeOne</a>. It takes a condition
--   and a function taking a groupdatum to action. If <tt>p</tt> is true,
--   it executes the resulting action. If it fails, it returns
--   <a>Nothing</a> from the <a>Query</a> so <a>composeOne</a> will go on
--   and try the next rule.
(-?>>) :: (Functor m, Monad m) => m (Match a) -> (a -> m b) -> m (Maybe b)
infixr 0 -?>>

-- | Return the current workspace
currentWs :: Query WorkspaceId

-- | Return the workspace tag of a window, if already managed
windowTag :: Query (Maybe WorkspaceId)

-- | Helper to check if a window property contains certain value.
isInProperty :: String -> String -> Query Bool

-- | A predicate to check whether a window is a KDE system tray icon.
isKDETrayWindow :: Query Bool

-- | A predicate to check whether a window wants to fill the whole screen.
--   See also <a>doFullFloat</a>.
isFullscreen :: Query Bool

-- | A predicate to check whether a window is hidden (minimized). See also
--   <a>XMonad.Actions.Minimize</a>.
isMinimized :: Query Bool

-- | A predicate to check whether a window is a dialog.
--   
--   See
--   <a>https://specifications.freedesktop.org/wm-spec/wm-spec-1.5.html#idm46485863906176</a>.
isDialog :: Query Bool

-- | A predicate to check whether a window is a notification.
--   
--   See
--   <a>https://specifications.freedesktop.org/wm-spec/wm-spec-1.5.html#idm46485863906176</a>.
isNotification :: Query Bool

-- | This function returns <a>Just</a> the <tt>_NET_WM_PID</tt> property
--   for a particular window if set, <a>Nothing</a> otherwise.
--   
--   See
--   <a>https://specifications.freedesktop.org/wm-spec/wm-spec-1.5.html#idm45623487788432</a>.
pid :: Query (Maybe ProcessID)

-- | This function returns <a>Just</a> the <tt>_NET_WM_DESKTOP</tt>
--   property for a particular window if set, <a>Nothing</a> otherwise.
--   
--   See
--   <a>https://specifications.freedesktop.org/wm-spec/wm-spec-1.5.html#idm46181547492704</a>.
desktop :: Query (Maybe Int)

-- | A predicate to check whether a window is Transient. It holds the
--   result which might be the window it is transient to or it might be
--   <a>Nothing</a>.
transientTo :: Query (Maybe Window)

-- | converts <a>MaybeManageHook</a>s to <a>ManageHook</a>s
maybeToDefinite :: (Monoid a, Functor m) => m (Maybe a) -> m a

-- | A ManageHook that may or may not have been executed; the outcome is
--   embedded in the Maybe
type MaybeManageHook = Query (Maybe (Endo WindowSet))

-- | A convenience <a>MaybeManageHook</a> that will check to see if a
--   window is transient, and then move it to its parent.
transience :: MaybeManageHook

-- | <a>transience</a> set to a <a>ManageHook</a>
transience' :: ManageHook

-- | This function returns <a>Just</a> the <tt>WM_CLIENT_LEADER</tt>
--   property for a particular window if set, <a>Nothing</a> otherwise.
--   Note that, generally, the window ID returned from this property (by
--   firefox, for example) corresponds to an unmapped or unmanaged dummy
--   window. For this to be useful in most cases, it should be used
--   together with <a>sameBy</a>.
--   
--   See <a>https://tronche.com/gui/x/icccm/sec-5.html</a>.
clientLeader :: Query (Maybe Window)

-- | For a given window, <a>sameBy</a> returns all windows that have a
--   matching property (e.g. those obtained from Queries of
--   <a>clientLeader</a> and <a>pid</a>).
sameBy :: Eq prop => Query (Maybe prop) -> Query [Window]

-- | <a>MaybeManageHook</a> that moves the window to the same workspace as
--   the first other window that has the same value of a given
--   <a>Query</a>. Useful Queries for this include <a>clientLeader</a> and
--   <a>pid</a>.
shiftToSame :: Eq prop => Query (Maybe prop) -> MaybeManageHook

-- | <a>shiftToSame</a> set to a <a>ManageHook</a>
shiftToSame' :: Eq prop => Query (Maybe prop) -> ManageHook

-- | Floats the new window in the given rectangle.
doRectFloat :: RationalRect -> ManageHook

-- | Floats the window and makes it use the whole screen. Equivalent to
--   <tt><a>doRectFloat</a> $ <a>RationalRect</a> 0 0 1 1</tt>.
doFullFloat :: ManageHook

-- | Floats a new window with its original size, but centered.
doCenterFloat :: ManageHook

-- | Floats a new window with its original size on the specified side of a
--   screen
doSideFloat :: Side -> ManageHook

-- | Floats a new window with its original size, and its top left corner at
--   a specific point on the screen (both coordinates should be in the
--   range 0 to 1).
doFloatAt :: Rational -> Rational -> ManageHook

-- | Floats a new window using a rectangle computed as a function of the
--   rectangle that it would have used by default.
doFloatDep :: (RationalRect -> RationalRect) -> ManageHook

-- | Hides window and ignores it.
doHideIgnore :: ManageHook

-- | Sinks a window
doSink :: ManageHook

-- | Lower an unmanaged window. Useful together with <a>doIgnore</a> to
--   lower special windows that for some reason don't do it themselves.
doLower :: ManageHook

-- | Raise an unmanaged window. Useful together with <a>doIgnore</a> to
--   raise special windows that for some reason don't do it themselves.
doRaise :: ManageHook

-- | Focus a window (useful in <a>setActivateHook</a>).
doFocus :: ManageHook

-- | A grouping type, which can hold the outcome of a predicate Query. This
--   is analogous to group types in regular expressions. TODO: create a
--   better API for aggregating multiple Matches logically
data Match a
instance GHC.Classes.Eq XMonad.Hooks.ManageHelpers.Side
instance GHC.Show.Show XMonad.Hooks.ManageHelpers.Side
instance GHC.Read.Read XMonad.Hooks.ManageHelpers.Side


-- | Layout modifier for displaying some window (monitor) above other
--   windows.
module XMonad.Layout.Monitor
data Monitor a
Monitor :: Property -> Rectangle -> Bool -> String -> Bool -> Rational -> Monitor a

-- | property which uniquely identifies monitor window
[prop] :: Monitor a -> Property

-- | specifies where to put monitor
[rect] :: Monitor a -> Rectangle

-- | is it visible by default?
[visible] :: Monitor a -> Bool

-- | name of monitor (useful when we have many of them)
[name] :: Monitor a -> String

-- | is it shown on all layouts?
[persistent] :: Monitor a -> Bool

-- | opacity level
[opacity] :: Monitor a -> Rational

-- | Template for <a>Monitor</a> record. At least <a>prop</a> and
--   <a>rect</a> should be redefined. Default settings: <a>visible</a> is
--   <a>True</a>, <a>persistent</a> is <a>False</a>.
monitor :: Monitor a

-- | Most of the property constructors are quite self-explaining.
data Property
Title :: String -> Property
ClassName :: String -> Property
Resource :: String -> Property

-- | WM_WINDOW_ROLE property
Role :: String -> Property

-- | WM_CLIENT_MACHINE property
Machine :: String -> Property
And :: Property -> Property -> Property
Or :: Property -> Property -> Property
Not :: Property -> Property
Const :: Bool -> Property

-- | Tagged via <a>XMonad.Actions.TagWindows</a>
Tagged :: String -> Property
infixr 9 `And`
infixr 8 `Or`

-- | Messages without names affect all monitors. Messages with names affect
--   only monitors whose names match.
data MonitorMessage
ToggleMonitor :: MonitorMessage
ShowMonitor :: MonitorMessage
HideMonitor :: MonitorMessage
ToggleMonitorNamed :: String -> MonitorMessage
ShowMonitorNamed :: String -> MonitorMessage
HideMonitorNamed :: String -> MonitorMessage

-- | Hides window and ignores it.
doHideIgnore :: ManageHook

-- | ManageHook which demanages monitor window and applies opacity
--   settings.
manageMonitor :: Monitor a -> ManageHook
instance GHC.Show.Show (XMonad.Layout.Monitor.Monitor a)
instance GHC.Read.Read (XMonad.Layout.Monitor.Monitor a)
instance GHC.Classes.Eq XMonad.Layout.Monitor.MonitorMessage
instance GHC.Show.Show XMonad.Layout.Monitor.MonitorMessage
instance GHC.Read.Read XMonad.Layout.Monitor.MonitorMessage
instance XMonad.Core.Message XMonad.Layout.Monitor.MonitorMessage
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Monitor.Monitor Graphics.X11.Types.Window


-- | UrgencyHook lets you configure an action to occur when a window
--   demands your attention. (In traditional WMs, this takes the form of
--   "flashing" on your "taskbar." Blech.)
module XMonad.Hooks.UrgencyHook

-- | This is the method to enable an urgency hook. It uses the default
--   <a>urgencyConfig</a> to control behavior. To change this, use
--   <a>withUrgencyHookC</a> instead.
withUrgencyHook :: (LayoutClass l Window, UrgencyHook h) => h -> XConfig l -> XConfig l

-- | This lets you modify the defaults set in <a>urgencyConfig</a>. An
--   example:
--   
--   <pre>
--   withUrgencyHookC dzenUrgencyHook { ... } def { suppressWhen = Focused }
--   </pre>
--   
--   (Don't type the <tt>...</tt>, you dolt.) See <a>UrgencyConfig</a> for
--   details on configuration.
withUrgencyHookC :: (LayoutClass l Window, UrgencyHook h) => h -> UrgencyConfig -> XConfig l -> XConfig l

-- | Global configuration, applied to all types of <a>UrgencyHook</a>. See
--   <a>urgencyConfig</a> for the defaults.
data UrgencyConfig
UrgencyConfig :: SuppressWhen -> RemindWhen -> UrgencyConfig

-- | when to trigger the urgency hook
[suppressWhen] :: UrgencyConfig -> SuppressWhen

-- | when to re-trigger the urgency hook
[remindWhen] :: UrgencyConfig -> RemindWhen

-- | The default <a>UrgencyConfig</a>: <tt>urgencyConfig = <a>def</a></tt>.

-- | <i>Deprecated: Use def insetad.</i>
urgencyConfig :: UrgencyConfig

-- | A set of choices as to <i>when</i> you should (or rather, shouldn't)
--   be notified of an urgent window. The default is <a>Visible</a>. Prefix
--   each of the following with "don't bug me when":
data SuppressWhen

-- | the window is currently visible
Visible :: SuppressWhen

-- | the window is on the currently focused physical screen
OnScreen :: SuppressWhen

-- | the window is currently focused
Focused :: SuppressWhen

-- | ... aww, heck, go ahead and bug me, just in case.
Never :: SuppressWhen

-- | A set of choices as to when you want to be re-notified of an urgent
--   window. Perhaps you focused on something and you miss the dzen popup
--   bar. Or you're AFK. Or you feel the need to be more distracted. I
--   don't care.
--   
--   The interval arguments are in seconds. See the <a>minutes</a> helper.
data RemindWhen

-- | triggering once is enough
Dont :: RemindWhen

-- | repeat &lt;arg1&gt; times every &lt;arg2&gt; seconds
Repeatedly :: Int -> Interval -> RemindWhen

-- | repeat every &lt;arg1&gt; until the urgency hint is cleared
Every :: Interval -> RemindWhen

-- | Focuses the most recently urgent window. Good for what ails ya -- I
--   mean, your keybindings. Example keybinding:
--   
--   <pre>
--   , ((modm              , xK_BackSpace), focusUrgent)
--   </pre>
focusUrgent :: X ()

-- | Just makes the urgents go away. Example keybinding:
--   
--   <pre>
--   , ((modm .|. shiftMask, xK_BackSpace), clearUrgents)
--   </pre>
clearUrgents :: X ()

-- | Flashes when a window requests your attention and you can't see it.
--   Defaults to a duration of five seconds, and no extra args to dzen. See
--   <a>DzenUrgencyHook</a>.
dzenUrgencyHook :: DzenUrgencyHook

-- | Your set of options for configuring a dzenUrgencyHook.
data DzenUrgencyHook
DzenUrgencyHook :: Int -> [String] -> DzenUrgencyHook

-- | number of microseconds to display the dzen (hence, you'll probably
--   want to use <a>seconds</a>)
[duration] :: DzenUrgencyHook -> Int

-- | list of extra args (as <a>String</a>s) to pass to dzen
[args] :: DzenUrgencyHook -> [String]
data NoUrgencyHook
NoUrgencyHook :: NoUrgencyHook
newtype BorderUrgencyHook
BorderUrgencyHook :: String -> BorderUrgencyHook
[urgencyBorderColor] :: BorderUrgencyHook -> String
data FocusHook
FocusHook :: FocusHook

-- | urgencyhook such that windows on certain workspaces never get urgency
--   set.
--   
--   Useful for scratchpad workspaces perhaps:
--   
--   <pre>
--   main = xmonad (withUrgencyHook (filterUrgencyHook ["NSP", "SP"]) def)
--   </pre>
filterUrgencyHook :: [WorkspaceId] -> Window -> X ()

-- | <a>filterUrgencyHook</a> that takes a generic <a>Query</a> to select
--   which windows should never be marked urgent.
filterUrgencyHook' :: Query Bool -> Window -> X ()

-- | A prettified way of multiplying by 60. Use like: <tt>(5
--   <a>minutes</a>)</tt>.
minutes :: Rational -> Rational

-- | Multiplies by ONE MILLION, for functions that take microseconds.
--   
--   Use like:
--   
--   <pre>
--   (5.5 `seconds`)
--   </pre>
--   
--   In GHC 7 and later, you must either enable the PostfixOperators
--   extension (by adding
--   
--   <pre>
--   {-# LANGUAGE PostfixOperators #-}
--   </pre>
--   
--   to the top of your file) or use seconds in prefix form:
--   
--   <pre>
--   seconds 5.5
--   </pre>
seconds :: Rational -> Int

-- | Mark the given window urgent.
--   
--   (The implementation is a bit hacky: send a _NET_WM_STATE ClientMessage
--   to ourselves. This is so that we respect the <a>SuppressWhen</a> of
--   the configured urgency hooks. If this module if ever migrated to the
--   ExtensibleConf infrastrcture, we'll then invoke markUrgent directly.)
askUrgent :: Window -> X ()

-- | Helper for <a>ManageHook</a> that marks the window as urgent (unless
--   suppressed, see <a>SuppressWhen</a>). Useful in
--   <a>setEwmhActivateHook</a> and also in combination with
--   <a>XMonad.Hooks.InsertPosition</a>, <a>XMonad.Hooks.Focus</a>.
doAskUrgent :: ManageHook

-- | X action that returns a list of currently urgent windows. You might
--   use it, or <a>withUrgents</a>, in your custom logHook, to display the
--   workspaces that contain urgent windows.
readUrgents :: X [Window]

-- | An HOF version of <a>readUrgents</a>, for those who prefer that sort
--   of thing.
withUrgents :: ([Window] -> X a) -> X a

-- | Clear urgency status of selected windows.
clearUrgents' :: [Window] -> X ()
data StdoutUrgencyHook
StdoutUrgencyHook :: StdoutUrgencyHook
newtype SpawnUrgencyHook
SpawnUrgencyHook :: String -> SpawnUrgencyHook

-- | The class definition, and some pre-defined instances.
class UrgencyHook h
urgencyHook :: UrgencyHook h => h -> Window -> X ()
type Interval = Rational

-- | A hook that sets the border color of an urgent window. The color will
--   remain until the next time the window gains or loses focus, at which
--   point the standard border color from the XConfig will be applied. You
--   may want to use suppressWhen = Never with this:
--   
--   <pre>
--   withUrgencyHookC BorderUrgencyHook { urgencyBorderColor = "#ff0000" } urgencyConfig { suppressWhen = Never } ...
--   </pre>
--   
--   (This should be <tt>urgentBorderColor</tt> but that breaks
--   <a>XMonad.Layout.Decoration</a>. <tt>borderColor</tt> breaks anyone
--   using <tt>XPConfig</tt> from <a>XMonad.Prompt</a>. We need to think a
--   bit more about namespacing issues, maybe.)
borderUrgencyHook :: String -> Window -> X ()

-- | A hook which will automatically send you to anything which sets the
--   urgent flag (as opposed to printing some sort of message. You would
--   use this as usual, eg.
--   
--   <pre>
--   withUrgencyHook FocusHook $ myconfig { ...
--   </pre>
focusHook :: Window -> X ()

-- | Spawn a commandline thing, appending the window id to the prefix
--   string you provide. (Make sure to add a space if you need it.) Do your
--   crazy xcompmgr thing.
spawnUrgencyHook :: String -> Window -> X ()

-- | For debugging purposes, really.
stdoutUrgencyHook :: Window -> X ()
instance GHC.Show.Show XMonad.Hooks.UrgencyHook.Urgents
instance GHC.Read.Read XMonad.Hooks.UrgencyHook.Urgents
instance GHC.Show.Show XMonad.Hooks.UrgencyHook.SuppressWhen
instance GHC.Read.Read XMonad.Hooks.UrgencyHook.SuppressWhen
instance GHC.Show.Show XMonad.Hooks.UrgencyHook.RemindWhen
instance GHC.Read.Read XMonad.Hooks.UrgencyHook.RemindWhen
instance GHC.Show.Show XMonad.Hooks.UrgencyHook.UrgencyConfig
instance GHC.Read.Read XMonad.Hooks.UrgencyHook.UrgencyConfig
instance GHC.Classes.Eq XMonad.Hooks.UrgencyHook.Reminder
instance GHC.Read.Read XMonad.Hooks.UrgencyHook.Reminder
instance GHC.Show.Show XMonad.Hooks.UrgencyHook.Reminder
instance GHC.Show.Show h => GHC.Show.Show (XMonad.Hooks.UrgencyHook.WithUrgencyHook h)
instance GHC.Read.Read h => GHC.Read.Read (XMonad.Hooks.UrgencyHook.WithUrgencyHook h)
instance GHC.Show.Show XMonad.Hooks.UrgencyHook.NoUrgencyHook
instance GHC.Read.Read XMonad.Hooks.UrgencyHook.NoUrgencyHook
instance GHC.Show.Show XMonad.Hooks.UrgencyHook.DzenUrgencyHook
instance GHC.Read.Read XMonad.Hooks.UrgencyHook.DzenUrgencyHook
instance GHC.Show.Show XMonad.Hooks.UrgencyHook.FocusHook
instance GHC.Read.Read XMonad.Hooks.UrgencyHook.FocusHook
instance GHC.Show.Show XMonad.Hooks.UrgencyHook.BorderUrgencyHook
instance GHC.Read.Read XMonad.Hooks.UrgencyHook.BorderUrgencyHook
instance GHC.Show.Show XMonad.Hooks.UrgencyHook.SpawnUrgencyHook
instance GHC.Read.Read XMonad.Hooks.UrgencyHook.SpawnUrgencyHook
instance GHC.Show.Show XMonad.Hooks.UrgencyHook.StdoutUrgencyHook
instance GHC.Read.Read XMonad.Hooks.UrgencyHook.StdoutUrgencyHook
instance XMonad.Hooks.UrgencyHook.UrgencyHook XMonad.Hooks.UrgencyHook.StdoutUrgencyHook
instance XMonad.Hooks.UrgencyHook.UrgencyHook XMonad.Hooks.UrgencyHook.SpawnUrgencyHook
instance XMonad.Hooks.UrgencyHook.UrgencyHook XMonad.Hooks.UrgencyHook.BorderUrgencyHook
instance XMonad.Hooks.UrgencyHook.UrgencyHook XMonad.Hooks.UrgencyHook.FocusHook
instance XMonad.Hooks.UrgencyHook.UrgencyHook XMonad.Hooks.UrgencyHook.DzenUrgencyHook
instance Data.Default.Class.Default XMonad.Hooks.UrgencyHook.DzenUrgencyHook
instance XMonad.Hooks.UrgencyHook.UrgencyHook XMonad.Hooks.UrgencyHook.NoUrgencyHook
instance XMonad.Hooks.UrgencyHook.UrgencyHook (Graphics.X11.Types.Window -> XMonad.Core.X ())
instance XMonad.Core.ExtensionClass [XMonad.Hooks.UrgencyHook.Reminder]
instance Data.Default.Class.Default XMonad.Hooks.UrgencyHook.UrgencyConfig
instance XMonad.Core.ExtensionClass XMonad.Hooks.UrgencyHook.Urgents


-- | xmonad calls the logHook with every internal state update, which is
--   useful for (among other things) outputting status information to an
--   external status bar program such as xmobar or dzen.
--   
--   This module provides a pretty-printing abstraction and utilities that
--   can be used to customize what is logged to a status bar. See
--   <a>XMonad.Hooks.StatusBar</a> for an abstraction over starting these
--   status bars. Together these are a modern replacement for
--   <a>XMonad.Hooks.DynamicLog</a>, which is now just a compatibility
--   wrapper.
module XMonad.Hooks.StatusBar.PP

-- | The <a>PP</a> type allows the user to customize the formatting of
--   status information.
data PP
PP :: (WorkspaceId -> String) -> (WorkspaceId -> String) -> (WorkspaceId -> String) -> (WorkspaceId -> String) -> Maybe (WorkspaceId -> String) -> (WorkspaceId -> String) -> (String -> WindowSpace -> String) -> String -> String -> (String -> String) -> (String -> String) -> (String -> String) -> ([String] -> [String]) -> X ([WindowSpace] -> [WindowSpace]) -> [X (Maybe String)] -> (String -> IO ()) -> WSPP -> PP

-- | how to print the tag of the currently focused workspace
[ppCurrent] :: PP -> WorkspaceId -> String

-- | how to print tags of visible but not focused workspaces (xinerama
--   only)
[ppVisible] :: PP -> WorkspaceId -> String

-- | how to print tags of hidden workspaces which contain windows
[ppHidden] :: PP -> WorkspaceId -> String

-- | how to print tags of empty hidden workspaces
[ppHiddenNoWindows] :: PP -> WorkspaceId -> String

-- | how to print tags of empty visible workspaces
[ppVisibleNoWindows] :: PP -> Maybe (WorkspaceId -> String)

-- | format to be applied to tags of urgent workspaces.
[ppUrgent] :: PP -> WorkspaceId -> String

-- | rename/augment the workspace tag (note that <tt>WindowSpace -&gt;
--   …</tt> acts as a Reader monad)
[ppRename] :: PP -> String -> WindowSpace -> String

-- | separator to use between different log sections (window name, layout,
--   workspaces)
[ppSep] :: PP -> String

-- | separator to use between workspace tags
[ppWsSep] :: PP -> String

-- | window title format for the focused window. To display the titles of
--   all windows—even unfocused ones—check <a>logTitles</a>.
[ppTitle] :: PP -> String -> String

-- | escape / sanitizes input to <a>ppTitle</a>
[ppTitleSanitize] :: PP -> String -> String

-- | layout name format
[ppLayout] :: PP -> String -> String

-- | how to order the different log sections. By default, this function
--   receives a list with three formatted strings, representing the
--   workspaces, the layout, and the current window titles, respectively.
--   If you have specified any extra loggers in <a>ppExtras</a>, their
--   output will also be appended to the list. To get them in the reverse
--   order, you can just use <tt>ppOrder = reverse</tt>. If you don't want
--   to display the current layout, you could use something like
--   <tt>ppOrder = \(ws:_:t:_) -&gt; [ws,t]</tt>, and so on.
[ppOrder] :: PP -> [String] -> [String]

-- | how to sort the workspaces. See <a>XMonad.Util.WorkspaceCompare</a>
--   for some useful sorts.
[ppSort] :: PP -> X ([WindowSpace] -> [WindowSpace])

-- | loggers for generating extra information such as time and date, system
--   load, battery status, and so on. See <a>XMonad.Util.Loggers</a> for
--   examples, or create your own!
[ppExtras] :: PP -> [X (Maybe String)]

-- | applied to the entire formatted string in order to output it. Can be
--   used to specify an alternative output method (e.g. write to a pipe
--   instead of stdout), and/or to perform some last-minute formatting.
--   Note that this is only used by <a>dynamicLogWithPP</a>; it won't work
--   with <a>dynamicLogString</a> or <a>XMonad.Hooks.StatusBar</a>.
[ppOutput] :: PP -> String -> IO ()

-- | extend workspace types with custom predicates. Check $predicates for
--   more details.
[ppPrinters] :: PP -> WSPP

-- | The default value for this type.
def :: Default a => a

-- | The same as <a>dynamicLogWithPP</a>, except it simply returns the
--   status as a formatted string without actually printing it to stdout,
--   to allow for further processing, or use in some application other than
--   a status bar.
dynamicLogString :: PP -> X String

-- | The guts of <a>dynamicLogString</a>. Forces the result, so it may
--   throw an exception (most commonly because <a>ppOrder</a> is
--   non-total). Use <a>dynamicLogString</a> for a version that catches the
--   exception and produces an error string.
dynamicLogString' :: PP -> X String

-- | Format the current status using the supplied pretty-printing format,
--   and write it to stdout.
dynamicLogWithPP :: PP -> X ()

-- | The data available to <a>WSPP'</a>.
data WS
WS :: [Window] -> WindowSet -> WindowSpace -> PP -> WS

-- | Urgent windows
[wsUrgents] :: WS -> [Window]

-- | The entire <a>WindowSet</a>, for context
[wsWindowSet] :: WS -> WindowSet

-- | The <a>WindowSpace</a> being formatted
[wsWS] :: WS -> WindowSpace

-- | The actual final <a>PP</a>
[wsPP] :: WS -> PP

-- | The type allowing to build formatters (and predicates). See the source
--   <a>fallbackPrinters</a> for an example.
type WSPP = WSPP' (WorkspaceId -> String)
type WSPP' = ReaderT WS Maybe

-- | For a <a>PP</a> <tt>pp</tt>, <tt>fallbackPrinters pp</tt> returns the
--   default <a>WSPP</a> used to format workspaces: the formatter chosen
--   corresponds to the first matching workspace type, respecting the
--   following precedence: <a>ppUrgent</a>, <a>ppCurrent</a>,
--   <a>ppVisible</a>, <a>ppVisibleNoWindows</a>, <a>ppHidden</a>,
--   <a>ppHiddenNoWindows</a>.
--   
--   This can be useful if one needs to use the default set of formatters
--   and post-process their output. (For pre-processing their input,
--   there's <a>ppRename</a>.)
fallbackPrinters :: WSPP

-- | Predicate for urgent workspaces.
isUrgent :: WS -> Bool

-- | Predicate for the current workspace.
isCurrent :: WS -> Bool

-- | Predicate for visible workspaces.
isVisible :: WS -> Bool

-- | Predicate for visible workspaces that have no windows.
isVisibleNoWindows :: WS -> Bool

-- | Predicate for hidden workspaces.
isHidden :: WS -> Bool

-- | Settings to emulate dwm's statusbar, dzen only.
dzenPP :: PP

-- | Some nice xmobar defaults.
xmobarPP :: PP

-- | The options that sjanssen likes to use with xmobar, as an example.
--   Note the use of <a>xmobarColor</a> and the record update on
--   <a>def</a>.
sjanssenPP :: PP

-- | The options that byorgey likes to use with dzen, as another example.
byorgeyPP :: PP

-- | Wrap a string in delimiters, unless it is empty.
wrap :: String -> String -> String -> String

-- | Pad a string with a leading and trailing space.
pad :: String -> String

-- | Trim leading and trailing whitespace from a string.
trim :: String -> String

-- | Limit a string to a certain length, adding "..." if truncated.
shorten :: Int -> String -> String

-- | Limit a string to a certain length, adding <tt>end</tt> if truncated.
shorten' :: String -> Int -> String -> String

-- | Like <a>shorten</a>, but truncate from the left instead of right.
shortenLeft :: Int -> String -> String

-- | Like <a>shorten'</a>, but truncate from the left instead of right.
shortenLeft' :: String -> Int -> String -> String

-- | Use xmobar escape codes to output a string with given foreground and
--   background colors.
xmobarColor :: String -> String -> String -> String

-- | Use xmobar escape codes to output a string with the font at the given
--   index
xmobarFont :: Int -> String -> String

-- | Encapsulate text with an action. The text will be displayed, and the
--   action executed when the displayed text is clicked. Illegal input is
--   not filtered, allowing xmobar to display any parse errors. Uses
--   xmobar's new syntax wherein the command is surrounded by backticks.
xmobarAction :: String -> String -> String -> String

-- | Use xmobar box to add a border to an arbitrary string.
xmobarBorder :: String -> String -> Int -> String -> String

-- | Encapsulate arbitrary text for display only, i.e. untrusted content if
--   wrapped (perhaps from window titles) will be displayed only, with all
--   tags ignored. Introduced in xmobar 0.21; see their documentation. Be
--   careful not to shorten the result.
xmobarRaw :: String -> String

-- | Strip xmobar markup, specifically the &lt;fc&gt;, &lt;icon&gt; and
--   &lt;action&gt; tags and the matching tags like &lt;/fc&gt;.
xmobarStrip :: String -> String
xmobarStripTags :: [String] -> String -> String

-- | Use dzen escape codes to output a string with given foreground and
--   background colors.
dzenColor :: String -> String -> String -> String

-- | Escape any dzen metacharacters.
dzenEscape :: String -> String

-- | Strip dzen formatting or commands.
dzenStrip :: String -> String

-- | Transforms a pretty-printer into one not displaying the given
--   workspaces.
--   
--   For example, filtering out the <tt>NSP</tt> workspace before giving
--   the <a>PP</a> to <a>dynamicLogWithPP</a>:
--   
--   <pre>
--   logHook = dynamicLogWithPP . filterOutWsPP [scratchpadWorkspaceTag] $ def
--   </pre>
--   
--   Here is another example, when using
--   <a>XMonad.Layout.IndependentScreens</a>. If you have handles
--   <tt>hLeft</tt> and <tt>hRight</tt> for bars on the left and right
--   screens, respectively, and <tt>pp</tt> is a pretty-printer function
--   that takes a handle, you could write
--   
--   <pre>
--   logHook = let log screen handle = dynamicLogWithPP . filterOutWsPP [scratchpadWorkspaceTag] . marshallPP screen . pp $ handle
--             in log 0 hLeft &gt;&gt; log 1 hRight
--   </pre>
filterOutWsPP :: [WorkspaceId] -> PP -> PP

-- | Format the workspace information, given a workspace sorting function,
--   a list of urgent windows, a pretty-printer format, and the current
--   WindowSet.
pprWindowSet :: WorkspaceSort -> [Window] -> PP -> WindowSet -> String
pprWindowSetXinerama :: WindowSet -> String
instance Data.Default.Class.Default XMonad.Hooks.StatusBar.PP.PP


-- | A collection of simple logger functions and formatting utilities which
--   can be used in the <a>ppExtras</a> field of a pretty-printing status
--   logger format. See <a>XMonad.Hooks.StatusBar.PP</a> for more
--   information.
module XMonad.Util.Loggers

-- | <a>Logger</a> is just a convenient synonym for <tt>X (Maybe
--   String)</tt>.
type Logger = X (Maybe String)

-- | Get the current volume with <tt>aumix</tt>.
--   <a>http://jpj.net/~trevor/aumix.html</a>
aumixVolume :: Logger

-- | Get the battery status (percent charge and charging/discharging
--   status). This is an ugly hack and may not work for some people. At
--   some point it would be nice to make this more general/have fewer
--   dependencies (assumes <tt>acpi</tt> and <tt>sed</tt> are installed.)
battery :: Logger

-- | Get the current date and time, and format them via the given format
--   string. The format used is the same as that used by the C library
--   function strftime; for example, <tt>date "%a %b %d"</tt> might display
--   something like <tt>Tue Feb 19</tt>. For more information see something
--   like
--   <a>http://www.cplusplus.com/reference/clibrary/ctime/strftime.html</a>.
date :: String -> Logger

-- | Get the load average. This assumes that you have a utility called
--   <tt>uptime</tt> and that you have <tt>sed</tt> installed; these are
--   fairly common on GNU/Linux systems but it would be nice to make this
--   more general.
loadAvg :: Logger

-- | Get a count of new mails in a maildir.
maildirNew :: FilePath -> Logger

-- | Get a count of unread mails in a maildir. For maildir format details,
--   to write loggers for other classes of mail, see
--   <a>http://cr.yp.to/proto/maildir.html</a> and <a>logFileCount</a>.
maildirUnread :: FilePath -> Logger

-- | Create a <a>Logger</a> from an arbitrary shell command.
logCmd :: String -> Logger

-- | Get a count of filtered files in a directory. See <a>maildirUnread</a>
--   and <a>maildirNew</a> source for usage examples.
logFileCount :: FilePath -> (String -> Bool) -> Logger

-- | Get the name of the current workspace.
logCurrent :: Logger

-- | Get the name of the current layout.
logLayout :: Logger

-- | Get the title (name) of the focused window.
logTitle :: Logger

-- | Like <a>logTitlesOnScreen</a>, but directly use the "focused" screen
--   (the one with the currently focused workspace).
logTitles :: (String -> String) -> (String -> String) -> Logger

-- | Variant of <a>logTitles</a>, but with support for urgent windows.
logTitles' :: TitlesFormat -> Logger

-- | Get the classname of the focused window.
logClassname :: Logger

-- | Like <a>logClassnamesOnScreen</a>, but directly use the "focused"
--   screen (the one with the currently focused workspace).
logClassnames :: (String -> String) -> (String -> String) -> Logger

-- | Variant of <a>logClassnames</a>, but with support for urgent windows.
logClassnames' :: ClassnamesFormat -> Logger

-- | Log the given string, as is.
logConst :: String -> Logger

-- | If the first logger returns <tt>Nothing</tt>, the default logger is
--   used. For example, to display a quote when no windows are on the
--   screen, you can do:
--   
--   <pre>
--   logDefault logTitle (logConst "Hey, you, you're finally awake.")
--   </pre>
logDefault :: Logger -> Logger -> Logger

-- | An infix operator for <a>logDefault</a>, which can be more convenient
--   to combine multiple loggers.
--   
--   <pre>
--   logTitle .| logWhenActive 0 (logConst "*") .| logConst "There's nothing here"
--   </pre>
(.|) :: Logger -> Logger -> Logger

-- | Get the name of the visible workspace on the given screen.
logCurrentOnScreen :: ScreenId -> Logger

-- | Get the name of the current layout on the given screen.
logLayoutOnScreen :: ScreenId -> Logger

-- | Get the title (name) of the focused window, on the given screen.
logTitleOnScreen :: ScreenId -> Logger

-- | Get the classname of the focused window, on the given screen.
logClassnameOnScreen :: ScreenId -> Logger

-- | Only display the <a>Logger</a> if the screen with the given
--   <a>ScreenId</a> is active. For example, this can be used to create a
--   marker that is only displayed when the primary screen is active.
--   
--   <pre>
--   logWhenActive 0 (logConst "*")
--   </pre>
logWhenActive :: ScreenId -> Logger -> Logger

-- | Get the titles of all windows on the visible workspace of the given
--   screen and format them according to the given functions.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   myXmobarPP :: X PP
--   myXmobarPP = pure $ def
--     { ppOrder  = [ws, l, _, wins] -&gt; [ws, l, wins]
--     , ppExtras = [logTitles formatFocused formatUnfocused]
--     }
--    where
--     formatFocused   = wrap "[" "]" . xmobarColor "#ff79c6" "" . shorten 50 . xmobarStrip
--     formatUnfocused = wrap "(" ")" . xmobarColor "#bd93f9" "" . shorten 30 . xmobarStrip
--   </pre>
logTitlesOnScreen :: ScreenId -> (String -> String) -> (String -> String) -> Logger

-- | Like <a>logTitlesOnScreen</a> but with support for urgent windows. To
--   be used with <a>XMonad.Hooks.UrgencyHook</a>.
logTitlesOnScreen' :: ScreenId -> TitlesFormat -> Logger

-- | Get the classnames of all windows on the visible workspace of the
--   given screen and format them according to the given functions.
logClassnamesOnScreen :: ScreenId -> (String -> String) -> (String -> String) -> Logger

-- | Like <a>logClassnamesOnScreen</a> but with support for urgent windows.
--   To be used with <a>XMonad.Hooks.UrgencyHook</a>.
logClassnamesOnScreen' :: ScreenId -> ClassnamesFormat -> Logger

-- | Formatting applied to the titles of certain windows.
data TitlesFormat
TitlesFormat :: (String -> String) -> (String -> String) -> (String -> String) -> TitlesFormat

-- | Focused formatting.
[focusedFormat] :: TitlesFormat -> String -> String

-- | Unfocused formatting.
[unfocusedFormat] :: TitlesFormat -> String -> String

-- | Formatting when urgent.
[urgentFormat] :: TitlesFormat -> String -> String

-- | Formatting applied to the classnames of certain windows.
data ClassnamesFormat
ClassnamesFormat :: (String -> String) -> (String -> String) -> (String -> String) -> ClassnamesFormat

-- | Focused formatting.
[focusedFormatClassname] :: ClassnamesFormat -> String -> String

-- | Unfocused formatting.
[unfocusedFormatClassname] :: ClassnamesFormat -> String -> String

-- | Formatting when urgent.
[urgentFormatClassname] :: ClassnamesFormat -> String -> String

-- | Use a string formatting function to edit a <a>Logger</a> string. For
--   example, to create a tag function to prefix or label loggers, as in
--   'tag: output', use:
--   
--   <pre>
--   tagL l = onLogger $ wrap (l ++ ": ") ""
--   
--      tagL "bat" battery
--      tagL "load" loadAvg
--   </pre>
--   
--   If you already have a (String -&gt; String) function you want to apply
--   to a logger:
--   
--   <pre>
--   revL = onLogger trim
--   </pre>
--   
--   See formatting utility source code for more <a>onLogger</a> usage
--   examples.
onLogger :: (String -> String) -> Logger -> Logger

-- | Wrap a logger's output in delimiters, unless it is <tt>X
--   (Nothing)</tt> or <tt>X (Just "")</tt>. Some examples:
--   
--   <pre>
--   wrapL " | " " | " (date "%a %d %b") -- ' | Tue 19 Feb | '
--   
--   wrapL "bat: " "" battery            -- ' bat: battery_logger_output'
--   </pre>
wrapL :: String -> String -> Logger -> Logger

-- | Make a logger's output constant width by padding with the given
--   string, <i>even if the logger is</i> <tt>X (Nothing)</tt> <i>or</i>
--   <tt>X (Just "")</tt>. Useful to reduce visual noise as a title logger
--   shrinks and grows, to use a fixed width for a logger that sometimes
--   becomes Nothing, or even to create fancy spacers or character based
--   art effects.
--   
--   It fills missing logger output with a repeated character like ".", ":"
--   or pattern, like " -.-". The cycling padding string is reversed on the
--   left of the logger output. This is mainly useful with AlignCenter.
fixedWidthL :: Align -> String -> Int -> Logger -> Logger

-- | Create a "spacer" logger, e.g. <tt>logSp 3 -- loggerizes ' '</tt>. For
--   more complex "spacers", use <a>fixedWidthL</a> with <tt>return
--   Nothing</tt>.
logSp :: Int -> Logger

-- | Pad a logger's output with a leading and trailing space, unless it is
--   <tt>X (Nothing)</tt> or <tt>X (Just "")</tt>.
padL :: Logger -> Logger

-- | Limit a logger's length, adding "..." if truncated.
shortenL :: Int -> Logger -> Logger

-- | Color a logger's output with dzen foreground and background colors.
--   
--   <pre>
--   dzenColorL "green" "#2A4C3F" battery
--   </pre>
dzenColorL :: String -> String -> Logger -> Logger

-- | Color a logger's output with xmobar foreground and background colors.
--   
--   <pre>
--   xmobarColorL "#6A5ACD" "gray6" loadAverage
--   </pre>
xmobarColorL :: String -> String -> Logger -> Logger
instance Data.Default.Class.Default XMonad.Util.Loggers.ClassnamesFormat
instance Data.Default.Class.Default XMonad.Util.Loggers.TitlesFormat


-- | Provides <tt>clickablePP</tt>, which when applied to the <a>PP</a>
--   pretty-printer used by <a>XMonad.Hooks.StatusBar</a> will make the
--   workspace tags clickable in XMobar (for switching focus).
module XMonad.Util.ClickableWorkspaces

-- | Apply clickable wrapping to the given PP.
clickablePP :: PP -> X PP

-- | Wrap string with an xmobar action that uses <tt>xdotool</tt> to switch
--   to workspace <tt>i</tt>.
clickableWrap :: Int -> String -> String


-- | Utility functions for simulating independent sets of workspaces on
--   each screen (like dwm's workspace model), using internal tags to
--   distinguish workspaces associated with each screen.
module XMonad.Layout.IndependentScreens
type VirtualWorkspace = WorkspaceId
type PhysicalWorkspace = WorkspaceId

-- | A <a>WindowSpace</a> whose tags are <a>VirtualWorkspace</a>s.
type VirtualWindowSpace = WindowSpace

-- | A <a>WindowSpace</a> whose tags are <a>PhysicalWorkspace</a>s.
type PhysicalWindowSpace = WindowSpace

-- | Get a list of all the virtual workspace names.
workspaces' :: XConfig l -> [VirtualWorkspace]

-- | Specify workspace names for each screen
withScreen :: ScreenId -> [VirtualWorkspace] -> [PhysicalWorkspace]

-- | Make all workspaces across the monitors bear the same names
withScreens :: ScreenId -> [VirtualWorkspace] -> [PhysicalWorkspace]

-- | Transform a function over physical workspaces into a function over
--   virtual workspaces. This is useful as it allows you to write code
--   without caring about the current screen, i.e. to say "switch to
--   workspace 3" rather than saying "switch to workspace 3 on monitor 3".
onCurrentScreen :: (PhysicalWorkspace -> WindowSet -> a) -> VirtualWorkspace -> WindowSet -> a

-- | This turns a pretty-printer into one that is aware of the independent
--   screens. The converted pretty-printer first filters out physical
--   workspaces on other screens, then converts all the physical workspaces
--   on this screen to their virtual names. Note that <a>ppSort</a> still
--   operates on physical (marshalled) workspace names, otherwise functions
--   from <a>XMonad.Util.WorkspaceCompare</a> wouldn't work. If you need to
--   sort on virtual names, see <a>marshallSort</a>.
--   
--   For example, if you have have two bars on the left and right screens,
--   respectively, and <tt>pp</tt> is a pretty-printer, you could apply
--   <a>marshallPP</a> when creating a <tt>StatusBarConfig</tt> from
--   <a>XMonad.Hooks.StatusBar</a>.
--   
--   A sample config looks like this:
--   
--   <pre>
--   mySBL = statusBarProp "xmobar" $ pure (marshallPP (S 0) pp)
--   mySBR = statusBarProp "xmobar" $ pure (marshallPP (S 1) pp)
--   main = xmonad $ withEasySB (mySBL &lt;&gt; mySBR) defToggleStrutsKey def
--   </pre>
marshallPP :: ScreenId -> PP -> PP

-- | Take a pretty-printer and turn it into one that only runs when the
--   current workspace is one associated with the given screen. The way
--   this works is a bit hacky, so beware: the <a>ppOutput</a> field of the
--   input will not be invoked if either of the following conditions is
--   met:
--   
--   <ol>
--   <li>The <a>ppSort</a> of the input returns an empty list (when not
--   given one).</li>
--   <li>The <a>ppOrder</a> of the input returns the exact string
--   <tt>"\0"</tt>.</li>
--   </ol>
--   
--   For example, you can use this to create a pipe which tracks the title
--   of the window currently focused on a given screen (even if the screen
--   is not current) by doing something like this:
--   
--   <pre>
--   ppFocus s = whenCurrentOn s def
--       { ppOrder  = \(_:_:title:_) -&gt; [title]
--       , ppOutput = appendFile ("focus" ++ show s) . (++ "\n")
--       }
--   </pre>
--   
--   Sequence a few of these pretty-printers to get a log hook that keeps
--   each screen's title up-to-date.
whenCurrentOn :: ScreenId -> PP -> PP

-- | In case you don't know statically how many screens there will be, you
--   can call this in main before starting xmonad. For example, part of my
--   config reads
--   
--   <pre>
--   main = do
--     nScreens &lt;- countScreens
--     xmonad $ def {
--       ...
--       workspaces = withScreens nScreens (workspaces def),
--       ...
--       }
--   </pre>
countScreens :: (MonadIO m, Integral i) => m i

-- | Filter workspaces that are on a given screen.
workspacesOn :: ScreenId -> [PhysicalWindowSpace] -> [PhysicalWindowSpace]

-- | Get the workspace currently active on a given screen
workspaceOnScreen :: ScreenId -> WindowSet -> Maybe PhysicalWorkspace

-- | Focus a window, switching workspace on the correct Xinerama screen if
--   neccessary.
focusWindow' :: Window -> WindowSet -> WindowSet

-- | Focus a given screen.
focusScreen :: ScreenId -> WindowSet -> WindowSet

-- | Get the nth virtual workspace
nthWorkspace :: Int -> X (Maybe VirtualWorkspace)

-- | Generate WindowSet transformation by providing a given function with
--   the workspace active on a given screen. This may for example be used
--   to shift a window to another screen as follows:
--   
--   <pre>
--   windows $ withWspOnScreen 1 W.shift
--   </pre>
withWspOnScreen :: ScreenId -> (PhysicalWorkspace -> WindowSet -> WindowSet) -> WindowSet -> WindowSet
marshall :: ScreenId -> VirtualWorkspace -> PhysicalWorkspace
unmarshall :: PhysicalWorkspace -> (ScreenId, VirtualWorkspace)
unmarshallS :: PhysicalWorkspace -> ScreenId
unmarshallW :: PhysicalWorkspace -> VirtualWorkspace

-- | Convert the tag of the <a>WindowSpace</a> from a
--   <a>VirtualWorkspace</a> to a <a>PhysicalWorkspace</a>.
marshallWindowSpace :: ScreenId -> WindowSpace -> WindowSpace

-- | Convert the tag of the <a>WindowSpace</a> from a
--   <a>PhysicalWorkspace</a> to a <a>VirtualWorkspace</a>.
unmarshallWindowSpace :: WindowSpace -> WindowSpace

-- | <tt>vSort</tt> is a function that sorts <a>VirtualWindowSpace</a>s
--   with virtual names. <tt>marshallSort s vSort</tt> is a function which
--   sorts <a>PhysicalWindowSpace</a>s with virtual names, but keeps only
--   the <a>WindowSpace</a>'s on screen <tt>s</tt>.
--   
--   NOTE: <tt>vSort</tt> operating on virtual names comes with some
--   caveats, see <a>this issue</a> for more information. You can use
--   <a>marshallSort</a> like in the following example:
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   pp' :: ScreenId -&gt; PP -&gt; PP
--   pp' s pp = (marshallPP s pp) { ppSort = fmap (marshallSort s) (ppSort pp) }
--   
--   mySBL = statusBarProp "xmobar" $ pure (pp' (S 0) pp)
--   mySBR = statusBarProp "xmobar" $ pure (pp' (S 1) pp)
--   main = xmonad $ withEasySB (mySBL &lt;&gt; mySBR) defToggleStrutsKey def
--   </pre>
--   
--   In this way, you have a custom virtual names sort on top of
--   <a>marshallPP</a>.
marshallSort :: ScreenId -> ([VirtualWindowSpace] -> [VirtualWindowSpace]) -> [PhysicalWindowSpace] -> [PhysicalWindowSpace]


-- | Provides bindings to add and delete links between workspaces. It is
--   aimed at providing useful links between workspaces in a multihead
--   setup. Linked workspaces are view at the same time.
module XMonad.Actions.LinkWorkspaces
switchWS :: (WorkspaceId -> X ()) -> MessageConfig -> WorkspaceId -> X ()

-- | Remove all maps between workspaces
removeAllMatchings :: MessageConfig -> X ()

-- | remove all matching regarding a given workspace
unMatch :: WorkspaceId -> X ()

-- | Toggle the currently displayed workspaces as matching. Starting from
--   the one with focus | a linked list of workspaces is created that will
--   later be iterated by switchToMatching.
toggleLinkWorkspaces :: MessageConfig -> X ()
defaultMessageConf :: MessageConfig
data MessageConfig
MessageConfig :: (ScreenId -> [Char] -> [Char] -> [Char] -> X ()) -> [Char] -> [Char] -> [Char] -> MessageConfig
[messageFunction] :: MessageConfig -> ScreenId -> [Char] -> [Char] -> [Char] -> X ()
[foreground] :: MessageConfig -> [Char]
[alertedForeground] :: MessageConfig -> [Char]
[background] :: MessageConfig -> [Char]
instance GHC.Show.Show XMonad.Actions.LinkWorkspaces.WorkspaceMap
instance GHC.Read.Read XMonad.Actions.LinkWorkspaces.WorkspaceMap
instance XMonad.Core.ExtensionClass XMonad.Actions.LinkWorkspaces.WorkspaceMap


-- | In multi-head setup, it might be useful to have screen information of
--   the visible workspaces combined with the workspace name, for example
--   in a status bar. This module provides utility functions to do just
--   that.
module XMonad.Hooks.StatusBar.WorkspaceScreen

-- | Combine a workspace name with a screen according to the given
--   <a>WorkspaceScreenCombiner</a>.
combineWithScreen :: X WorkspaceScreenCombiner -> PP -> X PP

-- | Combine a workspace name with the screen name it's visible on.
combineWithScreenName :: (WorkspaceId -> String -> String) -> PP -> X PP

-- | Combine a workspace name with the screen number it's visible on.
combineWithScreenNumber :: (WorkspaceId -> String -> String) -> PP -> X PP

-- | Type synonym for a function that combines a workspace name with a
--   screen.
type WorkspaceScreenCombiner = WorkspaceId -> WindowScreen -> String


-- | Dynamically augment workspace names logged to a status bar based on
--   the contents (windows) of the workspace.
module XMonad.Hooks.DynamicIcons

-- | Adjusts the <a>PP</a> with the given <tt>IconSet</tt>
iconsPP :: Query [String] -> PP -> X PP

-- | Adjusts the <a>PP</a> and then runs <a>dynamicLogWithPP</a>
dynamicLogIconsWithPP :: Query [String] -> PP -> X ()

-- | Shortcut for configuring single icons.
appIcon :: String -> Query [String]

-- | Modify a pretty-printer, <a>PP</a>, to augment workspace names with
--   icons based on the contents (windows) of the workspace.
dynamicIconsPP :: IconConfig -> PP -> X PP

-- | Returns a function for <a>ppRename</a> that augments workspaces with
--   icons according to the provided <a>IconConfig</a>.
getWorkspaceIcons :: IconConfig -> X (String -> WindowSpace -> String)

-- | Datatype for expanded <tt>Icon</tt> configurations
data IconConfig
IconConfig :: Query [String] -> (WorkspaceId -> [String] -> String) -> (Maybe (Stack Window) -> X [Window]) -> IconConfig

-- | What icons to use for each window.
[iconConfigIcons] :: IconConfig -> Query [String]

-- | How to format the result, see <a>iconsFmtReplace</a>,
--   <a>iconsFmtAppend</a>.
[iconConfigFmt] :: IconConfig -> WorkspaceId -> [String] -> String

-- | Which windows (icons) to show.
[iconConfigFilter] :: IconConfig -> Maybe (Stack Window) -> X [Window]

-- | <a>iconConfigFmt</a> that appends icons to the workspace name.
--   
--   First parameter specifies how to concatenate multiple icons. Useful
--   values include: <a>concat</a>, <a>unwords</a>, <a>wrapUnwords</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; iconsFmtAppend concat "1" []
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iconsFmtAppend concat "1" ["A", "B"]
--   "1:AB"
--   </pre>
iconsFmtAppend :: ([String] -> String) -> WorkspaceId -> [String] -> String

-- | <a>iconConfigFmt</a> that replaces the workspace name with icons, if
--   any.
--   
--   First parameter specifies how to concatenate multiple icons. Useful
--   values include: <a>concat</a>, <a>unwords</a>, <a>wrapUnwords</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; iconsFmtReplace concat "1" []
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iconsFmtReplace concat "1" ["A", "B"]
--   "AB"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iconsFmtReplace (wrapUnwords "{" "}") "1" ["A", "B"]
--   "{A B}"
--   </pre>
iconsFmtReplace :: ([String] -> String) -> WorkspaceId -> [String] -> String

-- | Join words with spaces, and wrap the result in delimiters unless there
--   was exactly one element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; wrapUnwords "{" "}" ["A", "B"]
--   "{A B}"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; wrapUnwords "{" "}" ["A"]
--   "A"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; wrapUnwords "{" "}" []
--   ""
--   </pre>
wrapUnwords :: String -> String -> [String] -> String

-- | <a>iconConfigFilter</a> that shows all windows of every workspace.
iconsGetAll :: Maybe (Stack Window) -> X [Window]

-- | <a>iconConfigFilter</a> that shows only the focused window for each
--   workspace.
iconsGetFocus :: Maybe (Stack Window) -> X [Window]
instance Data.Default.Class.Default XMonad.Hooks.DynamicIcons.IconConfig


-- | Provides bindings to duplicate a window on multiple workspaces,
--   providing dwm-like tagging functionality.
module XMonad.Actions.CopyWindow

-- | Copy the focused window to a workspace.
copy :: (Eq s, Eq i, Eq a) => i -> StackSet i l a s sd -> StackSet i l a s sd

-- | Copy the focused window to all workspaces.
copyToAll :: (Eq s, Eq i, Eq a) => StackSet i l a s sd -> StackSet i l a s sd

-- | Copy an arbitrary window to a workspace.
copyWindow :: (Eq a, Eq i, Eq s) => a -> i -> StackSet i l a s sd -> StackSet i l a s sd

-- | runOrCopy will run the provided shell command unless it can find a
--   specified window in which case it will copy the window to the current
--   workspace. Similar to (i.e., stolen from)
--   <a>XMonad.Actions.WindowGo</a>.
runOrCopy :: String -> Query Bool -> X ()

-- | Kill all other copies of focused window (if they're present). 'All
--   other' means here 'copies which are not on the current workspace'.
killAllOtherCopies :: X ()

-- | Remove the focused window from this workspace. If it's present in no
--   other workspace, then kill it instead. If we do kill it, we'll get a
--   delete notify back from X.
--   
--   There are two ways to delete a window. Either just kill it, or if it
--   supports the delete protocol, send a delete event (e.g. firefox).
kill1 :: X ()

-- | Get a list of tuples (tag, [Window]) for each workspace.
taggedWindows :: [Workspace i l a] -> [(i, [a])]

-- | Get tags with copies of the focused window (if present.)
copiesOfOn :: Eq a => Maybe a -> [(i, [a])] -> [i]

-- | A list of hidden workspaces containing a copy of the focused window.
wsContainingCopies :: X [WorkspaceId]

-- | Take a pretty printer and make it aware of copies by using the
--   provided function to show hidden workspaces that contain copies of the
--   focused window.
copiesPP :: (WorkspaceId -> String) -> PP -> X PP


-- | dmenu operations to bring windows to you, and bring you to windows.
--   That is to say, it pops up a dmenu with window names, in case you
--   forgot where you left your XChat.
module XMonad.Actions.WindowBringer
data WindowBringerConfig
WindowBringerConfig :: String -> [String] -> (WindowSpace -> Window -> X String) -> (Window -> X Bool) -> WindowBringerConfig

-- | The shell command that will handle window selection
[menuCommand] :: WindowBringerConfig -> String

-- | Arguments to be passed to menuCommand
[menuArgs] :: WindowBringerConfig -> [String]

-- | A function that produces window titles given a workspace and a window
[windowTitler] :: WindowBringerConfig -> WindowSpace -> Window -> X String

-- | Filter function to decide which windows to consider
[windowFilter] :: WindowBringerConfig -> Window -> X Bool

-- | Pops open a dmenu with window titles. Choose one, and you will be
--   taken to the corresponding workspace.
gotoMenu :: X ()

-- | Pops open a dmenu with window titles. Choose one, and you will be
--   taken to the corresponding workspace. This version accepts a
--   configuration object.
gotoMenuConfig :: WindowBringerConfig -> X ()

-- | Pops open an application with window titles given over stdin. Choose
--   one, and you will be taken to the corresponding workspace.
gotoMenu' :: String -> X ()

-- | Pops open a dmenu with window titles. Choose one, and you will be
--   taken to the corresponding workspace. This version takes a list of
--   arguments to pass to dmenu.
gotoMenuArgs :: [String] -> X ()

-- | Pops open an application with window titles given over stdin. Choose
--   one, and you will be taken to the corresponding workspace. This
--   version takes a list of arguments to pass to dmenu.
gotoMenuArgs' :: String -> [String] -> X ()

-- | Pops open a dmenu with window titles. Choose one, and it will be
--   dragged, kicking and screaming, into your current workspace.
bringMenu :: X ()

-- | Pops open a dmenu with window titles. Choose one, and it will be
--   dragged, kicking and screaming, into your current workspace. This
--   version accepts a configuration object.
bringMenuConfig :: WindowBringerConfig -> X ()

-- | Pops open an application with window titles given over stdin. Choose
--   one, and it will be dragged, kicking and screaming, into your current
--   workspace.
bringMenu' :: String -> X ()

-- | Pops open a dmenu with window titles. Choose one, and it will be
--   dragged, kicking and screaming, into your current workspace. This
--   version takes a list of arguments to pass to dmenu.
bringMenuArgs :: [String] -> X ()

-- | Pops open an application with window titles given over stdin. Choose
--   one, and it will be dragged, kicking and screaming, into your current
--   workspace. This version allows arguments to the chooser to be
--   specified.
bringMenuArgs' :: String -> [String] -> X ()

-- | Pops open a dmenu with window titles. Choose one, and it will be
--   copied into your current workspace.
copyMenu :: X ()

-- | Pops open a dmenu with window titles. Choose one, and it will be
--   copied into your current workspace. This version accepts a
--   configuration object.
copyMenuConfig :: WindowBringerConfig -> X ()

-- | Pops open an application with window titles given over stdin. Choose
--   one, and it will be copied into your current workspace.
copyMenu' :: String -> X ()

-- | Pops open a dmenu with window titles. Choose one, and it will be
--   copied into your current workspace. This version takes a list of
--   arguments to pass to dmenu.
copyMenuArgs :: [String] -> X ()

-- | Pops open an application with window titles given over stdin. Choose
--   one, and it will be copied into your current workspace. This version
--   allows arguments to the chooser to be specified.
copyMenuArgs' :: String -> [String] -> X ()

-- | A map from window names to Windows.
windowMap :: X (Map String Window)

-- | A map from application executable names to Windows.
windowAppMap :: X (Map String Window)

-- | A map from window names to Windows, given a windowTitler function.
windowMap' :: WindowBringerConfig -> X (Map String Window)

-- | Brings the specified window into the current workspace.
bringWindow :: Window -> WindowSet -> WindowSet

-- | Calls dmenuMap to grab the appropriate Window, and hands it off to
--   action if found.
actionMenu :: WindowBringerConfig -> (Window -> WindowSet -> WindowSet) -> X ()
instance Data.Default.Class.Default XMonad.Actions.WindowBringer.WindowBringerConfig


-- | xprompt operations to bring windows to you, and bring you to windows.
module XMonad.Prompt.Window
data WindowPrompt
Goto :: WindowPrompt
Bring :: WindowPrompt
BringCopy :: WindowPrompt
BringToMaster :: WindowPrompt
WithWindow :: String -> (Window -> X ()) -> WindowPrompt

-- | Pops open a prompt with window titles belonging to winmap. Choose one,
--   and an action is applied on the selected window, according to
--   WindowPrompt.
windowPrompt :: XPConfig -> WindowPrompt -> XWindowMap -> X ()

-- | Like <a>windowPrompt</a>, but uses the multiple modes feature of
--   <tt>Prompt</tt> (via <a>mkXPromptWithModes</a>).
--   
--   Given a list of actions along with the windows they should work with,
--   display the appropriate prompt with the ability to switch between them
--   using the <tt>changeModeKey</tt>.
--   
--   For example, to have a prompt that first shows you all windows, but
--   allows you to narrow the list down to just the windows on the current
--   workspace:
--   
--   <pre>
--   windowMultiPrompt config [(Goto, allWindows), (Goto, wsWindows)]
--   </pre>
windowMultiPrompt :: XPConfig -> [(WindowPrompt, XWindowMap)] -> X ()

-- | A helper to get the map of all windows.
allWindows :: XWindowMap

-- | A helper to get the map of all applications
allApplications :: XWindowMap

-- | A helper to get the map of windows of the current workspace.
wsWindows :: XWindowMap

-- | A Map where keys are pretty printable window names and values are
--   Xmonad windows identifier.
type XWindowMap = X (Map String Window)
instance XMonad.Prompt.XPrompt XMonad.Prompt.Window.WindowModePrompt
instance XMonad.Prompt.XPrompt XMonad.Prompt.Window.WindowPrompt


-- | Turns your workspaces into a more topic oriented system.
module XMonad.Actions.TopicSpace

-- | <a>Topic</a> is just an alias for <a>WorkspaceId</a>
type Topic = WorkspaceId

-- | <a>Dir</a> is just an alias for <a>FilePath</a>, but should point to a
--   directory.
type Dir = FilePath

-- | Here is the topic space configuration area.
data TopicConfig
TopicConfig :: Map Topic Dir -> Map Topic (X ()) -> (Topic -> X ()) -> Topic -> Int -> TopicConfig

-- | This mapping associates a directory to each topic.
[topicDirs] :: TopicConfig -> Map Topic Dir

-- | This mapping associates an action to trigger when switching to a given
--   topic which workspace is empty.
[topicActions] :: TopicConfig -> Map Topic (X ())

-- | This is the default topic action.
[defaultTopicAction] :: TopicConfig -> Topic -> X ()

-- | This is the default (= fallback) topic.
[defaultTopic] :: TopicConfig -> Topic

-- | This specifies the maximum depth of the topic history; usually 10 is a
--   good default since we can bind all of them using numeric keypad.

-- | <i>Deprecated: This field will be removed in the future; history is
--   now handled by XMonad.Hooks.WorkspaceHistory</i>
[maxTopicHistory] :: TopicConfig -> Int

-- | Convenience type for specifying topics.
data TopicItem
TI :: !Topic -> !Dir -> !X () -> TopicItem

-- | <a>Topic</a> ≡ <a>String</a>
[tiName] :: TopicItem -> !Topic

-- | Directory associated with topic; <a>Dir</a> ≡ <a>String</a>
[tiDir] :: TopicItem -> !Dir

-- | Startup hook when topic is empty
[tiAction] :: TopicItem -> !X ()

-- | Extract the names from a given list of <a>TopicItem</a>s.
topicNames :: [TopicItem] -> [Topic]

-- | From a list of <a>TopicItem</a>s, build a map that can be supplied as
--   the <a>topicActions</a>.
tiActions :: [TopicItem] -> Map Topic (X ())

-- | From a list of <a>TopicItem</a>s, build a map that can be supplied as
--   the <a>topicDirs</a>.
tiDirs :: [TopicItem] -> Map Topic Dir

-- | Associate a directory with the topic, but don't spawn anything.
noAction :: Topic -> Dir -> TopicItem

-- | Topic with <tt>tiDir = ~/</tt>.
inHome :: Topic -> X () -> TopicItem

-- | Switch to the given topic.
switchTopic :: TopicConfig -> Topic -> X ()

-- | Switch to the Nth last focused topic or fall back to the
--   <a>defaultTopic</a>.
switchNthLastFocused :: TopicConfig -> Int -> X ()

-- | Like <a>switchNthLastFocused</a>, but only consider topics that used
--   to be on the current screen.
--   
--   For example, the following function allows one to toggle between the
--   currently focused and the last used topic, while treating different
--   screens completely independently from one another.
--   
--   <pre>
--   toggleTopicScreen = switchNthLastFocusedByScreen myTopicConfig 1
--   </pre>
switchNthLastFocusedByScreen :: TopicConfig -> Int -> X ()

-- | Like <a>switchNthLastFocused</a>, but also filter out certain topics.
switchNthLastFocusedExclude :: [Topic] -> TopicConfig -> Int -> X ()

-- | Shift the focused window to the Nth last focused topic, or fall back
--   to doing nothing.
shiftNthLastFocused :: Int -> X ()

-- | Given a prompt configuration and a topic configuration, trigger the
--   action associated with the topic given in prompt.
topicActionWithPrompt :: XPConfig -> TopicConfig -> X ()

-- | Given a configuration and a topic, trigger the action associated with
--   the given topic.
topicAction :: TopicConfig -> Topic -> X ()

-- | Trigger the action associated with the current topic.
currentTopicAction :: TopicConfig -> X ()

-- | Return the (possibly empty) list of last focused topics.

-- | <i>Deprecated: Use XMonad.Hooks.WorkspaceHistory.workspaceHistory
--   (re-exported by this module) instead</i>
getLastFocusedTopics :: X [Topic]

-- | A list of workspace tags in the order they have been viewed, with the
--   most recent first. No duplicates are present, but not all workspaces
--   are guaranteed to appear, and there may be workspaces that no longer
--   exist.
workspaceHistory :: X [WorkspaceId]
workspaceHistoryByScreen :: X [(ScreenId, [WorkspaceId])]

-- | Given a <a>TopicConfig</a>, a topic, and a predicate to select topics
--   that one wants to keep, this function will cons the topic in front of
--   the list of last focused topics and filter it according to the
--   predicate. Note that we prune the list in case that its length exceeds
--   <a>maxTopicHistory</a>.

-- | <i>Deprecated: Use XMonad.Hooks.WorkspaceHistory instead</i>
setLastFocusedTopic :: TopicConfig -> Topic -> (Topic -> Bool) -> X ()

-- | Reverse the list of "last focused topics"
reverseLastFocusedTopics :: X ()

-- | A <a>logHook</a> that keeps track of the order in which workspaces
--   have been viewed.
workspaceHistoryHook :: X ()

-- | Like <a>workspaceHistoryHook</a>, but with the ability to exclude
--   certain workspaces.
workspaceHistoryHookExclude :: [WorkspaceId] -> X ()

-- | This function is a variant of <a>pprWindowSet</a> which takes a topic
--   configuration and a pretty-printing record <a>PP</a>. It will show the
--   list of topics sorted historically and highlight topics with urgent
--   windows.
pprWindowSet :: TopicConfig -> PP -> X String

-- | Return the directory associated with the current topic, or return the
--   empty string if the topic could not be found.
currentTopicDir :: TopicConfig -> X FilePath

-- | Check the given topic configuration for duplicate or undefined topics.
checkTopicConfig :: [Topic] -> TopicConfig -> IO ()

-- | An alias for <tt>flip replicateM_</tt>
(>*>) :: Monad m => m a -> Int -> m ()
infix 9 >*>
instance Data.Default.Class.Default XMonad.Actions.TopicSpace.TopicConfig


-- | Extends <a>XMonad.ManageHook</a> EDSL to work on focused windows and
--   current workspace.
module XMonad.Hooks.Focus

-- | Information about current workspace and focus.
data Focus
Focus :: WorkspaceId -> Maybe Window -> WorkspaceId -> Focus

-- | Workspace, where new window appears.
[newWorkspace] :: Focus -> WorkspaceId

-- | Focused window on workspace, where new window appears.
[focusedWindow] :: Focus -> Maybe Window

-- | Current workspace.
[currentWorkspace] :: Focus -> WorkspaceId
newtype FocusLock
FocusLock :: Bool -> FocusLock
[getFocusLock] :: FocusLock -> Bool

-- | Toggle stored focus lock state.
toggleLock :: X ()

-- | Lock focus.
focusLockOn :: X ()

-- | Unlock focus.
focusLockOff :: X ()

-- | Monad on top of <a>Query</a> providing additional information about
--   new window.
data FocusQuery a
runFocusQuery :: FocusQuery a -> Focus -> Query a
type FocusHook = FocusQuery (Endo WindowSet)

-- | Lift <a>Query</a> into <a>FocusQuery</a> monad. The same as
--   <a>new</a>.
liftQuery :: Query a -> FocusQuery a

-- | Run <a>Query</a> on new window.
new :: Query a -> FocusQuery a

-- | Run <a>Query</a> on focused window on workspace, where new window
--   appears. If there is no focused window, return <a>False</a>.
focused :: Query Bool -> FocusQuery Bool

-- | More general version of <a>focused</a>.
focused' :: Monoid a => Query a -> FocusQuery a

-- | Run <a>Query</a> on window focused at particular workspace. If there
--   is no focused window, return <a>False</a>.
focusedOn :: WorkspaceId -> Query Bool -> FocusQuery Bool

-- | More general version of <a>focusedOn</a>.
focusedOn' :: Monoid a => WorkspaceId -> Query a -> FocusQuery a

-- | Run <a>Query</a> on focused window on current workspace. If there is
--   no focused window, return <a>False</a>. Note,
--   
--   <pre>
--   focused &lt;&amp;&amp;&gt; newOnCur != focusedCur
--   </pre>
--   
--   The first will affect only new or activated window appearing on
--   current workspace, while the last will affect any window: focus even
--   for windows appearing on other workpsaces will depend on focus on
--   <i>current</i> workspace.
focusedCur :: Query Bool -> FocusQuery Bool

-- | More general version of <a>focusedCur</a>.
focusedCur' :: Monoid a => Query a -> FocusQuery a

-- | Does new window appear at particular workspace?
newOn :: WorkspaceId -> FocusQuery Bool

-- | Does new window appear at current workspace?
newOnCur :: FocusQuery Bool

-- | Execute <a>Query</a>, unless focus is locked.
unlessFocusLock :: Monoid a => Query a -> Query a

-- | Keep focus on workspace (may not be current), where new window
--   appears. Workspace will not be switched. This operation is idempotent
--   and effectively returns focus to window focused on that workspace
--   before applying <tt>(Endo WindowSet)</tt> function.
keepFocus :: FocusHook

-- | Switch focus to new window on workspace (may not be current), where
--   new window appears. Workspace will not be switched. This operation is
--   idempotent.
switchFocus :: FocusHook

-- | Keep current workspace. Focus will not be changed at either current or
--   new window's workspace. This operation is idempotent and effectively
--   switches to workspace, which was current before applying <tt>(Endo
--   WindowSet)</tt> function.
keepWorkspace :: FocusHook

-- | Switch workspace to one, where new window appears. Focus will not be
--   changed at either current or new window's workspace. This operation is
--   idempotent.
switchWorkspace :: FocusHook

-- | I don't know at which workspace new window will appear until <tt>(Endo
--   WindowSet)</tt> function from <a>windows</a> in
--   <a>XMonad.Operations</a> actually run, but in <tt>(Endo
--   WindowSet)</tt> function i can't already execute monadic actions,
--   because it's pure. So, i compute result for every workspace here and
--   just use it later in <tt>(Endo WindowSet)</tt> function. Note, though,
--   that this will execute monadic actions many times, and therefore
--   assume, that result of <a>FocusHook</a> does not depend on the number
--   of times it was executed.
manageFocus :: FocusHook -> ManageHook

-- | Default EWMH window activation behavior: switch to workspace with
--   activated window and switch focus to it. Not to be used in a
--   <a>manageHook</a>.
activateSwitchWs :: ManageHook

-- | Move activated window to current workspace and switch focus to it.
--   Note, that i need to explicitly call <a>switchFocus</a> here, because
--   otherwise, when activated window is <i>already</i> on current
--   workspace, focus won't be switched. Not to be used in a
--   <a>manageHook</a>.
activateOnCurrentWs :: ManageHook

-- | Move activated window to current workspace, but keep focus unchanged.
--   Not to be used in a <a>manageHook</a>.
activateOnCurrentKeepFocus :: ManageHook
instance GHC.Show.Show XMonad.Hooks.Focus.Focus
instance GHC.Show.Show XMonad.Hooks.Focus.FocusLock
instance GHC.Base.Monoid a => GHC.Base.Monoid (XMonad.Hooks.Focus.FocusQuery a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (XMonad.Hooks.Focus.FocusQuery a)
instance Control.Monad.IO.Class.MonadIO XMonad.Hooks.Focus.FocusQuery
instance Control.Monad.Reader.Class.MonadReader XMonad.Hooks.Focus.Focus XMonad.Hooks.Focus.FocusQuery
instance GHC.Base.Monad XMonad.Hooks.Focus.FocusQuery
instance GHC.Base.Applicative XMonad.Hooks.Focus.FocusQuery
instance GHC.Base.Functor XMonad.Hooks.Focus.FocusQuery
instance XMonad.Core.ExtensionClass XMonad.Hooks.Focus.FocusLock
instance Data.Default.Class.Default XMonad.Hooks.Focus.Focus


-- | xmonad normally honours those requests by doing exactly what the
--   client application asked, and refreshing. There are some misbehaving
--   clients, however, that:
--   
--   <ul>
--   <li>try to move their window to the last known absolute position
--   regardless of the current xrandr/xinerama layout</li>
--   <li>move their window to 0, 0 for no particular reason (e.g.
--   rxvt-unicode)</li>
--   <li>issue lots of no-op requests causing flickering (e.g. Steam)</li>
--   </ul>
--   
--   This module provides a replacement handler for
--   <a>ConfigureRequestEvent</a> to work around such misbehaviours.
module XMonad.Hooks.FloatConfigureReq

-- | A variant of <a>MaybeManageHook</a> that additionally may or may not
--   make changes to the <a>WindowSet</a>.
type MaybeMaybeManageHook = Query (Maybe (Maybe (Endo WindowSet)))

-- | Customizable handler for a <a>ConfigureRequestEvent</a>. If the
--   event's <a>ev_window</a> is a managed floating window, the provided
--   <a>MaybeMaybeManageHook</a> is consulted and its result interpreted as
--   follows:
--   
--   <ul>
--   <li><tt>Nothing</tt> - no match, fall back to the default handler</li>
--   <li><tt>Just Nothing</tt> - match but ignore, no refresh, just send
--   ConfigureNotify</li>
--   <li><tt>Just (Just a)</tt> - match, modify <a>WindowSet</a>, refresh,
--   send ConfigureNotify</li>
--   </ul>
floatConfReqHook :: MaybeMaybeManageHook -> Event -> X All

-- | A pre-packaged <a>floatConfReqHook</a> that fixes flickering of the
--   Steam client by ignoring <a>ConfigureRequestEvent</a>s on any of its
--   floating windows.
--   
--   To use this, add <a>fixSteamFlicker</a> to your
--   <a>handleEventHook</a>.
fixSteamFlicker :: Event -> X All
fixSteamFlickerMMMH :: MaybeMaybeManageHook


-- | This module provides tools to automatically manage <tt>dock</tt> type
--   programs, such as gnome-panel, kicker, dzen, and xmobar.
module XMonad.Hooks.ManageDocks

-- | Add docks functionality to the given config. See above for an example.
docks :: XConfig a -> XConfig a

-- | Detects if the given window is of type DOCK and if so, reveals it, but
--   does not manage it.
manageDocks :: ManageHook

-- | Checks if a window is a DOCK or DESKTOP window. Ignores xmonad's own
--   windows (usually _NET_WM_WINDOW_TYPE_DESKTOP) to avoid unnecessary
--   refreshes.
checkDock :: Query Bool
newtype AvoidStruts a
AvoidStruts :: Set Direction2D -> AvoidStruts a

-- | Adjust layout automagically: don't cover up any docks, status bars,
--   etc.
--   
--   Note that this modifier must be applied before any modifier that
--   changes the screen rectangle, or struts will be applied in the wrong
--   place and may affect the other modifier(s) in odd ways. This is most
--   commonly seen with the <tt>spacing</tt> modifier and friends.
avoidStruts :: LayoutClass l a => l a -> ModifiedLayout AvoidStruts l a

-- | Adjust layout automagically: don't cover up docks, status bars, etc.
--   on the indicated sides of the screen. Valid sides are <a>U</a> (top),
--   <a>Direction2D</a> (bottom), <a>R</a> (right), or <a>L</a> (left). The
--   warning in <a>avoidStruts</a> applies to this modifier as well.
avoidStrutsOn :: LayoutClass l a => [Direction2D] -> l a -> ModifiedLayout AvoidStruts l a

-- | Message type which can be sent to an <a>AvoidStruts</a> layout
--   modifier to alter its behavior.
data ToggleStruts
ToggleStruts :: ToggleStruts
ToggleStrut :: Direction2D -> ToggleStruts

-- | SetStruts is a message constructor used to set or unset specific
--   struts, regardless of whether or not the struts were originally set.
--   Here are some example bindings:
--   
--   Show all gaps:
--   
--   <pre>
--   ,((modm .|. shiftMask  ,xK_b),sendMessage $ SetStruts [minBound .. maxBound] [])
--   </pre>
--   
--   Hide all gaps:
--   
--   <pre>
--   ,((modm .|. controlMask,xK_b),sendMessage $ SetStruts [] [minBound .. maxBound])
--   </pre>
--   
--   Show only upper and left gaps:
--   
--   <pre>
--   ,((modm .|. controlMask .|. shiftMask,xK_b),sendMessage $ SetStruts [U,L] [minBound .. maxBound])
--   </pre>
--   
--   Hide the bottom keeping whatever the other values were:
--   
--   <pre>
--   ,((modm .|. controlMask .|. shiftMask,xK_g),sendMessage $ SetStruts [] [D])
--   </pre>
data SetStruts
SetStruts :: [Direction2D] -> [Direction2D] -> SetStruts
[addedStruts] :: SetStruts -> [Direction2D]

-- | These are removed from the currently set struts before
--   <a>addedStruts</a> are added.
[removedStruts] :: SetStruts -> [Direction2D]

-- | Goes through the list of windows and find the gap so that all STRUT
--   settings are satisfied.
calcGap :: Set Direction2D -> X (Rectangle -> Rectangle)

-- | Whenever a new dock appears, refresh the layout immediately to avoid
--   the new dock.

-- | <i>Deprecated: Use docks instead.</i>
docksEventHook :: Event -> X All

-- | <i>Deprecated: Use docks instead.</i>
docksStartupHook :: X ()
instance GHC.Show.Show (XMonad.Hooks.ManageDocks.AvoidStruts a)
instance GHC.Read.Read (XMonad.Hooks.ManageDocks.AvoidStruts a)
instance GHC.Show.Show XMonad.Hooks.ManageDocks.ToggleStruts
instance GHC.Read.Read XMonad.Hooks.ManageDocks.ToggleStruts
instance GHC.Show.Show XMonad.Hooks.ManageDocks.SetStruts
instance GHC.Read.Read XMonad.Hooks.ManageDocks.SetStruts
instance GHC.Classes.Eq XMonad.Hooks.ManageDocks.StrutCache
instance GHC.Show.Show XMonad.Hooks.ManageDocks.RectC
instance GHC.Classes.Eq XMonad.Hooks.ManageDocks.RectC
instance XMonad.Core.ExtensionClass XMonad.Hooks.ManageDocks.StrutCache
instance XMonad.Core.Message XMonad.Hooks.ManageDocks.SetStruts
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Hooks.ManageDocks.AvoidStruts a
instance XMonad.Core.Message XMonad.Hooks.ManageDocks.ToggleStruts
instance XMonad.Core.Message XMonad.Hooks.ManageDocks.UpdateDocks


-- | xmonad calls the logHook with every internal state update, which is
--   useful for (among other things) outputting status information to an
--   external status bar program such as xmobar or dzen.
--   
--   This module provides a composable interface for (re)starting these
--   status bars and logging to them, either using pipes or X properties.
--   There's also <a>XMonad.Hooks.StatusBar.PP</a> which provides an
--   abstraction and some utilities for customization what is logged to a
--   status bar. Together, these are a modern replacement for
--   <a>XMonad.Hooks.DynamicLog</a>, which is now just a compatibility
--   wrapper.
module XMonad.Hooks.StatusBar

-- | This datataype abstracts a status bar to provide a common interface
--   functions like <a>statusBarPipe</a> or <a>statusBarProp</a>. Once
--   defined, a status bar can be incorporated in <a>XConfig</a> by using
--   <a>withSB</a> or <a>withEasySB</a>, which take care of the necessary
--   plumbing.
data StatusBarConfig
StatusBarConfig :: X () -> X () -> X () -> StatusBarConfig

-- | What and how to log to the status bar.
[sbLogHook] :: StatusBarConfig -> X ()

-- | How to start the status bar.
[sbStartupHook] :: StatusBarConfig -> X ()

-- | How to kill the status bar.
[sbCleanupHook] :: StatusBarConfig -> X ()

-- | Incorporates a <a>StatusBarConfig</a> into an <a>XConfig</a> by taking
--   care of the necessary plumbing (starting, restarting and logging to
--   it).
--   
--   Using this function multiple times to combine status bars may result
--   in only one status bar working properly. See the section on using
--   multiple status bars for more details.
withSB :: LayoutClass l Window => StatusBarConfig -> XConfig l -> XConfig l

-- | Like <a>withSB</a>, but takes an extra key to toggle struts. It also
--   applies the <a>avoidStruts</a> layout modifier and the <a>docks</a>
--   combinator.
--   
--   Using this function multiple times to combine status bars may result
--   in only one status bar working properly. See the section on using
--   multiple status bars for more details.
withEasySB :: LayoutClass l Window => StatusBarConfig -> (XConfig Layout -> (KeyMask, KeySym)) -> XConfig l -> XConfig (ModifiedLayout AvoidStruts l)

-- | Default <tt>mod-b</tt> key binding for <a>withEasySB</a>
defToggleStrutsKey :: XConfig t -> (KeyMask, KeySym)

-- | Creates a <a>StatusBarConfig</a> that uses property logging to
--   <tt>_XMONAD_LOG</tt>, which is set in <a>xmonadDefProp</a>
statusBarProp :: String -> X PP -> StatusBarConfig

-- | Like <a>statusBarProp</a>, but lets you define the property
statusBarPropTo :: String -> String -> X PP -> StatusBarConfig

-- | A generic <a>StatusBarConfig</a> that launches a status bar but takes
--   a generic <tt>X ()</tt> logging function instead of a <a>PP</a>. This
--   has several uses:
--   
--   <ul>
--   <li>With <a>xmonadPropLog</a> or <a>xmonadPropLog'</a> in the logging
--   function, a custom non-<a>PP</a>-based logger can be used for logging
--   into an <tt>xmobar</tt>.</li>
--   <li>With <a>mempty</a> as the logging function, it's possible to
--   manage a status bar that reads information from EWMH properties like
--   <tt>taffybar</tt>.</li>
--   <li>With <a>mempty</a> as the logging function, any other dock like
--   <tt>trayer</tt> or <tt>stalonetray</tt> can be managed by this
--   module.</li>
--   </ul>
statusBarGeneric :: String -> X () -> StatusBarConfig

-- | Like <a>statusBarProp</a>, but uses pipe-based logging instead.
statusBarPipe :: String -> X PP -> IO StatusBarConfig

-- | Given a function to create status bars, <a>dynamicSBs</a> adds the
--   dynamic status bar capabilities to the config. For a version of this
--   function that applies <a>docks</a> and <a>avoidStruts</a>, check
--   <a>dynamicEasySBs</a>.
--   
--   Heavily inspired by <a>XMonad.Hooks.DynamicBars</a>
dynamicSBs :: (ScreenId -> X StatusBarConfig) -> XConfig l -> XConfig l

-- | Like <a>dynamicSBs</a>, but applies <a>docks</a> to the resulting
--   config and adds <a>avoidStruts</a> to the layout.
dynamicEasySBs :: LayoutClass l Window => (ScreenId -> X StatusBarConfig) -> XConfig l -> XConfig (ModifiedLayout AvoidStruts l)

-- | Write a string to the <tt>_XMONAD_LOG</tt> property on the root
--   window.
xmonadPropLog :: String -> X ()

-- | Write a string to a property on the root window. This property is of
--   type <tt>UTF8_STRING</tt>.
xmonadPropLog' :: String -> String -> X ()

-- | The default property xmonad writes to. (<tt>_XMONAD_LOG</tt>).
xmonadDefProp :: String

-- | Spawns a status bar and saves its PID together with the commands that
--   was used to start it. This is useful when the status bars should be
--   restarted with xmonad. Use this in combination with
--   <a>killStatusBar</a>.
--   
--   Note: in some systems, multiple processes might start, even though one
--   command is provided. This means the first PID, of the group leader, is
--   saved.
spawnStatusBar :: String -> X ()

-- | Kills the status bar started with <a>spawnStatusBar</a> using the
--   given command and resets the state. This could go for example at the
--   beginning of the startupHook, to kill the status bars that need to be
--   restarted.
--   
--   Concretely, this function sends a <a>sigTERM</a> to the saved PIDs
--   using <a>signalProcessGroup</a> to effectively terminate all
--   processes, regardless of how many were started by using
--   <a>spawnStatusBar</a>.
--   
--   There is one caveat to keep in mind: to keep the implementation
--   simple; no checks are executed before terminating the processes. This
--   means: if the started process dies for some reason, and enough time
--   passes for the PIDs to wrap around, this function might terminate
--   another process that happens to have the same PID. However, this isn't
--   a typical usage scenario.
killStatusBar :: String -> X ()

-- | Kill all status bars started with <a>spawnStatusBar</a>. Note the
--   caveats in <tt>cleanupStatusBar</tt>
killAllStatusBars :: X ()

-- | Start all status bars. Note that you do not need this in your startup
--   hook. This can be bound to a keybinding for example to be used in
--   tandem with <a>killAllStatusBars</a>.
startAllStatusBars :: X ()
instance GHC.Read.Read XMonad.Hooks.StatusBar.StatusBarPIDs
instance GHC.Show.Show XMonad.Hooks.StatusBar.StatusBarPIDs
instance XMonad.Core.ExtensionClass XMonad.Hooks.StatusBar.StatusBarPIDs
instance XMonad.Core.ExtensionClass XMonad.Hooks.StatusBar.ActiveSBs
instance GHC.Base.Semigroup XMonad.Hooks.StatusBar.StatusBarConfig
instance GHC.Base.Monoid XMonad.Hooks.StatusBar.StatusBarConfig
instance Data.Default.Class.Default XMonad.Hooks.StatusBar.StatusBarConfig


-- | This module is a collection of random fixes, workarounds and other
--   functions that rely on somewhat hacky implementations which may have
--   unwanted side effects and/or are small enough to not warrant a
--   separate module.
--   
--   Import this module as qualified like so:
--   
--   <pre>
--   import qualified XMonad.Util.Hacks as Hacks
--   </pre>
--   
--   and then use the functions you want as described in their respective
--   documentation.
module XMonad.Util.Hacks

-- | Fixes fullscreen behaviour of chromium based apps by quickly applying
--   and undoing a resize. This causes chromium to recalculate the
--   fullscreen window dimensions to match the actual "windowed fullscreen"
--   dimensions.
windowedFullscreenFixEventHook :: Event -> X All

-- | Fixes Java applications that don't work well with xmonad, by setting
--   <tt>_JAVA_AWT_WM_NONREPARENTING=1</tt>
javaHack :: XConfig l -> XConfig l

-- | Like <a>trayAbovePanelEventHook</a>, but specialised for
--   trayer/xmobar.
trayerAboveXmobarEventHook :: Event -> X All

-- | Whenever a tray window lowers itself to the bottom of the stack, look
--   for any panels above it and lower these.
trayAbovePanelEventHook :: Query Bool -> Query Bool -> Event -> X All

-- | A simple trayer/xmobar-specific event hook that watches for trayer
--   window resize changes and updates the _XMONAD_TRAYPAD property with
--   xmobar markup that leaves a gap for the trayer.
trayerPaddingXmobarEventHook :: Event -> X All

-- | A generic version of <a>trayerPaddingXmobarEventHook</a> that allows
--   the user to specify how to identify a tray window and the property to
--   use with <a>xmonadPropLog'</a>. This is useful for other trays like
--   stalonetray and also when space for more than one tray-like window
--   needs to be reserved.
trayPaddingXmobarEventHook :: Query Bool -> String -> Event -> X All

-- | A fully generic tray resize hook that invokes a callback whenever a
--   tray-like window changes width.
trayPaddingEventHook :: Query Bool -> (Int -> X ()) -> Event -> X All

-- | A pre-packaged <a>floatConfReqHook</a> that fixes flickering of the
--   Steam client by ignoring <a>ConfigureRequestEvent</a>s on any of its
--   floating windows.
--   
--   To use this, add <a>fixSteamFlicker</a> to your
--   <a>handleEventHook</a>.
fixSteamFlicker :: Event -> X All


-- | <b>Note:</b> This module is a <b>compatibility wrapper</b> for the
--   following:
--   
--   <ul>
--   <li><a>XMonad.Hooks.StatusBar</a></li>
--   <li><a>XMonad.Hooks.StatusBar.PP</a></li>
--   </ul>
--   
--   DynamicLog API is frozen and users are encouraged to migrate to these
--   modern replacements.
--   
--   <i>Original description and documentation follows:</i>
--   
--   xmonad calls the logHook with every internal state update, which is
--   useful for (among other things) outputting status information to an
--   external status bar program such as xmobar or dzen. DynamicLog
--   provides several drop-in logHooks for this purpose, as well as
--   flexible tools for specifying your own formatting.
module XMonad.Hooks.DynamicLog

-- | Run xmonad with a property-based xmobar status bar set to some nice
--   defaults.
--   
--   <pre>
--   main = xmonad $ xmobarProp myConfig
--   
--   myConfig = def { ... }
--   </pre>
--   
--   The intent is that the above config file should provide a nice status
--   bar with minimal effort. Note that you still need to configure xmobar
--   to use the <tt>XMonadLog</tt> plugin instead of the default
--   <tt>StdinReader</tt>, see above.
--   
--   If you wish to customize the status bar format at all, use the
--   modernized interface provided by the <a>XMonad.Hooks.StatusBar</a> and
--   <a>XMonad.Hooks.StatusBar.PP</a> modules instead.
--   
--   The binding uses the <a>XMonad.Hooks.ManageDocks</a> module to
--   automatically handle screen placement for xmobar, and enables 'mod-b'
--   for toggling the menu bar.
xmobarProp :: LayoutClass l Window => XConfig l -> XConfig (ModifiedLayout AvoidStruts l)

-- | This function works like <a>xmobarProp</a>, but uses pipes instead of
--   property-based logging.
xmobar :: LayoutClass l Window => XConfig l -> IO (XConfig (ModifiedLayout AvoidStruts l))

-- | Like <a>statusBarProp</a>, but uses pipes instead of property-based
--   logging. Only use this function if your status bar does not support
--   reading from a property of the root window.
statusBar :: LayoutClass l Window => String -> PP -> (XConfig Layout -> (KeyMask, KeySym)) -> XConfig l -> IO (XConfig (ModifiedLayout AvoidStruts l))

-- | Run xmonad with a dzen status bar set to some nice defaults.
--   
--   <pre>
--   main = xmonad =&lt;&lt; dzen myConfig
--   
--   myConfig = def { ... }
--   </pre>
--   
--   This works pretty much the same as the <a>xmobar</a> function.
dzen :: LayoutClass l Window => XConfig l -> IO (XConfig (ModifiedLayout AvoidStruts l))

-- | Run xmonad with a dzen status bar with specified dzen command line
--   arguments.
--   
--   <pre>
--   main = xmonad =&lt;&lt; dzenWithFlags flags myConfig
--   
--   myConfig = def { ... }
--   
--   flags = "-e onstart lower -w 800 -h 24 -ta l -fg #a8a3f7 -bg #3f3c6d"
--   </pre>
--   
--   This function works much in the same way as the <a>dzen</a> function,
--   only that it can also be used to customize the arguments passed to
--   dzen2, e.g changing the default width and height of dzen2.
--   
--   You should use this function only when the default <a>dzen</a>
--   function does not serve your purpose.
dzenWithFlags :: LayoutClass l Window => String -> XConfig l -> IO (XConfig (ModifiedLayout AvoidStruts l))

-- | An example log hook, which prints status information to stdout in the
--   default format:
--   
--   <pre>
--   1 2 [3] 4 7 : full : title
--   </pre>
--   
--   That is, the currently populated workspaces, the current workspace
--   layout, and the title of the focused window.
--   
--   To customize the output format, see <a>dynamicLogWithPP</a>.
dynamicLog :: X ()

-- | Workspace logger with a format designed for Xinerama:
--   
--   <pre>
--   [1 9 3] 2 7
--   </pre>
--   
--   where 1, 9, and 3 are the workspaces on screens 1, 2 and 3,
--   respectively, and 2 and 7 are non-visible, non-empty workspaces.
--   
--   At the present time, the current layout and window title are not
--   shown. The xinerama workspace format shown above can be (mostly)
--   replicated using <a>dynamicLogWithPP</a> by setting <a>ppSort</a> to
--   <i>getSortByXineramaRule</i> from <a>XMonad.Util.WorkspaceCompare</a>.
--   For example,
--   
--   <pre>
--   def { ppCurrent = dzenColor "red" "#efebe7"
--       , ppVisible = wrap "[" "]"
--       , ppSort    = getSortByXineramaRule
--       }
--   </pre>
dynamicLogXinerama :: X ()

-- | Write a string to the <tt>_XMONAD_LOG</tt> property on the root
--   window.
xmonadPropLog :: String -> X ()

-- | Write a string to a property on the root window. This property is of
--   type <tt>UTF8_STRING</tt>.
xmonadPropLog' :: String -> String -> X ()

-- | The default property xmonad writes to. (<tt>_XMONAD_LOG</tt>).
xmonadDefProp :: String

-- | Format the current status using the supplied pretty-printing format,
--   and write it to stdout.
dynamicLogWithPP :: PP -> X ()

-- | The same as <a>dynamicLogWithPP</a>, except it simply returns the
--   status as a formatted string without actually printing it to stdout,
--   to allow for further processing, or use in some application other than
--   a status bar.
dynamicLogString :: PP -> X String

-- | The <a>PP</a> type allows the user to customize the formatting of
--   status information.
data PP
PP :: (WorkspaceId -> String) -> (WorkspaceId -> String) -> (WorkspaceId -> String) -> (WorkspaceId -> String) -> Maybe (WorkspaceId -> String) -> (WorkspaceId -> String) -> (String -> WindowSpace -> String) -> String -> String -> (String -> String) -> (String -> String) -> (String -> String) -> ([String] -> [String]) -> X ([WindowSpace] -> [WindowSpace]) -> [X (Maybe String)] -> (String -> IO ()) -> WSPP -> PP

-- | how to print the tag of the currently focused workspace
[ppCurrent] :: PP -> WorkspaceId -> String

-- | how to print tags of visible but not focused workspaces (xinerama
--   only)
[ppVisible] :: PP -> WorkspaceId -> String

-- | how to print tags of hidden workspaces which contain windows
[ppHidden] :: PP -> WorkspaceId -> String

-- | how to print tags of empty hidden workspaces
[ppHiddenNoWindows] :: PP -> WorkspaceId -> String

-- | how to print tags of empty visible workspaces
[ppVisibleNoWindows] :: PP -> Maybe (WorkspaceId -> String)

-- | format to be applied to tags of urgent workspaces.
[ppUrgent] :: PP -> WorkspaceId -> String

-- | rename/augment the workspace tag (note that <tt>WindowSpace -&gt;
--   …</tt> acts as a Reader monad)
[ppRename] :: PP -> String -> WindowSpace -> String

-- | separator to use between different log sections (window name, layout,
--   workspaces)
[ppSep] :: PP -> String

-- | separator to use between workspace tags
[ppWsSep] :: PP -> String

-- | window title format for the focused window. To display the titles of
--   all windows—even unfocused ones—check <a>logTitles</a>.
[ppTitle] :: PP -> String -> String

-- | escape / sanitizes input to <a>ppTitle</a>
[ppTitleSanitize] :: PP -> String -> String

-- | layout name format
[ppLayout] :: PP -> String -> String

-- | how to order the different log sections. By default, this function
--   receives a list with three formatted strings, representing the
--   workspaces, the layout, and the current window titles, respectively.
--   If you have specified any extra loggers in <a>ppExtras</a>, their
--   output will also be appended to the list. To get them in the reverse
--   order, you can just use <tt>ppOrder = reverse</tt>. If you don't want
--   to display the current layout, you could use something like
--   <tt>ppOrder = \(ws:_:t:_) -&gt; [ws,t]</tt>, and so on.
[ppOrder] :: PP -> [String] -> [String]

-- | how to sort the workspaces. See <a>XMonad.Util.WorkspaceCompare</a>
--   for some useful sorts.
[ppSort] :: PP -> X ([WindowSpace] -> [WindowSpace])

-- | loggers for generating extra information such as time and date, system
--   load, battery status, and so on. See <a>XMonad.Util.Loggers</a> for
--   examples, or create your own!
[ppExtras] :: PP -> [X (Maybe String)]

-- | applied to the entire formatted string in order to output it. Can be
--   used to specify an alternative output method (e.g. write to a pipe
--   instead of stdout), and/or to perform some last-minute formatting.
--   Note that this is only used by <a>dynamicLogWithPP</a>; it won't work
--   with <a>dynamicLogString</a> or <a>XMonad.Hooks.StatusBar</a>.
[ppOutput] :: PP -> String -> IO ()

-- | extend workspace types with custom predicates. Check $predicates for
--   more details.
[ppPrinters] :: PP -> WSPP

-- | The default value for this type.
def :: Default a => a

-- | Settings to emulate dwm's statusbar, dzen only.
dzenPP :: PP

-- | Some nice xmobar defaults.
xmobarPP :: PP

-- | The options that sjanssen likes to use with xmobar, as an example.
--   Note the use of <a>xmobarColor</a> and the record update on
--   <a>def</a>.
sjanssenPP :: PP

-- | The options that byorgey likes to use with dzen, as another example.
byorgeyPP :: PP

-- | Wrap a string in delimiters, unless it is empty.
wrap :: String -> String -> String -> String

-- | Pad a string with a leading and trailing space.
pad :: String -> String

-- | Trim leading and trailing whitespace from a string.
trim :: String -> String

-- | Limit a string to a certain length, adding "..." if truncated.
shorten :: Int -> String -> String

-- | Limit a string to a certain length, adding <tt>end</tt> if truncated.
shorten' :: String -> Int -> String -> String

-- | Like <a>shorten</a>, but truncate from the left instead of right.
shortenLeft :: Int -> String -> String

-- | Like <a>shorten'</a>, but truncate from the left instead of right.
shortenLeft' :: String -> Int -> String -> String

-- | Use xmobar escape codes to output a string with given foreground and
--   background colors.
xmobarColor :: String -> String -> String -> String

-- | Encapsulate text with an action. The text will be displayed, and the
--   action executed when the displayed text is clicked. Illegal input is
--   not filtered, allowing xmobar to display any parse errors. Uses
--   xmobar's new syntax wherein the command is surrounded by backticks.
xmobarAction :: String -> String -> String -> String

-- | Use xmobar box to add a border to an arbitrary string.
xmobarBorder :: String -> String -> Int -> String -> String

-- | Encapsulate arbitrary text for display only, i.e. untrusted content if
--   wrapped (perhaps from window titles) will be displayed only, with all
--   tags ignored. Introduced in xmobar 0.21; see their documentation. Be
--   careful not to shorten the result.
xmobarRaw :: String -> String

-- | Strip xmobar markup, specifically the &lt;fc&gt;, &lt;icon&gt; and
--   &lt;action&gt; tags and the matching tags like &lt;/fc&gt;.
xmobarStrip :: String -> String
xmobarStripTags :: [String] -> String -> String

-- | Use dzen escape codes to output a string with given foreground and
--   background colors.
dzenColor :: String -> String -> String -> String

-- | Escape any dzen metacharacters.
dzenEscape :: String -> String

-- | Strip dzen formatting or commands.
dzenStrip :: String -> String

-- | Transforms a pretty-printer into one not displaying the given
--   workspaces.
--   
--   For example, filtering out the <tt>NSP</tt> workspace before giving
--   the <a>PP</a> to <a>dynamicLogWithPP</a>:
--   
--   <pre>
--   logHook = dynamicLogWithPP . filterOutWsPP [scratchpadWorkspaceTag] $ def
--   </pre>
--   
--   Here is another example, when using
--   <a>XMonad.Layout.IndependentScreens</a>. If you have handles
--   <tt>hLeft</tt> and <tt>hRight</tt> for bars on the left and right
--   screens, respectively, and <tt>pp</tt> is a pretty-printer function
--   that takes a handle, you could write
--   
--   <pre>
--   logHook = let log screen handle = dynamicLogWithPP . filterOutWsPP [scratchpadWorkspaceTag] . marshallPP screen . pp $ handle
--             in log 0 hLeft &gt;&gt; log 1 hRight
--   </pre>
filterOutWsPP :: [WorkspaceId] -> PP -> PP

-- | Format the workspace information, given a workspace sorting function,
--   a list of urgent windows, a pretty-printer format, and the current
--   WindowSet.
pprWindowSet :: WorkspaceSort -> [Window] -> PP -> WindowSet -> String
pprWindowSetXinerama :: WindowSet -> String


-- | Manage per-screen status bars.

-- | <i>Deprecated: Use XMonad.Hooks.StatusBar instead</i>
module XMonad.Hooks.DynamicBars
type DynamicStatusBar = ScreenId -> IO Handle
type DynamicStatusBarCleanup = IO ()
type DynamicStatusBarPartialCleanup = ScreenId -> IO ()
dynStatusBarStartup :: DynamicStatusBar -> DynamicStatusBarCleanup -> X ()
dynStatusBarStartup' :: DynamicStatusBar -> DynamicStatusBarPartialCleanup -> X ()
dynStatusBarEventHook :: DynamicStatusBar -> DynamicStatusBarCleanup -> Event -> X All
dynStatusBarEventHook' :: DynamicStatusBar -> DynamicStatusBarPartialCleanup -> Event -> X All
multiPP :: PP -> PP -> X ()
multiPPFormat :: (PP -> X String) -> PP -> PP -> X ()
instance XMonad.Core.ExtensionClass XMonad.Hooks.DynamicBars.DynStatusBarInfo


-- | Move and resize floating windows using other windows and the edge of
--   the screen as guidelines.
module XMonad.Actions.FloatSnap

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D

-- | Move a window in the specified direction until it snaps against
--   another window or the edge of the screen.
snapMove :: Direction2D -> Maybe Int -> Window -> X ()

-- | Grow the specified edge of a window until it snaps against another
--   window or the edge of the screen.
snapGrow :: Direction2D -> Maybe Int -> Window -> X ()

-- | Shrink the specified edge of a window until it snaps against another
--   window or the edge of the screen.
snapShrink :: Direction2D -> Maybe Int -> Window -> X ()

-- | Move a window by both axises in any direction to snap against the
--   closest part of other windows or the edge of the screen.
snapMagicMove :: Maybe Int -> Maybe Int -> Window -> X ()

-- | Resize the window by each edge independently to snap against the
--   closest part of other windows or the edge of the screen.
snapMagicResize :: [Direction2D] -> Maybe Int -> Maybe Int -> Window -> X ()

-- | Resize the window by each edge independently to snap against the
--   closest part of other windows or the edge of the screen. Use the
--   location of the mouse over the window to decide which edges to snap.
--   In corners, the two adjoining edges will be snapped, along the middle
--   of an edge only that edge will be snapped. In the center of the window
--   all edges will snap. Intended to be used together with
--   <a>XMonad.Actions.FlexibleResize</a> or
--   <a>XMonad.Actions.FlexibleManipulate</a>.
snapMagicMouseResize :: Rational -> Maybe Int -> Maybe Int -> Window -> X ()

-- | Schedule a task to take place after the current dragging is completed.
afterDrag :: X () -> X ()

-- | Take an action if the current dragging can be considered a click,
--   supposing the drag just started before this function is called. A drag
--   is considered a click if it is completed within 300 ms.
ifClick :: X () -> X ()

-- | Take an action if the current dragging is completed within a certain
--   time (in milliseconds.)
ifClick' :: Int -> X () -> X () -> X ()


-- | Makes xmonad use the <a>EWMH</a> hints to tell panel applications
--   about its workspaces and the windows therein. It also allows the user
--   to interact with xmonad by clicking on panels and window lists.
module XMonad.Hooks.EwmhDesktops

-- | Add EWMH support for workspaces (virtual desktops) to the given
--   <a>XConfig</a>. See above for an example.
ewmh :: XConfig a -> XConfig a

-- | Add EWMH fullscreen functionality to the given config.
ewmhFullscreen :: XConfig a -> XConfig a

-- | A <a>ManageHook</a> that shifts windows to the workspace they want to
--   be in. Useful for restoring browser windows to where they were before
--   restart.
--   
--   To only use this for browsers (which might be a good idea, as many
--   apps try to restore their window to their original position, but it's
--   rarely desirable outside of security updates of multi-window apps like
--   a browser), use this:
--   
--   <pre>
--   stringProperty "WM_WINDOW_ROLE" =? "browser" --&gt; ewmhDesktopsManageHook
--   </pre>
ewmhDesktopsManageHook :: ManageHook

-- | <a>ewmhDesktopsManageHook</a> as a <a>MaybeManageHook</a> for use with
--   <a>composeOne</a>. Returns <a>Nothing</a> if the window didn't
--   indicate any desktop preference, otherwise <a>Just</a> (even if the
--   preferred desktop was out of bounds).
ewmhDesktopsMaybeManageHook :: MaybeManageHook

-- | Add (compose after) an arbitrary user-specified function to
--   sort/filter the workspace list. The default/initial function is
--   <a>getSortByIndex</a>. This can be used to e.g. filter out scratchpad
--   workspaces. Workspaces <i>must not</i> be renamed here.
addEwmhWorkspaceSort :: X WorkspaceSort -> XConfig l -> XConfig l

-- | Like <a>addEwmhWorkspaceSort</a>, but replace it instead of
--   adding/composing.
setEwmhWorkspaceSort :: X WorkspaceSort -> XConfig l -> XConfig l

-- | Add (compose after) an arbitrary user-specified function to rename
--   each workspace. This works just like <a>ppRename</a>: the
--   <tt>WindowSpace -&gt; …</tt> acts as a Reader monad. Useful with
--   <a>XMonad.Actions.WorkspaceNames</a>,
--   <a>XMonad.Layout.IndependentScreens</a>,
--   <a>XMonad.Hooks.DynamicIcons</a>.
addEwmhWorkspaceRename :: X (String -> WindowSpace -> String) -> XConfig l -> XConfig l

-- | Like <a>addEwmhWorkspaceRename</a>, but replace it instead of
--   adding/composing.
setEwmhWorkspaceRename :: X (String -> WindowSpace -> String) -> XConfig l -> XConfig l

-- | Set (replace) the hook which is invoked when a client sends a
--   <tt>_NET_ACTIVE_WINDOW</tt> request to activate a window. The default
--   is <a>doFocus</a> which focuses the window immediately, switching
--   workspace if necessary. <a>doAskUrgent</a> is a less intrusive
--   alternative.
--   
--   More complex hooks can be constructed using combinators from
--   <a>XMonad.ManageHook</a>, <a>XMonad.Hooks.ManageHelpers</a> and
--   <a>XMonad.Hooks.Focus</a>.
setEwmhActivateHook :: ManageHook -> XConfig l -> XConfig l
setEwmhFullscreenHooks :: ManageHook -> ManageHook -> XConfig l -> XConfig l
disableEwmhManageDesktopViewport :: XConfig l -> XConfig l

-- | Initializes EwmhDesktops and advertises EWMH support to the X server.

-- | <i>Deprecated: Use ewmh instead.</i>
ewmhDesktopsStartup :: X ()

-- | Notifies pagers and window lists, such as those in the gnome-panel of
--   the current state of workspaces and windows.

-- | <i>Deprecated: Use ewmh instead.</i>
ewmhDesktopsLogHook :: X ()

-- | Generalized version of ewmhDesktopsLogHook that allows an arbitrary
--   user-specified function to sort/filter the workspace list
--   (post-sorting).

-- | <i>Deprecated: Use ewmh and addEwmhWorkspaceSort instead.</i>
ewmhDesktopsLogHookCustom :: WorkspaceSort -> X ()

-- | Intercepts messages from pagers and similar applications and reacts on
--   them.
--   
--   Currently supports:
--   
--   <ul>
--   <li>_NET_CURRENT_DESKTOP (switching desktops)</li>
--   <li>_NET_WM_DESKTOP (move windows to other desktops)</li>
--   <li>_NET_ACTIVE_WINDOW (activate another window, changing workspace if
--   needed)</li>
--   <li>_NET_CLOSE_WINDOW (close window)</li>
--   </ul>

-- | <i>Deprecated: Use ewmh instead.</i>
ewmhDesktopsEventHook :: Event -> X All

-- | Generalized version of ewmhDesktopsEventHook that allows an arbitrary
--   user-specified function to sort/filter the workspace list
--   (post-sorting).

-- | <i>Deprecated: Use ewmh and addEwmhWorkspaceSort instead.</i>
ewmhDesktopsEventHookCustom :: WorkspaceSort -> Event -> X All

-- | An event hook to handle applications that wish to fullscreen using the
--   <tt>_NET_WM_STATE</tt> protocol. This includes users of the
--   <tt>gtk_window_fullscreen()</tt> function, such as Totem, Evince and
--   OpenOffice.org.
--   
--   Note this is not included in <a>ewmh</a>.

-- | <i>Deprecated: Use ewmhFullscreen instead.</i>
fullscreenEventHook :: Event -> X All

-- | Advertises EWMH fullscreen support to the X server.

-- | <i>Deprecated: Use ewmhFullscreen instead.</i>
fullscreenStartup :: X ()
instance GHC.Classes.Eq XMonad.Hooks.EwmhDesktops.DesktopNames
instance GHC.Classes.Eq XMonad.Hooks.EwmhDesktops.ClientList
instance GHC.Classes.Eq XMonad.Hooks.EwmhDesktops.ClientListStacking
instance GHC.Classes.Eq XMonad.Hooks.EwmhDesktops.CurrentDesktop
instance GHC.Classes.Eq XMonad.Hooks.EwmhDesktops.WindowDesktops
instance GHC.Classes.Eq XMonad.Hooks.EwmhDesktops.ActiveWindow
instance GHC.Classes.Eq XMonad.Hooks.EwmhDesktops.MonitorTags
instance GHC.Show.Show XMonad.Hooks.EwmhDesktops.MonitorTags
instance XMonad.Core.ExtensionClass XMonad.Hooks.EwmhDesktops.MonitorTags
instance XMonad.Core.ExtensionClass XMonad.Hooks.EwmhDesktops.ActiveWindow
instance XMonad.Core.ExtensionClass XMonad.Hooks.EwmhDesktops.WindowDesktops
instance XMonad.Core.ExtensionClass XMonad.Hooks.EwmhDesktops.CurrentDesktop
instance XMonad.Core.ExtensionClass XMonad.Hooks.EwmhDesktops.ClientListStacking
instance XMonad.Core.ExtensionClass XMonad.Hooks.EwmhDesktops.ClientList
instance XMonad.Core.ExtensionClass XMonad.Hooks.EwmhDesktops.DesktopNames
instance Data.Default.Class.Default XMonad.Hooks.EwmhDesktops.EwmhDesktopsConfig


-- | Hooks for sending messages about fullscreen windows to layouts, and a
--   few example layout modifier that implement fullscreen windows.
module XMonad.Layout.Fullscreen

-- | Modifies your config to apply basic fullscreen support -- fullscreen
--   windows when they request it. Example usage:
--   
--   <pre>
--   main = xmonad
--        $ fullscreenSupport
--        $ def { ... }
--   </pre>
fullscreenSupport :: LayoutClass l Window => XConfig l -> XConfig (ModifiedLayout FullscreenFull l)

-- | fullscreenSupport with smartBorders support so the border doesn't show
--   when the window is fullscreen
--   
--   <pre>
--   main = xmonad
--        $ fullscreenSupportBorder
--        $ def { ... }
--   </pre>
fullscreenSupportBorder :: LayoutClass l Window => XConfig l -> XConfig (ModifiedLayout FullscreenFull (ModifiedLayout SmartBorder (ModifiedLayout FullscreenFull l)))

-- | Layout modifier that makes fullscreened window fill the entire screen.
fullscreenFull :: LayoutClass l a => l a -> ModifiedLayout FullscreenFull l a

-- | Layout modifier that makes the fullscreened window fill the entire
--   screen only if it is currently focused.
fullscreenFocus :: LayoutClass l a => l a -> ModifiedLayout FullscreenFocus l a

-- | As above, but the fullscreened window will fill the specified
--   rectangle instead of the entire screen.
fullscreenFullRect :: LayoutClass l a => RationalRect -> l a -> ModifiedLayout FullscreenFull l a

-- | As above, but the fullscreened window will fill the specified
--   rectangle instead of the entire screen.
fullscreenFocusRect :: LayoutClass l a => RationalRect -> l a -> ModifiedLayout FullscreenFocus l a

-- | Hackish layout modifier that makes floating fullscreened windows fill
--   the entire screen.
fullscreenFloat :: LayoutClass l a => l a -> ModifiedLayout FullscreenFloat l a

-- | As above, but the fullscreened window will fill the specified
--   rectangle instead of the entire screen.
fullscreenFloatRect :: LayoutClass l a => RationalRect -> l a -> ModifiedLayout FullscreenFloat l a

-- | The event hook required for the layout modifiers to work
fullscreenEventHook :: Event -> X All

-- | Manage hook that sets the fullscreen property for windows that are
--   initially fullscreen
fullscreenManageHook :: ManageHook

-- | A version of fullscreenManageHook that lets you specify your own query
--   to decide whether a window should be fullscreen.
fullscreenManageHookWith :: Query Bool -> ManageHook

-- | Messages that control the fullscreen state of the window.
--   AddFullscreen and RemoveFullscreen are sent to all layouts when a
--   window wants or no longer wants to be fullscreen. FullscreenChanged is
--   sent to the current layout after one of the above have been sent.
data FullscreenMessage
AddFullscreen :: Window -> FullscreenMessage
RemoveFullscreen :: Window -> FullscreenMessage
FullscreenChanged :: FullscreenMessage
data FullscreenFloat a
data FullscreenFocus a
data FullscreenFull a
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.Fullscreen.FullscreenFull a)
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Layout.Fullscreen.FullscreenFull a)
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.Fullscreen.FullscreenFocus a)
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Layout.Fullscreen.FullscreenFocus a)
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.Fullscreen.FullscreenFloat a)
instance (GHC.Classes.Ord a, GHC.Read.Read a) => GHC.Read.Read (XMonad.Layout.Fullscreen.FullscreenFloat a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Fullscreen.FullscreenFloat Graphics.X11.Types.Window
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Fullscreen.FullscreenFocus Graphics.X11.Types.Window
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.Fullscreen.FullscreenFull Graphics.X11.Types.Window
instance XMonad.Core.Message XMonad.Layout.Fullscreen.FullscreenMessage


-- | This module provides a config suitable for use with a desktop
--   environment such as KDE or GNOME.
module XMonad.Config.Desktop
desktopConfig :: XConfig (ModifiedLayout AvoidStruts (Choose Tall (Choose (Mirror Tall) Full)))
desktopLayoutModifiers :: LayoutClass l a => l a -> ModifiedLayout AvoidStruts l a


-- | This module provides a config suitable for use with the Xfce desktop
--   environment.
module XMonad.Config.Xfce
xfceConfig :: XConfig (ModifiedLayout AvoidStruts (Choose Tall (Choose (Mirror Tall) Full)))
desktopLayoutModifiers :: LayoutClass l a => l a -> ModifiedLayout AvoidStruts l a


-- | This module provides a config suitable for use with the MATE desktop
--   environment.
module XMonad.Config.Mate
mateConfig :: XConfig (ModifiedLayout AvoidStruts (Choose Tall (Choose (Mirror Tall) Full)))

-- | Launch the "Run Application" dialog. mate-panel must be running for
--   this to work. partial application for existing keybinding
--   compatibility.
mateRun :: X ()

-- | Launch a panel action. Either the "Run Application" dialog
--   ("run_dialog" parameter, see above) or the main menu ("main_menu"
--   parameter). mate-panel must be running for this to work.
matePanel :: String -> X ()

-- | Register xmonad with mate. 'dbus-send' must be in the $PATH with which
--   xmonad is started.
--   
--   This action reduces a delay on startup only if you have configured
--   mate-session to start xmonad with a command such as (check local
--   documentation):
--   
--   <pre>
--   dconf write /org/mate/desktop/session/required_components/windowmanager "'xmonad'"
--   </pre>
--   
--   (the extra quotes are required by dconf)
mateRegister :: MonadIO m => m ()

-- | Display MATE logout dialog. This is the default mod-q action.
mateLogout :: MonadIO m => m ()

-- | Display MATE shutdown dialog. You can override mod-q to invoke this,
--   or bind it to another key if you prefer.
mateShutdown :: MonadIO m => m ()
desktopLayoutModifiers :: LayoutClass l a => l a -> ModifiedLayout AvoidStruts l a


-- | This module provides a config suitable for use with the KDE desktop
--   environment.
module XMonad.Config.Kde
kdeConfig :: XConfig (ModifiedLayout AvoidStruts (Choose Tall (Choose (Mirror Tall) Full)))
kde4Config :: XConfig (ModifiedLayout AvoidStruts (Choose Tall (Choose (Mirror Tall) Full)))
desktopLayoutModifiers :: LayoutClass l a => l a -> ModifiedLayout AvoidStruts l a


-- | This module provides a config suitable for use with the GNOME desktop
--   environment.
module XMonad.Config.Gnome
gnomeConfig :: XConfig (ModifiedLayout AvoidStruts (Choose Tall (Choose (Mirror Tall) Full)))

-- | Launch the "Run Application" dialog. gnome-panel must be running for
--   this to work.
gnomeRun :: X ()

-- | Register xmonad with gnome. 'dbus-send' must be in the $PATH with
--   which xmonad is started.
--   
--   This action reduces a delay on startup only only if you have
--   configured gnome-session&gt;=2.26: to start xmonad with a command as
--   such:
--   
--   <pre>
--   gconftool-2 -s /desktop/gnome/session/required_components/windowmanager xmonad --type string
--   </pre>
gnomeRegister :: MonadIO m => m ()
desktopLayoutModifiers :: LayoutClass l a => l a -> ModifiedLayout AvoidStruts l a


-- | Provides bindings to rename workspaces, show these names in a status
--   bar and swap workspaces along with their names. These names survive
--   restart. Together with <a>XMonad.Layout.WorkspaceDir</a> this provides
--   for a fully dynamic topic space workflow.
module XMonad.Actions.WorkspaceNames

-- | Prompt for a new name for the current workspace and set it.
renameWorkspace :: XPConfig -> X ()

-- | Returns a lookup function that maps workspace tags to workspace names.
getWorkspaceNames' :: X (WorkspaceId -> Maybe String)

-- | Returns a function for <a>ppRename</a> that appends <tt>sep</tt> and
--   the workspace name, if set.
getWorkspaceNames :: String -> X (String -> WindowSpace -> String)

-- | Gets the name of a workspace, if set, otherwise returns nothing.
getWorkspaceName :: WorkspaceId -> X (Maybe String)

-- | Gets the name of the current workspace. See <a>getWorkspaceName</a>
getCurrentWorkspaceName :: X (Maybe String)

-- | Sets the name of a workspace. Empty string makes the workspace unnamed
--   again.
setWorkspaceName :: WorkspaceId -> String -> X ()

-- | Sets the name of the current workspace. See <a>setWorkspaceName</a>.
setCurrentWorkspaceName :: String -> X ()

-- | See <a>swapTo</a>. This is the same with names.
swapTo :: Direction1D -> X ()

-- | Swap with the previous or next workspace of the given type.
swapTo' :: Direction1D -> WSType -> X ()

-- | See <a>swapWithCurrent</a>. This is almost the same with names.
swapWithCurrent :: WorkspaceId -> X ()

-- | Same behavior than <a>workspacePrompt</a> excepted it acts on the
--   workspace name provided by this module.
workspaceNamePrompt :: XPConfig -> (WorkspaceId -> X ()) -> X ()

-- | Modify <a>PP</a>'s pretty-printing format to show workspace names as
--   well.
workspaceNamesPP :: PP -> X PP

-- | Tell <a>XMonad.Hooks.EwmhDesktops</a> to append workspace names to
--   desktop names.
workspaceNamesEwmh :: XConfig l -> XConfig l
instance GHC.Show.Show XMonad.Actions.WorkspaceNames.WorkspaceNames
instance GHC.Read.Read XMonad.Actions.WorkspaceNames.WorkspaceNames
instance XMonad.Core.ExtensionClass XMonad.Actions.WorkspaceNames.WorkspaceNames


module XMonad.Actions.ToggleFullFloat

-- | Hook this module into <a>ewmhFullscreen</a>. This makes windows
--   restore their original state (size and position if floating) instead
--   of unconditionally sinking into the tiling layer.
--   
--   (<a>gcToggleFullFloat</a> is included here.)
toggleFullFloatEwmhFullscreen :: XConfig a -> XConfig a

-- | Full-float a window, if it's not already full-floating. Otherwise,
--   restore its original state.
toggleFullFloat :: Window -> X ()

-- | Full-float a window, remembering its state (tiled/floating and
--   position/size).
fullFloat :: Window -> X ()

-- | Restore window to its remembered state.
unFullFloat :: Window -> X ()

-- | Install ToggleFullFloat garbage collection hooks.
--   
--   Note: This is included in <a>toggleFullFloatEwmhFullscreen</a>, only
--   needed if using the <a>toggleFullFloat</a> separately from the EWMH
--   hook.
gcToggleFullFloat :: XConfig a -> XConfig a
instance GHC.Read.Read XMonad.Actions.ToggleFullFloat.ToggleFullFloat
instance GHC.Show.Show XMonad.Actions.ToggleFullFloat.ToggleFullFloat
instance XMonad.Core.ExtensionClass XMonad.Actions.ToggleFullFloat.ToggleFullFloat


-- | Adds actions for minimizing and maximizing windows
--   
--   This module should be used with <a>XMonad.Layout.Minimize</a>. Add
--   <tt>minimize</tt> to your layout modifiers as described in
--   <a>XMonad.Layout.Minimize</a> and use actions from this module
--   
--   Possible keybindings:
--   
--   <pre>
--   , ((modm,               xK_m     ), withFocused minimizeWindow)
--   , ((modm .|. shiftMask, xK_m     ), withLastMinimized maximizeWindowAndFocus)
--   </pre>
module XMonad.Actions.Minimize

-- | Minimize a window
minimizeWindow :: Window -> X ()

-- | Just maximize a window without focusing
maximizeWindow :: Window -> X ()

-- | Maximize a window and then focus it
maximizeWindowAndFocus :: Window -> X ()

-- | Perform an action with last minimized window on current workspace or
--   do nothing if there is no minimized windows on current workspace
withLastMinimized :: (Window -> X ()) -> X ()

-- | Like withLastMinimized but the provided action is always invoked with
--   a 'Maybe Window', that will be nothing if there is no last minimized
--   window.
withLastMinimized' :: (Maybe Window -> X ()) -> X ()

-- | Perform an action with first minimized window on current workspace or
--   do nothing if there is no minimized windows on current workspace
withFirstMinimized :: (Window -> X ()) -> X ()

-- | Like withFirstMinimized but the provided action is always invoked with
--   a 'Maybe Window', that will be nothing if there is no first minimized
--   window.
withFirstMinimized' :: (Maybe Window -> X ()) -> X ()
withMinimized :: ([Window] -> X a) -> X a


-- | Handles window manager hints to minimize and restore windows. Use this
--   with <a>XMonad.Layout.Minimize</a>.
module XMonad.Hooks.Minimize
minimizeEventHook :: Event -> X All


-- | Named scratchpads that can be mutually exclusive.

-- | <i>Deprecated: Use the exclusive scratchpad functionality of
--   <a>XMonad.Util.NamedScratchpad</a> insead.</i>
module XMonad.Util.ExclusiveScratchpads

-- | Create <a>ExclusiveScratchpads</a> from <tt>[(name,cmd,query)]</tt>
--   with a common <tt>hook</tt>
mkXScratchpads :: [(String, String, Query Bool)] -> ManageHook -> ExclusiveScratchpads

-- | Create <a>ManageHook</a> from <a>ExclusiveScratchpads</a>
xScratchpadsManageHook :: ExclusiveScratchpads -> ManageHook

-- | Pop up/hide the scratchpad by name and possibly hide its exclusive
scratchpadAction :: ExclusiveScratchpads -> String -> X ()

-- | Hide all <a>ExclusiveScratchpads</a> on the current screen
hideAll :: ExclusiveScratchpads -> X ()

-- | If the focused window is a scratchpad, the scratchpad gets reset to
--   the original placement specified with the hook and becomes exclusive
--   again
resetExclusiveSp :: ExclusiveScratchpads -> X ()

-- | Make a window not exclusive anymore
setNoexclusive :: ExclusiveScratchpads -> Window -> X ()

-- | Resize window, make it not exclusive anymore
resizeNoexclusive :: ExclusiveScratchpads -> Window -> X ()

-- | Float and drag the window, make it not exclusive anymore
floatMoveNoexclusive :: ExclusiveScratchpads -> Window -> X ()
data ExclusiveScratchpad
XSP :: String -> String -> Query Bool -> ManageHook -> [String] -> ExclusiveScratchpad

-- | Name of the scratchpad
[name] :: ExclusiveScratchpad -> String

-- | Command to spawn the scratchpad
[cmd] :: ExclusiveScratchpad -> String

-- | Query to match the scratchpad
[query] :: ExclusiveScratchpad -> Query Bool

-- | Hook to specify the placement policy
[hook] :: ExclusiveScratchpad -> ManageHook

-- | Names of exclusive scratchpads
[exclusive] :: ExclusiveScratchpad -> [String]
type ExclusiveScratchpads = [ExclusiveScratchpad]

-- | Manage hook that makes the window non-floating
nonFloating :: ManageHook

-- | Manage hook that makes the window floating with the default placement
defaultFloating :: ManageHook

-- | Manage hook that makes the window floating with custom placement
customFloating :: RationalRect -> ManageHook


-- | Provides a way to modify a window spawned by a command(e.g shift it to
--   the workspace it was launched on) by using the _NET_WM_PID property
--   that most windows set on creation. Hence this module won't work on
--   applications that don't set this property.
module XMonad.Actions.SpawnOn
data Spawner

-- | Provides a manage hook to react on process spawned with
--   <a>spawnOn</a>, <a>spawnHere</a> etc.
manageSpawn :: ManageHook
manageSpawnWithGC :: ([(ProcessID, ManageHook)] -> X [(ProcessID, ManageHook)]) -> ManageHook

-- | Replacement for <a>spawn</a> which launches application on current
--   workspace.
spawnHere :: String -> X ()

-- | Replacement for <a>spawn</a> which launches application on given
--   workspace.
spawnOn :: WorkspaceId -> String -> X ()

-- | Spawn an application and apply the manage hook when it opens.
spawnAndDo :: ManageHook -> String -> X ()

-- | Replacement for Shell prompt (<a>XMonad.Prompt.Shell</a>) which
--   launches application on current workspace.
shellPromptHere :: XPConfig -> X ()

-- | Replacement for Shell prompt (<a>XMonad.Prompt.Shell</a>) which
--   launches application on given workspace.
shellPromptOn :: WorkspaceId -> XPConfig -> X ()
instance XMonad.Core.ExtensionClass XMonad.Actions.SpawnOn.Spawner


-- | A module for spawning a command once, and only once. Useful to start
--   status bars and make session settings inside startupHook. See also
--   <a>XMonad.Util.SessionStart</a> for a different and more flexible way
--   to run commands only on first startup.
module XMonad.Util.SpawnOnce

-- | The first time <a>spawnOnce</a> is executed on a particular command,
--   that command is executed. Subsequent invocations for a command do
--   nothing.
spawnOnce :: String -> X ()

-- | Provides a manage hook to react on process spawned with
--   <a>spawnOn</a>, <a>spawnHere</a> etc.
manageSpawn :: ManageHook

-- | Like <a>spawnOnce</a> but launches the application on the given
--   workspace.
spawnOnOnce :: WorkspaceId -> String -> X ()

-- | Lanch the given application n times on the specified workspace.
--   Subsequent attempts to spawn this application will be ignored.
spawnNOnOnce :: Int -> WorkspaceId -> String -> X ()

-- | Spawn the application once and apply the manage hook. Subsequent
--   attempts to spawn this application will be ignored.
spawnAndDoOnce :: ManageHook -> String -> X ()
instance GHC.Show.Show XMonad.Util.SpawnOnce.SpawnOnce
instance GHC.Read.Read XMonad.Util.SpawnOnce.SpawnOnce
instance XMonad.Core.ExtensionClass XMonad.Util.SpawnOnce.SpawnOnce



-- | <i>Deprecated: This module contains a personal configuration, to be
--   removed from xmonad-contrib. If you use this module, please copy the
--   relevant parts to your configuration or obtain a copy of it on
--   <a>https://xmonad.org/configurations.html</a> and include it as a
--   local module.</i>
module XMonad.Config.Dmwit
outputOf :: String -> IO String
geomMean :: Floating a => [a] -> a
arithMean :: Floating a => [a] -> a
namedNumbers :: [Char] -> String -> [[Char]]
splitColon :: [Char] -> [[Char]]
parse :: (Floating a, Read a) => String -> a
modVolume :: String -> Integer -> IO Double
centerMouse :: X ()
statusBarMouse :: X ()
withScreen :: ScreenId -> (WorkspaceId -> WindowSet -> WindowSet) -> X ()
makeLauncher :: [Char] -> [Char] -> [Char] -> [Char] -> [Char]
launcher :: [Char]
termLauncher :: [Char]
viewShift :: (Ord a, Eq s, Eq i) => i -> StackSet i l a s sd -> StackSet i l a s sd
floatAll :: [String] -> Query (Endo WindowSet)
sinkFocus :: Ord a => StackSet i l a s sd -> StackSet i l a s sd
showMod :: String -> Integer -> X ()
volumeDzen :: String -> X ()
altMask :: KeyMask
bright :: String
dark :: String
fullscreen43on169 :: RationalRect
fullscreenMPlayer :: Query (Endo (StackSet PhysicalWorkspace (Layout Window) Window ScreenId ScreenDetail))
operationOn :: (Ord t, Eq s) => (t -> StackSet PhysicalWorkspace l t s sd -> StackSet PhysicalWorkspace l t s sd) -> ScreenId -> VirtualWorkspace -> t -> Query (Endo (StackSet PhysicalWorkspace l t s sd))
viewFullOn :: (Ord t, Eq s) => ScreenId -> VirtualWorkspace -> t -> Query (Endo (StackSet PhysicalWorkspace l t s sd))
centerWineOn :: (Ord t, Eq s) => ScreenId -> VirtualWorkspace -> t -> Query (Endo (StackSet PhysicalWorkspace l t s sd))
class Show a => PPrint a
pprint :: PPrint a => Int -> a -> String
data PPrintable
P :: a -> PPrintable
record :: String -> Int -> [(String, PPrintable)] -> String
dmwitConfig :: ScreenId -> XConfig (ModifiedLayout Magnifier (Choose (ModifiedLayout AvoidStruts Grid) (ModifiedLayout WithBorder Full)))
main :: IO ()
keyBindings :: XConfig Layout -> Map (KeyMask, KeySym) (X ())
atSchool :: MonadIO m => b -> b -> m b
anyMask :: [((KeyMask, b), b)] -> [((KeyMask, b), b)]
pipeName :: Show a => [Char] -> a -> [Char]
xmobarCommand :: ScreenId -> String
allPPs :: ScreenId -> X ()
color :: String -> String -> String
ppFocus :: ScreenId -> PP
ppWorkspaces :: ScreenId -> PP
instance GHC.Show.Show XMonad.Config.Dmwit.PPrintable
instance XMonad.Config.Dmwit.PPrint XMonad.Config.Dmwit.PPrintable
instance XMonad.Config.Dmwit.PPrint Graphics.X11.Xlib.Types.Rectangle
instance XMonad.Config.Dmwit.PPrint a => XMonad.Config.Dmwit.PPrint (XMonad.StackSet.Stack a)
instance (XMonad.Config.Dmwit.PPrint i, XMonad.Config.Dmwit.PPrint l, XMonad.Config.Dmwit.PPrint a) => XMonad.Config.Dmwit.PPrint (XMonad.StackSet.Workspace i l a)
instance XMonad.Config.Dmwit.PPrint XMonad.Core.ScreenDetail
instance (XMonad.Config.Dmwit.PPrint i, XMonad.Config.Dmwit.PPrint l, XMonad.Config.Dmwit.PPrint a, XMonad.Config.Dmwit.PPrint sid, XMonad.Config.Dmwit.PPrint sd) => XMonad.Config.Dmwit.PPrint (XMonad.StackSet.Screen i l a sid sd)
instance (XMonad.Config.Dmwit.PPrint i, XMonad.Config.Dmwit.PPrint l, XMonad.Config.Dmwit.PPrint a, XMonad.Config.Dmwit.PPrint sid, XMonad.Config.Dmwit.PPrint sd) => XMonad.Config.Dmwit.PPrint (XMonad.StackSet.StackSet i l a sid sd)
instance XMonad.Config.Dmwit.PPrint a => XMonad.Config.Dmwit.PPrint (GHC.Maybe.Maybe a)
instance XMonad.Config.Dmwit.PPrint a => XMonad.Config.Dmwit.PPrint [a]
instance XMonad.Config.Dmwit.PPrint (XMonad.Core.Layout a)
instance XMonad.Config.Dmwit.PPrint GHC.Types.Int
instance XMonad.Config.Dmwit.PPrint Graphics.X11.Xlib.Types.Screen
instance XMonad.Config.Dmwit.PPrint GHC.Num.Integer.Integer
instance XMonad.Config.Dmwit.PPrint Graphics.X11.Xlib.Types.Position
instance XMonad.Config.Dmwit.PPrint Graphics.X11.Xlib.Types.Dimension
instance XMonad.Config.Dmwit.PPrint GHC.Types.Char
instance XMonad.Config.Dmwit.PPrint GHC.Word.Word64
instance XMonad.Config.Dmwit.PPrint XMonad.Core.ScreenId
instance (GHC.Show.Show a, GHC.Show.Show b) => XMonad.Config.Dmwit.PPrint (Data.Map.Internal.Map a b)


module XMonad.Actions.Profiles
type ProfileId = String

-- | Profile representation.
data Profile
Profile :: !ProfileId -> ![WorkspaceId] -> Profile

-- | Profile name.
[profileId] :: Profile -> !ProfileId

-- | A list of workspaces contained within a profile.
[profileWS] :: Profile -> ![WorkspaceId]

-- | User config for profiles.
data ProfileConfig
ProfileConfig :: ![WorkspaceId] -> ![Profile] -> !ProfileId -> ProfileConfig

-- | A list of workspaces to exclude from the <tt>profileHistoryHook</tt>.
[workspaceExcludes] :: ProfileConfig -> ![WorkspaceId]

-- | A list of user-defined profiles.
[profiles] :: ProfileConfig -> ![Profile]

-- | Profile shown on startup.
[startingProfile] :: ProfileConfig -> !ProfileId

-- | Hook profiles into XMonad. This function adds a startup hook that sets
--   up ProfileState. Also adds an afterRescreenHook for viewing correct
--   workspaces when adding new screens.
addProfiles :: ProfileConfig -> XConfig a -> XConfig a

-- | Hooks profiles into XMonad and enables Profile history logging.
addProfilesWithHistory :: ProfileConfig -> XConfig a -> XConfig a

-- | Switch to a profile.
switchToProfile :: ProfileId -> X ()

-- | For cycling through workspaces associated with the current.
wsFilter :: WSType

-- | Create keybindings per profile.
bindOn :: [(String, X ())] -> X ()

-- | Pretty printer for a bar. Prints workspace ids of current profile.
excludeWSPP :: PP -> X PP

-- | Loggs currentProfile and all profiles with hidden workspaces
--   (workspaces that aren't shown on a screen but have windows).
profileLogger :: (String -> String) -> (String -> String) -> Logger

-- | Prompt for switching profiles.
switchProfilePrompt :: XPConfig -> X ()

-- | Prompt for adding a workspace id to a profile.
addWSToProfilePrompt :: XPConfig -> X ()

-- | Prompt for removing a workspace from a profile.
removeWSFromProfilePrompt :: XPConfig -> X ()

-- | Prompt for switching workspaces.
switchProfileWSPrompt :: XPConfig -> X ()

-- | Prompt for shifting windows to a different workspace.
shiftProfileWSPrompt :: XPConfig -> X ()

-- | Returns current profile.
currentProfile :: X ProfileId

-- | Returns ids of all profiles.
profileIds :: X [ProfileId]

-- | Returns previous profile.
previousProfile :: X (Maybe ProfileId)

-- | Returns the history of viewed workspaces per profile.
profileHistory :: X (Map ProfileId [(ScreenId, WorkspaceId)])

-- | <tt>XWindowMap</tt> of all windows contained in a profile.
allProfileWindows :: XWindowMap

-- | Returns the workspace ids associated with a profile id.
profileWorkspaces :: ProfileId -> X [WorkspaceId]
instance Control.DeepSeq.NFData XMonad.Actions.Profiles.ProfileHistory
instance GHC.Show.Show XMonad.Actions.Profiles.ProfileHistory
instance GHC.Read.Read XMonad.Actions.Profiles.ProfileHistory
instance XMonad.Prompt.XPrompt XMonad.Actions.Profiles.ProfilePrompt
instance XMonad.Core.ExtensionClass XMonad.Actions.Profiles.ProfileHistory
instance Data.Default.Class.Default XMonad.Actions.Profiles.ProfileConfig
instance XMonad.Core.ExtensionClass XMonad.Actions.Profiles.ProfileState


-- | A set of prompts for XMonad
module XMonad.Actions.Launcher

-- | Create a list of modes based on : a list of extensions mapped to
--   actions the path to hoogle
defaultLauncherModes :: LauncherConfig -> [XPMode]
type ExtensionActions = Map String (String -> X ())
data LauncherConfig
LauncherConfig :: String -> String -> LauncherConfig
[browser] :: LauncherConfig -> String
[pathToHoogle] :: LauncherConfig -> String

-- | Creates a prompt with the given modes
launcherPrompt :: XPConfig -> [XPMode] -> X ()
instance XMonad.Prompt.XPrompt XMonad.Actions.Launcher.CalculatorMode
instance XMonad.Prompt.XPrompt XMonad.Actions.Launcher.HoogleMode


-- | Provides bindings to add and delete workspaces.
module XMonad.Actions.DynamicWorkspaces

-- | Add a new workspace with the given name, or do nothing if a workspace
--   with the given name already exists; then switch to the newly created
--   workspace.
addWorkspace :: String -> X ()

-- | Prompt for the name of a new workspace, add it if it does not already
--   exist, and switch to it.
addWorkspacePrompt :: XPConfig -> X ()

-- | Same as addWorkspace, but adds the workspace to the end of the list of
--   workspaces
appendWorkspace :: String -> X ()

-- | Prompt for the name of a new workspace, appending it to the end of the
--   list of workspaces if it does not already exist, and switch to it.
appendWorkspacePrompt :: XPConfig -> X ()

-- | Adds a new workspace with the given name to the current list of
--   workspaces. This function allows the user to pass a function that
--   inserts an element into a list at an arbitrary spot.
addWorkspaceAt :: (WindowSpace -> [WindowSpace] -> [WindowSpace]) -> String -> X ()

-- | Remove the current workspace.
removeWorkspace :: X ()

-- | Remove workspace with specific tag.
removeWorkspaceByTag :: String -> X ()

-- | Remove the current workspace if it contains no windows.
removeEmptyWorkspace :: X ()

-- | Remove workspace with specific tag if it contains no windows.
removeEmptyWorkspaceByTag :: String -> X ()

-- | Remove the current workspace after an operation if it is empty and
--   hidden. Can be used to remove a workspace if it is empty when leaving
--   it. The operation may only change workspace once, otherwise the
--   workspace will not be removed.
removeEmptyWorkspaceAfter :: X () -> X ()

-- | Like <a>removeEmptyWorkspaceAfter</a> but use a list of sticky
--   workspaces, whose entries will never be removed.
removeEmptyWorkspaceAfterExcept :: [String] -> X () -> X ()

-- | Add a new hidden workspace with the given name, or do nothing if a
--   workspace with the given name already exists.
addHiddenWorkspace :: String -> X ()

-- | Add a new hidden workspace with the given name, or do nothing if a
--   workspace with the given name already exists. Takes a function to
--   insert the workspace at an arbitrary spot in the list.
addHiddenWorkspaceAt :: (WindowSpace -> [WindowSpace] -> [WindowSpace]) -> String -> X ()
withWorkspace :: XPConfig -> (String -> X ()) -> X ()
selectWorkspace :: XPConfig -> X ()
renameWorkspace :: XPConfig -> X ()
renameWorkspaceByName :: String -> X ()
toNthWorkspace :: (String -> X ()) -> Int -> X ()
withNthWorkspace :: (String -> WindowSet -> WindowSet) -> Int -> X ()

-- | Set the index of the current workspace.
setWorkspaceIndex :: WorkspaceIndex -> X ()
withWorkspaceIndex :: (String -> WindowSet -> WindowSet) -> WorkspaceIndex -> X ()

-- | The workspace index is mapped to a workspace tag by the user and can
--   be updated.
type WorkspaceIndex = Int
instance GHC.Show.Show XMonad.Actions.DynamicWorkspaces.DynamicWorkspaceState
instance GHC.Read.Read XMonad.Actions.DynamicWorkspaces.DynamicWorkspaceState
instance XMonad.Core.ExtensionClass XMonad.Actions.DynamicWorkspaces.DynamicWorkspaceState


-- | Named scratchpads that support several arbitrary applications at the
--   same time.
module XMonad.Util.NamedScratchpad

-- | Single named scratchpad configuration
data NamedScratchpad
NS :: String -> String -> Query Bool -> ManageHook -> NamedScratchpad

-- | Scratchpad name
[name] :: NamedScratchpad -> String

-- | Command used to run application
[cmd] :: NamedScratchpad -> String

-- | Query to find already running application
[query] :: NamedScratchpad -> Query Bool

-- | Manage hook called for application window, use it to define the
--   placement. See <tt>nonFloating</tt>, <tt>defaultFloating</tt> and
--   <tt>customFloating</tt>
[hook] :: NamedScratchpad -> ManageHook

-- | Tag of the scratchpad workspace
scratchpadWorkspaceTag :: String

-- | Manage hook that makes the window non-floating
nonFloating :: ManageHook

-- | Manage hook that makes the window floating with the default placement
defaultFloating :: ManageHook

-- | Manage hook that makes the window floating with custom placement
customFloating :: RationalRect -> ManageHook

-- | Named scratchpads configuration
type NamedScratchpads = [NamedScratchpad]

-- | Action to pop up specified named scratchpad
--   
--   Note [Ignored Arguments]: Most of the time, this function ignores its
--   first argument and uses <a>NSPState</a> instead. The only time when it
--   does not is when no other window has been opened before in the running
--   xmonad instance. If this is not your use-case, you can safely call
--   this function with an empty list.
namedScratchpadAction :: NamedScratchpads -> String -> X ()

-- | Action to pop up specified named scratchpad, initially starting it on
--   the current workspace.
--   
--   This function <i>almost always</i> ignores its first argument; see
--   Note [Ignored Arguments] for <a>namedScratchpadAction</a>.
spawnHereNamedScratchpadAction :: NamedScratchpads -> String -> X ()

-- | Action to pop up specified named scratchpad, given a custom way to
--   initially start the application.
--   
--   This function <i>almost always</i> ignores its second argument; see
--   Note [Ignored Arguments] for <a>namedScratchpadAction</a>.
customRunNamedScratchpadAction :: (NamedScratchpad -> X ()) -> NamedScratchpads -> String -> X ()

-- | Like <a>namedScratchpadAction</a>, but execute the action for all
--   scratchpads that match the query.
--   
--   This function <i>almost always</i> ignores its first argument; see
--   Note [Ignored Arguments] for <a>namedScratchpadAction</a>.
allNamedScratchpadAction :: NamedScratchpads -> String -> X ()

-- | Manage hook to use with named scratchpads
namedScratchpadManageHook :: NamedScratchpads -> ManageHook

-- | A <tt>logHook</tt> to hide scratchpads when they lose focus. This can
--   be useful for e.g. dropdown terminals. Note that this also requires
--   you to use the <a>refocusLastLogHook</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   import XMonad.Hooks.RefocusLast (refocusLastLogHook)
--   import XMonad.Util.NamedScratchpad
--   
--   main = xmonad $ def
--     { logHook = refocusLastLogHook
--              &gt;&gt; nsHideOnFocusLoss myScratchpads
--                 -- enable hiding for all of @myScratchpads@
--     }
--   </pre>
nsHideOnFocusLoss :: NamedScratchpads -> X ()

-- | A <tt>logHook</tt> to have only one active scratchpad on a workspace.
--   This can be useful when working with multiple floating scratchpads
--   which would otherwise be stacked. Note that this also requires you to
--   use the <a>refocusLastLogHook</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   import XMonad.Hooks.RefocusLast (refocusLastLogHook)
--   import XMonad.Util.NamedScratchpad
--   
--   main = xmonad $ def
--     { logHook = refocusLastLogHook
--              &gt;&gt; nsHideOnNewScratchpad myScratchpads
--                 -- enable hiding for all of @myScratchpads@
--     }
--   </pre>
nsSingleScratchpadPerWorkspace :: NamedScratchpads -> X ()

-- | Toggle the visibility of a dynamic scratchpad.
dynamicNSPAction :: String -> X ()

-- | Either create a dynamic scratchpad out of the given window, or stop a
--   window from being one if it already is.
toggleDynamicNSP :: String -> Window -> X ()

-- | Make some scratchpads exclusive.
addExclusives :: [[String]] -> X ()

-- | If the focused window is a scratchpad, the scratchpad gets reset to
--   the original placement specified with the hook and becomes exclusive
--   again.
resetFocusedNSP :: X ()

-- | <tt>setNoexclusive w</tt> makes the window <tt>w</tt> lose its
--   exclusivity features.
setNoexclusive :: Window -> X ()

-- | Resize window and make it lose its exclusivity status in the process.
resizeNoexclusive :: Window -> X ()

-- | Float and drag the window; make it lose its exclusivity status in the
--   process.
floatMoveNoexclusive :: Window -> X ()

-- | Transforms a workspace list containing the NSP workspace into one that
--   doesn't contain it. Intended for use with logHooks.

-- | <i>Deprecated: Use XMonad.Util.WorkspaceCompare.filterOutWs
--   [scratchpadWorkspaceTag] instead</i>
namedScratchpadFilterOutWorkspace :: [WindowSpace] -> [WindowSpace]

-- | Transforms a pretty-printer into one not displaying the NSP workspace.
--   
--   A simple use could be:
--   
--   <pre>
--   logHook = dynamicLogWithPP . namedScratchpadFilterOutWorkspace $ def
--   </pre>
--   
--   Here is another example, when using
--   <a>XMonad.Layout.IndependentScreens</a>. If you have handles
--   <tt>hLeft</tt> and <tt>hRight</tt> for bars on the left and right
--   screens, respectively, and <tt>pp</tt> is a pretty-printer function
--   that takes a handle, you could write
--   
--   <pre>
--   logHook = let log screen handle = dynamicLogWithPP . namedScratchpadFilterOutWorkspacePP . marshallPP screen . pp $ handle
--             in log 0 hLeft &gt;&gt; log 1 hRight
--   </pre>

-- | <i>Deprecated: Use XMonad.Hooks.StatusBar.PP.filterOutWsPP
--   [scratchpadWorkspaceTag] instead</i>
namedScratchpadFilterOutWorkspacePP :: PP -> PP
instance XMonad.Core.ExtensionClass XMonad.Util.NamedScratchpad.NSPState


-- | Very handy hotkey-launched floating terminal window.

-- | <i>Deprecated: Use XMonad.Util.NamedScratchpad instead</i>
module XMonad.Util.Scratchpad

-- | Action to pop up the terminal, for the user to bind to a custom key.
scratchpadSpawnAction :: XConfig l -> X ()

-- | Action to pop up the terminal, with a directly specified terminal.
scratchpadSpawnActionTerminal :: String -> X ()

-- | Action to pop up any program with the user specifying how to set its
--   resource to "scratchpad". For example, with gnome-terminal:
--   
--   <pre>
--   scratchpadSpawnActionCustom "gnome-terminal --disable-factory --name scratchpad"
--   </pre>
scratchpadSpawnActionCustom :: String -> X ()

-- | The ManageHook, with the default rectangle: Half the screen wide, a
--   quarter of the screen tall, centered.
scratchpadManageHookDefault :: ManageHook

-- | The ManageHook, with a user-specified StackSet.RationalRect, e.g., for
--   a terminal 4/10 of the screen width from the left, half the screen
--   height from the top, and 6/10 of the screen width by 3/10 the screen
--   height, use:
--   
--   <pre>
--   scratchpadManageHook (W.RationalRect 0.4 0.5 0.6 0.3)
--   </pre>
scratchpadManageHook :: RationalRect -> ManageHook

-- | Transforms a workspace list containing the NSP workspace into one that
--   doesn't contain it. Intended for use with <a>logHook</a>s (see
--   <a>filterOutWsPP</a>) and <a>XMonad.Hooks.EwmhDesktops</a> (see
--   <a>addEwmhWorkspaceSort</a>).
scratchpadFilterOutWorkspace :: [WindowSpace] -> [WindowSpace]


-- | <a>XMonad.Util.Loggers</a> for <a>XMonad.Util.NamedScratchpad</a>
module XMonad.Util.Loggers.NamedScratchpad

-- | <a>startupHook</a> to initialize scratchpad activation tracking
--   
--   <pre>
--   , startupHook = ... &lt;&gt; nspTrackStartup scratchpads
--   </pre>
--   
--   If you kickstart the <a>logHook</a>, do it <i>after</i>
--   <a>nspTrackStartup</a>!
nspTrackStartup :: [NamedScratchpad] -> X ()

-- | <a>handleEventHook</a> to track scratchpad activation/deactivation
--   
--   <pre>
--   , handleEventHook = ... &lt;&gt; nspTrackHook scratchpads
--   </pre>
nspTrackHook :: [NamedScratchpad] -> Event -> X All

-- | <a>Logger</a> for scratchpads' state, using Unicode characters as
--   "icons".
--   
--   <pre>
--   , ppExtras = [..., nspActive' iconChars showActive showInactive, ...]
--   </pre>
nspActiveIcon :: [Char] -> (String -> String) -> (String -> String) -> Logger

-- | <a>Logger</a> with String-s (and no defaults)
--   
--   <pre>
--   , ppExtras = [..., nspActive iconStrs showActive showInactive, ...]
--   </pre>
nspActive :: [String] -> (String -> String) -> (String -> String) -> Logger

-- | Variant of the above getting the String-s from the
--   <a>NamedScratchpad</a>s
nspActive' :: [NamedScratchpad] -> (String -> String) -> (String -> String) -> Logger
instance XMonad.Core.ExtensionClass XMonad.Util.Loggers.NamedScratchpad.NSPTrack


-- | Dynamically manage "workspace groups", sets of workspaces being used
--   together for some common task or purpose, to allow switching between
--   workspace groups in a single action. Note that this only makes sense
--   for multi-head setups.
module XMonad.Actions.DynamicWorkspaceGroups
type WSGroupId = String

-- | Add a new workspace group of the given name, mapping to an explicitly
--   specified association between screen IDs and workspace names. This
--   function could be useful for, say, creating some standard workspace
--   groups in your startup hook.
addRawWSGroup :: WSGroupId -> [(ScreenId, WorkspaceId)] -> X ()

-- | Add a new workspace group with the given name.
addWSGroup :: WSGroupId -> [WorkspaceId] -> X ()

-- | Give a name to the current workspace group.
addCurrentWSGroup :: WSGroupId -> X ()

-- | Delete the named workspace group from the list of workspace groups.
--   Note that this has no effect on the workspaces involved; it simply
--   forgets the given name.
forgetWSGroup :: WSGroupId -> X ()

-- | View the workspace group with the given name.
viewWSGroup :: WSGroupId -> X ()

-- | Prompt for a workspace group to view.
promptWSGroupView :: XPConfig -> String -> X ()

-- | Prompt for a name for the current workspace group.
promptWSGroupAdd :: XPConfig -> String -> X ()

-- | Prompt for a workspace group to forget.
promptWSGroupForget :: XPConfig -> String -> X ()
data WSGPrompt

-- | View the workspace group with the given name, treating the workspaces
--   as topics.
viewTopicGroup :: TopicConfig -> WSGroupId -> X ()

-- | Prompt for a workspace group to view, treating the workspaces as
--   topics.
promptTopicGroupView :: TopicConfig -> XPConfig -> String -> X ()
instance GHC.Show.Show XMonad.Actions.DynamicWorkspaceGroups.WSGroupStorage
instance GHC.Read.Read XMonad.Actions.DynamicWorkspaceGroups.WSGroupStorage
instance XMonad.Prompt.XPrompt XMonad.Actions.DynamicWorkspaceGroups.WSGPrompt
instance XMonad.Core.ExtensionClass XMonad.Actions.DynamicWorkspaceGroups.WSGroupStorage


-- | Imbues workspaces with additional features so they can be treated as
--   individual project areas.
module XMonad.Actions.DynamicProjects

-- | Details about a workspace that represents a project.
data Project
Project :: !ProjectName -> !FilePath -> !Maybe (X ()) -> Project

-- | Workspace name.
[projectName] :: Project -> !ProjectName

-- | Working directory.
[projectDirectory] :: Project -> !FilePath

-- | Optional start-up hook.
[projectStartHook] :: Project -> !Maybe (X ())
type ProjectName = String

-- | Add dynamic projects support to the given config.
dynamicProjects :: [Project] -> XConfig a -> XConfig a

-- | Prompt for a project name and then switch to it. Automatically creates
--   a project if a new name is returned from the prompt.
switchProjectPrompt :: XPConfig -> X ()

-- | Prompts for a project name and then shifts the currently focused
--   window to that project.
shiftToProjectPrompt :: XPConfig -> X ()

-- | Rename the current project.
renameProjectPrompt :: XPConfig -> X ()

-- | Change the working directory used for the current project.
--   
--   NOTE: This will only affect new processed started in this project.
--   Existing processes will maintain the previous working directory.
changeProjectDirPrompt :: XPConfig -> X ()

-- | Switch to the given project.
switchProject :: Project -> X ()

-- | Shift the currently focused window to the given project.
shiftToProject :: Project -> X ()

-- | Find a project based on its name.
lookupProject :: ProjectName -> X (Maybe Project)

-- | Fetch the current project (the one being used for the currently active
--   workspace).
currentProject :: X Project

-- | Activate a project by updating the working directory and possibly
--   running its start-up hook. This function is automatically invoked when
--   the workspace changes.
activateProject :: Project -> X ()

-- | Modify the current project using a pure function.
modifyProject :: (Project -> Project) -> X ()
instance XMonad.Prompt.XPrompt XMonad.Actions.DynamicProjects.ProjectPrompt
instance XMonad.Core.ExtensionClass XMonad.Actions.DynamicProjects.ProjectState


-- | A module for easily running Internet searches on web sites through
--   xmonad. Modeled after the handy Surfraw CLI search tools at
--   <a>https://secure.wikimedia.org/wikipedia/en/wiki/Surfraw</a>.
--   
--   Additional sites welcomed.
module XMonad.Actions.Search

-- | Given a browser, a search engine's transformation function, and a
--   search term, perform the requested search in the browser.
search :: Browser -> Site -> Query -> X ()
data SearchEngine
SearchEngine :: Name -> Site -> SearchEngine

-- | Given a base URL, create the <a>SearchEngine</a> that escapes the
--   query and appends it to the base. You can easily define a new engine
--   locally using exported functions without needing to modify
--   <a>XMonad.Actions.Search</a>:
--   
--   <pre>
--   myNewEngine = searchEngine "site" "https://site.com/search="
--   </pre>
--   
--   The important thing is that the site has a interface which accepts the
--   escaped query string as part of the URL. Alas, the exact URL to feed
--   searchEngine varies from site to site, often considerably, so there's
--   no general way to cover this.
--   
--   Generally, examining the resultant URL of a search will allow you to
--   reverse-engineer it if you can't find the necessary URL already
--   described in other projects such as Surfraw.
searchEngine :: Name -> String -> SearchEngine

-- | If your search engine is more complex than this (you may want to
--   identify the kind of input and make the search URL dependent on the
--   input or put the query inside of a URL instead of in the end) you can
--   use the alternative <a>searchEngineF</a> function.
--   
--   <pre>
--   searchFunc :: String -&gt; String
--   searchFunc s | "wiki:"    `isPrefixOf` s = "https://en.wikipedia.org/wiki/" ++ (escape $ drop 1 $ snd $ break (==':') s)
--                | "https://" `isPrefixOf` s = s
--                | otherwise                 = (use google) s
--   myNewEngine = searchEngineF "mymulti" searchFunc
--   </pre>
--   
--   <tt>searchFunc</tt> here searches for a word in wikipedia if it has a
--   prefix of "wiki:" (you can use the <a>escape</a> function to escape
--   any forbidden characters), opens an address directly if it starts with
--   "https://" and otherwise uses the provided google search engine. You
--   can use other engines inside of your own through the <a>use</a>
--   function as shown above to make complex searches.
--   
--   The user input will be automatically escaped in search engines created
--   with <a>searchEngine</a>, <a>searchEngineF</a>, however, completely
--   depends on the transformation function passed to it.
searchEngineF :: Name -> Site -> SearchEngine

-- | Like <a>search</a>, but in this case, the string is not specified but
--   grabbed from the user's response to a prompt. Example:
--   
--   <pre>
--   , ((modm, xK_g), promptSearch greenXPConfig google)
--   </pre>
--   
--   This specializes "promptSearchBrowser" by supplying the browser
--   argument as supplied by <a>getBrowser</a> from
--   <a>XMonad.Prompt.Shell</a>.
promptSearch :: XPConfig -> SearchEngine -> X ()

-- | Like <a>search</a>, but for use with the output from a Prompt; it
--   grabs the Prompt's result, passes it to a given searchEngine and opens
--   it in a given browser.
promptSearchBrowser :: XPConfig -> Browser -> SearchEngine -> X ()

-- | Like <a>promptSearchBrowser</a>, but only suggest previous searches
--   for the given <a>SearchEngine</a> in the prompt.
promptSearchBrowser' :: XPConfig -> Browser -> SearchEngine -> X ()

-- | Like <a>search</a>, but for use with the X selection; it grabs the
--   selection, passes it to a given searchEngine and opens it in the
--   default browser . Example:
--   
--   <pre>
--   , ((modm .|. shiftMask, xK_g), selectSearch google)
--   </pre>
--   
--   This specializes "selectSearchBrowser" by supplying the browser
--   argument as supplied by <a>getBrowser</a> from
--   <a>XMonad.Prompt.Shell</a>.
selectSearch :: SearchEngine -> X ()

-- | Like <a>search</a>, but for use with the X selection; it grabs the
--   selection, passes it to a given searchEngine and opens it in a given
--   browser.
selectSearchBrowser :: Browser -> SearchEngine -> X ()

-- | &lt;math&gt;. The <a>isPrefixOf</a> function takes two lists and
--   returns <a>True</a> iff the first list is a prefix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | Escape the search string so search engines understand it. Only digits
--   and ASCII letters are not encoded. All non ASCII characters which are
--   encoded as UTF8
escape :: String -> String

-- | Given an already defined search engine, extracts its transformation
--   function, making it easy to create compound search engines. For an
--   instance you can use <tt>use google</tt> to get a function which makes
--   the same transformation as the google search engine would.
use :: SearchEngine -> Site

-- | This function wraps up a search engine and creates a new one, which
--   works like the argument, but goes directly to a URL if one is given
--   rather than searching.
--   
--   <pre>
--   myIntelligentGoogleEngine = intelligent google
--   </pre>
--   
--   Now if you search for https://xmonad.org it will directly open in your
--   browser
intelligent :: SearchEngine -> SearchEngine

-- | Connects a few search engines into one. If the search engines' names
--   are "s1", "s2" and "s3", then the resulting engine will use s1 if the
--   query is <tt>s1:word</tt>, s2 if you type <tt>s2:word</tt> and s3 in
--   all other cases.
--   
--   Example:
--   
--   <pre>
--   multiEngine = intelligent (wikipedia !&gt; mathworld !&gt; (prefixAware google))
--   </pre>
--   
--   Now if you type "wiki:Haskell" it will search for "Haskell" in
--   Wikipedia, "mathworld:integral" will search mathworld, and everything
--   else will fall back to google. The use of intelligent will make sure
--   that URLs are opened directly.
(!>) :: SearchEngine -> SearchEngine -> SearchEngine
infixr 6 !>

-- | Makes a search engine prefix-aware. Especially useful together with
--   <a>!&gt;</a>. It will automatically remove the prefix from a query so
--   that you don't end up searching for google:xmonad if google is your
--   fallback engine and you explicitly add the prefix.
prefixAware :: SearchEngine -> SearchEngine

-- | Changes search engine's name
namedEngine :: Name -> SearchEngine -> SearchEngine
alpha :: SearchEngine
amazon :: SearchEngine
arXiv :: SearchEngine
aur :: SearchEngine
clojureDocs :: SearchEngine
codesearch :: SearchEngine
cratesIo :: SearchEngine
deb :: SearchEngine
debbts :: SearchEngine
debpts :: SearchEngine
dictionary :: SearchEngine
duckduckgo :: SearchEngine
ebay :: SearchEngine
flora :: SearchEngine
github :: SearchEngine
google :: SearchEngine
hackage :: SearchEngine
homeManager :: SearchEngine
hoogle :: SearchEngine
images :: SearchEngine
imdb :: SearchEngine
lucky :: SearchEngine
maps :: SearchEngine
mathworld :: SearchEngine
ncatlab :: SearchEngine
nixos :: SearchEngine
noogle :: SearchEngine
openstreetmap :: SearchEngine
protondb :: SearchEngine
rosettacode :: SearchEngine
rustStd :: SearchEngine
scholar :: SearchEngine
sourcehut :: SearchEngine
stackage :: SearchEngine
steam :: SearchEngine
thesaurus :: SearchEngine
vocabulary :: SearchEngine
voidpgks_x86_64 :: SearchEngine
voidpgks_x86_64_musl :: SearchEngine
wayback :: SearchEngine
wikipedia :: SearchEngine
wiktionary :: SearchEngine
youtube :: SearchEngine
zbmath :: SearchEngine
multi :: SearchEngine
type Browser = FilePath
type Site = String -> String
type Query = String
type Name = String

-- | A customized prompt indicating we are searching, and the name of the
--   site.
data Search
instance XMonad.Prompt.XPrompt XMonad.Actions.Search.Search


-- | A module for painting on the screen
module XMonad.Util.XUtils

-- | Like <a>showSimpleWindow</a>, but fully manage the window; i.e.,
--   destroy it after the given function finishes its execution.
withSimpleWindow :: WindowConfig -> [String] -> X a -> X a

-- | Create a window, then fill and show it with the given text. If you are
--   looking for a version of this function that also takes care of
--   destroying the window, refer to <a>withSimpleWindow</a>.
showSimpleWindow :: WindowConfig -> [String] -> X Window

-- | The config for a window, as interpreted by <a>showSimpleWindow</a>.
--   
--   The font <tt>winFont</tt> can either be specified in the TODO format
--   or as an xft font. For example:
--   
--   <pre>
--   winFont = "xft:monospace-20"
--   </pre>
--   
--   or
--   
--   <pre>
--   winFont = "-misc-fixed-*-*-*-*-20-*-*-*-*-*-*-*"
--   </pre>
data WindowConfig
WindowConfig :: !String -> !String -> !String -> !WindowRect -> WindowConfig

-- | Font to use.
[winFont] :: WindowConfig -> !String

-- | Background color.
[winBg] :: WindowConfig -> !String

-- | Foreground color.
[winFg] :: WindowConfig -> !String

-- | Position and size of the rectangle.
[winRect] :: WindowConfig -> !WindowRect

-- | What kind of window we should be.
data WindowRect

-- | Centered, big enough to fit all the text.
CenterWindow :: WindowRect

-- | Completely custom dimensions.
CustomRect :: Rectangle -> WindowRect

-- | Compute the weighted average the colors of two given <a>Pixel</a>
--   values.
--   
--   This function masks out any alpha channel in the passed pixels, and
--   the result has no alpha channel. X11 mishandles <tt>Pixel</tt> values
--   with alpha channels and throws errors while producing black pixels.
averagePixels :: Pixel -> Pixel -> Double -> X Pixel

-- | Create a simple window given a rectangle. If Nothing is given only the
--   exposureMask will be set, otherwise the Just value. Use
--   <a>showWindow</a> to map and hideWindow to unmap.
createNewWindow :: Rectangle -> Maybe EventMask -> String -> Bool -> X Window

-- | Map a window
showWindow :: Window -> X ()

-- | the list version
showWindows :: [Window] -> X ()

-- | unmap a window
hideWindow :: Window -> X ()

-- | the list version
hideWindows :: [Window] -> X ()

-- | destroy a window
deleteWindow :: Window -> X ()

-- | the list version
deleteWindows :: [Window] -> X ()

-- | Fill a window with a rectangle and a border
paintWindow :: Window -> Dimension -> Dimension -> Dimension -> String -> String -> X ()

-- | Fill a window with a rectangle and a border, and write | a number of
--   strings to given positions
paintAndWrite :: Window -> XMonadFont -> Dimension -> Dimension -> Dimension -> String -> String -> String -> String -> [Align] -> [String] -> X ()

-- | Fill a window with a rectangle and a border, and write | a number of
--   strings and a number of icons to given positions
paintTextAndIcons :: Window -> XMonadFont -> Dimension -> Dimension -> Dimension -> String -> String -> String -> String -> [Align] -> [String] -> [Placement] -> [[[Bool]]] -> X ()

-- | Get the Pixel value for a named color: if an invalid name is given the
--   black pixel will be returned.
stringToPixel :: (Functor m, MonadIO m) => Display -> String -> m Pixel

-- | Convert a <tt>Pixel</tt> into a <tt>String</tt>.
--   
--   This function removes any alpha channel from the <tt>Pixel</tt>,
--   because X11 mishandles alpha channels and produces black.
pixelToString :: MonadIO m => Display -> Pixel -> m String

-- | Short for <a>fromIntegral</a>.
fi :: (Integral a, Num b) => a -> b
instance Data.Default.Class.Default XMonad.Util.XUtils.WindowConfig


-- | WindowNavigation is an extension to allow easy navigation of a
--   workspace.
module XMonad.Layout.WindowNavigation
windowNavigation :: LayoutClass l a => l a -> ModifiedLayout WindowNavigation l a
configurableNavigation :: LayoutClass l a => WNConfig -> l a -> ModifiedLayout WindowNavigation l a
data Navigate
Go :: Direction2D -> Navigate
Swap :: Direction2D -> Navigate
Move :: Direction2D -> Navigate

-- | Apply action with destination window
Apply :: (Window -> X ()) -> Direction2D -> Navigate

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D
data MoveWindowToWindow a
MoveWindowToWindow :: a -> a -> MoveWindowToWindow a

-- | Used with <a>configurableNavigation</a> to specify how to show
--   reachable windows' borders. You cannot create <a>WNConfig</a> values
--   directly; use <a>def</a> or one of the following three functions to
--   create one.
--   
--   <a>def</a>, and <a>windowNavigation</a>, uses the focused border color
--   at 40% brightness, as if you had specified
--   
--   <pre>
--   configurableNavigation (navigateBrightness 0.4)
--   </pre>
data WNConfig

-- | Indicate reachable windows by drawing their borders in the specified
--   color.
navigateColor :: String -> WNConfig

-- | Indicate reachable windows by drawing their borders in the active
--   border color, with the specified brightness.
navigateBrightness :: Double -> WNConfig

-- | Don't use window borders for navigation.
noNavigateBorders :: WNConfig

-- | The default value for this type.
def :: Default a => a
data WindowNavigation a
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.WindowNavigation.MoveWindowToWindow a)
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Layout.WindowNavigation.MoveWindowToWindow a)
instance GHC.Read.Read XMonad.Layout.WindowNavigation.WNConfig
instance GHC.Show.Show XMonad.Layout.WindowNavigation.WNConfig
instance GHC.Show.Show (XMonad.Layout.WindowNavigation.WindowNavigation a)
instance GHC.Read.Read (XMonad.Layout.WindowNavigation.WindowNavigation a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.WindowNavigation.WindowNavigation Graphics.X11.Types.Window
instance Data.Default.Class.Default XMonad.Layout.WindowNavigation.WNConfig
instance XMonad.Core.Message XMonad.Layout.WindowNavigation.Navigate
instance Data.Typeable.Internal.Typeable a => XMonad.Core.Message (XMonad.Layout.WindowNavigation.MoveWindowToWindow a)


-- | A layout that combines multiple layouts and allows to specify where to
--   put new windows.
module XMonad.Layout.ComboP
combineTwoP :: (LayoutClass super (), LayoutClass l1 Window, LayoutClass l2 Window) => super () -> l1 Window -> l2 Window -> Property -> CombineTwoP (super ()) l1 l2 Window
data CombineTwoP l l1 l2 a
data SwapWindow

-- | Swap window between panes
SwapWindow :: SwapWindow

-- | Swap window between panes in the N-th nested ComboP. <tt>SwapWindowN
--   0</tt> equals to SwapWindow
SwapWindowN :: Int -> SwapWindow
data PartitionWins

-- | Reset the layout and partition all windows into the correct
--   sub-layout. Useful for when window properties have changed and you
--   want ComboP to update which layout a window belongs to.
PartitionWins :: PartitionWins

-- | Most of the property constructors are quite self-explaining.
data Property
Title :: String -> Property
ClassName :: String -> Property
Resource :: String -> Property

-- | WM_WINDOW_ROLE property
Role :: String -> Property

-- | WM_CLIENT_MACHINE property
Machine :: String -> Property
And :: Property -> Property -> Property
Or :: Property -> Property -> Property
Not :: Property -> Property
Const :: Bool -> Property

-- | Tagged via <a>XMonad.Actions.TagWindows</a>
Tagged :: String -> Property
infixr 9 `And`
infixr 8 `Or`
instance GHC.Show.Show XMonad.Layout.ComboP.SwapWindow
instance GHC.Read.Read XMonad.Layout.ComboP.SwapWindow
instance GHC.Show.Show XMonad.Layout.ComboP.PartitionWins
instance GHC.Read.Read XMonad.Layout.ComboP.PartitionWins
instance (GHC.Show.Show a, GHC.Show.Show l, GHC.Show.Show (l1 a), GHC.Show.Show (l2 a)) => GHC.Show.Show (XMonad.Layout.ComboP.CombineTwoP l l1 l2 a)
instance (GHC.Read.Read a, GHC.Read.Read l, GHC.Read.Read (l1 a), GHC.Read.Read (l2 a)) => GHC.Read.Read (XMonad.Layout.ComboP.CombineTwoP l l1 l2 a)
instance (XMonad.Core.LayoutClass l (), XMonad.Core.LayoutClass l1 Graphics.X11.Types.Window, XMonad.Core.LayoutClass l2 Graphics.X11.Types.Window) => XMonad.Core.LayoutClass (XMonad.Layout.ComboP.CombineTwoP (l ()) l1 l2) Graphics.X11.Types.Window
instance XMonad.Core.Message XMonad.Layout.ComboP.PartitionWins
instance XMonad.Core.Message XMonad.Layout.ComboP.SwapWindow


-- | A layout that combines multiple layouts.
module XMonad.Layout.Combo
combineTwo :: (Read a, Eq a, LayoutClass super (), LayoutClass l1 a, LayoutClass l2 a) => super () -> l1 a -> l2 a -> CombineTwo (super ()) l1 l2 a
data CombineTwo l l1 l2 a
instance (GHC.Show.Show a, GHC.Show.Show l, GHC.Show.Show (l1 a), GHC.Show.Show (l2 a)) => GHC.Show.Show (XMonad.Layout.Combo.CombineTwo l l1 l2 a)
instance (GHC.Read.Read a, GHC.Read.Read l, GHC.Read.Read (l1 a), GHC.Read.Read (l2 a)) => GHC.Read.Read (XMonad.Layout.Combo.CombineTwo l l1 l2 a)
instance (XMonad.Core.LayoutClass l (), XMonad.Core.LayoutClass l1 a, XMonad.Core.LayoutClass l2 a, GHC.Read.Read a, GHC.Show.Show a, GHC.Classes.Eq a, Data.Typeable.Internal.Typeable a) => XMonad.Core.LayoutClass (XMonad.Layout.Combo.CombineTwo (l ()) l1 l2) a


-- | This is a layout modifier that will show the workspace name
module XMonad.Layout.ShowWName

-- | A layout modifier to show the workspace name when switching
showWName :: l a -> ModifiedLayout ShowWName l a

-- | A layout modifier to show the workspace name when switching. It is
--   possible to provide a custom configuration.
showWName' :: SWNConfig -> l a -> ModifiedLayout ShowWName l a

-- | The default value for this type.
def :: Default a => a
data SWNConfig
SWNC :: String -> String -> String -> Rational -> SWNConfig

-- | Font name
[swn_font] :: SWNConfig -> String

-- | Background color
[swn_bgcolor] :: SWNConfig -> String

-- | String color
[swn_color] :: SWNConfig -> String

-- | Time in seconds of the name visibility
[swn_fade] :: SWNConfig -> Rational
data ShowWName a
instance GHC.Show.Show XMonad.Layout.ShowWName.SWNConfig
instance GHC.Read.Read XMonad.Layout.ShowWName.SWNConfig
instance GHC.Show.Show (XMonad.Layout.ShowWName.ShowWName a)
instance GHC.Read.Read (XMonad.Layout.ShowWName.ShowWName a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.ShowWName.ShowWName a
instance Data.Default.Class.Default XMonad.Layout.ShowWName.SWNConfig


-- | A layout in the spirit of <a>XMonad.Layout.ResizableTile</a>, but with
--   the option to use the mouse to adjust the layout.
module XMonad.Layout.MouseResizableTile
mouseResizableTile :: MouseResizableTile a

-- | May be removed in favor of <tt>mouseResizableTile { isMirrored = True
--   }</tt>
mouseResizableTileMirrored :: MouseResizableTile a
data MRTMessage
SetMasterFraction :: Rational -> MRTMessage
SetLeftSlaveFraction :: Int -> Rational -> MRTMessage
SetRightSlaveFraction :: Int -> Rational -> MRTMessage
ShrinkSlave :: MRTMessage
ExpandSlave :: MRTMessage

-- | Get/set the number of windows in master pane (default: 1).
nmaster :: MouseResizableTile a -> Int

-- | Get/set the proportion of screen occupied by master pane (default:
--   1/2).
masterFrac :: MouseResizableTile a -> Rational

-- | Get/set the proportion of remaining space in a column occupied by a
--   slave window (default: 1/2).
slaveFrac :: MouseResizableTile a -> Rational

-- | Get/set the increment used when modifying masterFrac/slaveFrac by the
--   Shrink, Expand, etc. messages (default: 3/100).
fracIncrement :: MouseResizableTile a -> Rational

-- | Get/set whether the layout is mirrored (default: False).
isMirrored :: MouseResizableTile a -> Bool

-- | Get/set dragger and gap dimensions (default: FixedDragger 6 6).
draggerType :: MouseResizableTile a -> DraggerType

-- | Specifies the size of the clickable area between windows.
data DraggerType
FixedDragger :: Dimension -> Dimension -> DraggerType

-- | width of a gap between windows
[gapWidth] :: DraggerType -> Dimension

-- | width of the dragger itself (will overlap windows if greater than gap)
[draggerWidth] :: DraggerType -> Dimension

-- | no gaps, draggers overlap window borders
BordersDragger :: DraggerType
data MouseResizableTile a
instance GHC.Read.Read XMonad.Layout.MouseResizableTile.DraggerInfo
instance GHC.Show.Show XMonad.Layout.MouseResizableTile.DraggerInfo
instance GHC.Read.Read XMonad.Layout.MouseResizableTile.DraggerType
instance GHC.Show.Show XMonad.Layout.MouseResizableTile.DraggerType
instance GHC.Read.Read (XMonad.Layout.MouseResizableTile.MouseResizableTile a)
instance GHC.Show.Show (XMonad.Layout.MouseResizableTile.MouseResizableTile a)
instance XMonad.Core.LayoutClass XMonad.Layout.MouseResizableTile.MouseResizableTile Graphics.X11.Types.Window
instance XMonad.Core.Message XMonad.Layout.MouseResizableTile.MRTMessage


-- | Layouts that splits the screen either horizontally or vertically and
--   shows two windows. The first window is always the master window, and
--   the other is either the currently focused window or the second window
--   in layout order.
module XMonad.Layout.DragPane
dragPane :: DragType -> Double -> Double -> DragPane a
data DragPane a
data DragType
Horizontal :: DragType
Vertical :: DragType
instance GHC.Read.Read XMonad.Layout.DragPane.DragType
instance GHC.Show.Show XMonad.Layout.DragPane.DragType
instance GHC.Read.Read (XMonad.Layout.DragPane.DragPane a)
instance GHC.Show.Show (XMonad.Layout.DragPane.DragPane a)
instance GHC.Classes.Eq XMonad.Layout.DragPane.SetFrac
instance GHC.Read.Read XMonad.Layout.DragPane.SetFrac
instance GHC.Show.Show XMonad.Layout.DragPane.SetFrac
instance XMonad.Core.Message XMonad.Layout.DragPane.SetFrac
instance XMonad.Core.LayoutClass XMonad.Layout.DragPane.DragPane a


-- | The <a>XMonad.Layout.LayoutCombinators</a> module provides combinators
--   for easily combining multiple layouts into one composite layout.
module XMonad.Layout.LayoutCombinators
(*||*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 *||*
(**||*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 **||*
(***||*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 ***||*
(****||*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 ****||*
(***||**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 ***||**
(****||***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 ****||***
(***||****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 ***||****
(*||****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 *||****
(**||***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 **||***
(*||***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 *||***
(*||**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 *||**
(*//*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 *//*
(**//*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 **//*
(***//*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 ***//*
(****//*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 ****//*
(***//**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 ***//**
(****//***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 ****//***
(***//****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 ***//****
(*//****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 *//****
(**//***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 **//***
(*//***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 *//***
(*//**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (DragPane ()) l1 l2 a
infixr 6 *//**
(*|*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
infixr 6 *|*
(**|*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
infixr 6 **|*
(***|*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
infixr 6 ***|*
(****|*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
infixr 6 ****|*
(***|**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
infixr 6 ***|**
(****|***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
infixr 6 ****|***
(***|****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
infixr 6 ***|****
(*|****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
infixr 6 *|****
(**|***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
infixr 6 **|***
(*|***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
infixr 6 *|***
(*|**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Tall ()) l1 l2 a
infixr 6 *|**
(*/*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
infixr 6 */*
(**/*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
infixr 6 **/*
(***/*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
infixr 6 ***/*
(****/*) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
infixr 6 ****/*
(***/**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
infixr 6 ***/**
(****/***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
infixr 6 ****/***
(***/****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
infixr 6 ***/****
(*/****) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
infixr 6 */****
(**/***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
infixr 6 **/***
(*/***) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
infixr 6 */***
(*/**) :: (Read a, Eq a, LayoutClass l1 a, LayoutClass l2 a) => l1 a -> l2 a -> CombineTwo (Mirror Tall ()) l1 l2 a
infixr 6 */**

-- | The layout choice combinator
(|||) :: l a -> r a -> Choose l r a
infixr 5 |||

-- | A message to jump to a particular layout, specified by its description
--   string.
--   
--   The argument given to a <a>JumpToLayout</a> message should be the
--   <tt>description</tt> of the layout to be selected. If you use
--   <a>XMonad.Hooks.DynamicLog</a> from <tt>xmonad-contrib</tt>, this is
--   the name of the layout displayed in your status bar. Alternatively,
--   you can use GHCi to determine the proper name to use. For example:
--   
--   <pre>
--   $ ghci
--   GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
--   Loading package base ... linking ... done.
--   :set prompt "&gt; "    -- don't show loaded module names
--   &gt; :m +XMonad.Core   -- load the xmonad core
--   &gt; :m +XMonad.Layout.Grid  -- load whatever module you want to use
--   &gt; description Grid  -- find out what it's called
--   "Grid"
--   </pre>
--   
--   As yet another (possibly easier) alternative, you can use the
--   <a>XMonad.Layout.Renamed</a> module (also in <tt>xmonad-contrib</tt>)
--   to give custom names to your layouts, and use those.
--   
--   For example, if you want to jump directly to the <a>Full</a> layout
--   you can do
--   
--   <pre>
--   , ((modm .|. controlMask, xK_f), sendMessage $ JumpToLayout "Full")
--   </pre>
newtype JumpToLayout
JumpToLayout :: String -> JumpToLayout

-- | <i>Deprecated: Use <a>Choose</a> instead.</i>
type NewSelect = Choose


-- | A layout modifier and a class for easily creating decorated layouts.
module XMonad.Layout.Decoration

-- | A layout modifier that, with a <a>Shrinker</a>, a <a>Theme</a>, a
--   <a>DecorationStyle</a>, and a layout, will decorate this layout
--   according to the decoration style provided.
--   
--   For some usage examples see <a>XMonad.Layout.DecorationMadness</a>.
decoration :: (DecorationStyle ds a, Shrinker s) => s -> Theme -> ds a -> l a -> ModifiedLayout (Decoration ds s) l a

-- | A <a>Theme</a> is a record of colors, font etc., to customize a
--   <a>DecorationStyle</a>.
--   
--   For a collection of <a>Theme</a>s see <a>XMonad.Util.Themes</a>
data Theme
Theme :: String -> String -> String -> String -> String -> String -> Dimension -> Dimension -> Dimension -> String -> String -> String -> String -> Dimension -> Dimension -> [(String, Align)] -> [([[Bool]], Placement)] -> Theme

-- | Color of the active window
[activeColor] :: Theme -> String

-- | Color of the inactive window
[inactiveColor] :: Theme -> String

-- | Color of the urgent window
[urgentColor] :: Theme -> String

-- | Color of the border of the active window
[activeBorderColor] :: Theme -> String

-- | Color of the border of the inactive window
[inactiveBorderColor] :: Theme -> String

-- | Color of the border of the urgent window
[urgentBorderColor] :: Theme -> String

-- | Width of the border of the active window
[activeBorderWidth] :: Theme -> Dimension

-- | Width of the border of the inactive window
[inactiveBorderWidth] :: Theme -> Dimension

-- | Width of the border of the urgent window
[urgentBorderWidth] :: Theme -> Dimension

-- | Color of the text of the active window
[activeTextColor] :: Theme -> String

-- | Color of the text of the inactive window
[inactiveTextColor] :: Theme -> String

-- | Color of the text of the urgent window
[urgentTextColor] :: Theme -> String

-- | Font name
[fontName] :: Theme -> String

-- | Maximum width of the decorations (if supported by the
--   <a>DecorationStyle</a>)
[decoWidth] :: Theme -> Dimension

-- | Height of the decorations
[decoHeight] :: Theme -> Dimension

-- | Extra text to appear in a window's title bar. Refer to for a use
--   <a>XMonad.Layout.ImageButtonDecoration</a>
[windowTitleAddons] :: Theme -> [(String, Align)]

-- | Extra icons to appear in a window's title bar. Inner <tt>[Bool]</tt>
--   is a row in a icon bitmap.
[windowTitleIcons] :: Theme -> [([[Bool]], Placement)]

-- | The default value for this type.
def :: Default a => a

-- | The <a>Decoration</a> <a>LayoutModifier</a>. This data type is an
--   instance of the <a>LayoutModifier</a> class. This data type will be
--   passed, together with a layout, to the <a>ModifiedLayout</a> type
--   constructor to modify the layout by adding decorations according to a
--   <a>DecorationStyle</a>.
data Decoration ds s a

-- | A <a>Decoration</a> layout modifier will handle <a>SetTheme</a>, a
--   message to dynamically change the decoration <a>Theme</a>.
newtype DecorationMsg
SetTheme :: Theme -> DecorationMsg

-- | The <a>DecorationStyle</a> class, defines methods used in the
--   implementation of the <a>Decoration</a> <a>LayoutModifier</a>
--   instance. A type instance of this class is passed to the
--   <a>Decoration</a> type in order to decorate a layout, by using these
--   methods.
class (Read (ds a), Show (ds a), Eq a) => DecorationStyle ds a

-- | The description that the <a>Decoration</a> modifier will display.
describeDeco :: DecorationStyle ds a => ds a -> String

-- | Shrink the window's rectangle when applying a decoration.
shrink :: DecorationStyle ds a => ds a -> Rectangle -> Rectangle -> Rectangle

-- | The decoration event hook
decorationEventHook :: DecorationStyle ds a => ds a -> DecorationState -> Event -> X ()

-- | A hook that can be used to catch the cases when the user clicks on the
--   decoration. If you return True here, the click event will be
--   considered as dealt with and no further processing will take place.
decorationCatchClicksHook :: DecorationStyle ds a => ds a -> Window -> Int -> Int -> X Bool

-- | This hook is called while a window is dragged using the decoration.
--   The hook can be overwritten if a different way of handling the
--   dragging is required.
decorationWhileDraggingHook :: DecorationStyle ds a => ds a -> CInt -> CInt -> (Window, Rectangle) -> Position -> Position -> X ()

-- | This hoook is called after a window has been dragged using the
--   decoration.
decorationAfterDraggingHook :: DecorationStyle ds a => ds a -> (Window, Rectangle) -> Window -> X ()

-- | The pure version of the main method, <a>decorate</a>.
pureDecoration :: DecorationStyle ds a => ds a -> Dimension -> Dimension -> Rectangle -> Stack a -> [(a, Rectangle)] -> (a, Rectangle) -> Maybe Rectangle

-- | Given the theme's decoration width and height, the screen rectangle,
--   the windows stack, the list of windows and rectangles returned by the
--   underlying layout and window to be decorated, tupled with its
--   rectangle, produce a <a>Just</a> <a>Rectangle</a> or <a>Nothing</a> if
--   the window is not to be decorated.
decorate :: DecorationStyle ds a => ds a -> Dimension -> Dimension -> Rectangle -> Stack a -> [(a, Rectangle)] -> (a, Rectangle) -> X (Maybe Rectangle)

-- | The default <a>DecorationStyle</a>, with just the default methods'
--   implementations.
data DefaultDecoration a
DefaultDecoration :: DefaultDecoration a
class (Read s, Show s) => Shrinker s
shrinkIt :: Shrinker s => s -> String -> [String]
data DefaultShrinker
shrinkText :: DefaultShrinker
data CustomShrink
CustomShrink :: CustomShrink
shrinkWhile :: (String -> [String]) -> (String -> X Bool) -> String -> X String

-- | True if the window is in the <tt>Stack</tt>. The <a>Window</a> comes
--   second to facilitate list processing, even though <tt>w `isInStack`
--   s</tt> won't work...;)
isInStack :: Eq a => Stack a -> a -> Bool

-- | Given a <a>Rectangle</a> and a list of <a>Rectangle</a>s is True if
--   the <a>Rectangle</a> is not completely contained by any
--   <a>Rectangle</a> of the list.
isVisible :: Rectangle -> [Rectangle] -> Bool

-- | The contrary of <a>isVisible</a>.
isInvisible :: Rectangle -> [Rectangle] -> Bool

-- | True is the first <a>Rectangle</a> is totally within the second
--   <a>Rectangle</a>.
isWithin :: Rectangle -> Rectangle -> Bool

-- | Short for <a>fromIntegral</a>.
fi :: (Integral a, Num b) => a -> b
findWindowByDecoration :: Window -> DecorationState -> Maybe (OrigWin, (Window, Maybe Rectangle))

-- | The <a>Decoration</a> state component, where the list of decorated
--   window's is zipped with a list of decoration. A list of decoration is
--   a list of tuples, a <a>Maybe</a> <a>Window</a> and a 'Maybe
--   Rectangle'. The <a>Window</a> will be displayed only if the rectangle
--   is of type <a>Just</a>.
data DecorationState
type OrigWin = (Window, Rectangle)
instance GHC.Read.Read XMonad.Layout.Decoration.Theme
instance GHC.Show.Show XMonad.Layout.Decoration.Theme
instance (GHC.Read.Read s, GHC.Read.Read (ds a)) => GHC.Read.Read (XMonad.Layout.Decoration.Decoration ds s a)
instance (GHC.Show.Show s, GHC.Show.Show (ds a)) => GHC.Show.Show (XMonad.Layout.Decoration.Decoration ds s a)
instance GHC.Show.Show (XMonad.Layout.Decoration.DefaultDecoration a)
instance GHC.Read.Read (XMonad.Layout.Decoration.DefaultDecoration a)
instance GHC.Show.Show XMonad.Layout.Decoration.DefaultShrinker
instance GHC.Read.Read XMonad.Layout.Decoration.DefaultShrinker
instance XMonad.Layout.Decoration.Shrinker XMonad.Layout.Decoration.DefaultShrinker
instance (XMonad.Layout.Decoration.DecorationStyle ds Graphics.X11.Types.Window, XMonad.Layout.Decoration.Shrinker s) => XMonad.Layout.LayoutModifier.LayoutModifier (XMonad.Layout.Decoration.Decoration ds s) Graphics.X11.Types.Window
instance GHC.Show.Show XMonad.Layout.Decoration.CustomShrink
instance GHC.Read.Read XMonad.Layout.Decoration.CustomShrink
instance GHC.Classes.Eq a => XMonad.Layout.Decoration.DecorationStyle XMonad.Layout.Decoration.DefaultDecoration a
instance XMonad.Core.Message XMonad.Layout.Decoration.DecorationMsg
instance Data.Default.Class.Default XMonad.Layout.Decoration.Theme


-- | A (hopefully) growing collection of themes for decorated layouts.
module XMonad.Util.Themes
listOfThemes :: [ThemeInfo]
ppThemeInfo :: ThemeInfo -> String

-- | The default xmonad theme, by David Roundy.
xmonadTheme :: ThemeInfo

-- | Small decorations with a Ion3 remembrance, by Andrea Rossato.
smallClean :: ThemeInfo

-- | Matching decorations for Adwaita GTK theme
adwaitaTheme :: ThemeInfo

-- | Matching decorations for Adwaita-dark GTK theme
adwaitaDarkTheme :: ThemeInfo

-- | Ffrom Robert Manea's prompt theme.
robertTheme :: ThemeInfo

-- | Dark Theme, by Lucian Poston.
darkTheme :: ThemeInfo

-- | deifl's Theme, by deifl.
deiflTheme :: ThemeInfo

-- | oxymor00n's theme, by Tom Rauchenwald.
oxymor00nTheme :: ThemeInfo

-- | Don's preferred colors - from DynamicLog...;)
donaldTheme :: ThemeInfo
wfarrTheme :: ThemeInfo

-- | Forest colours, by Kathryn Andersen
kavonForestTheme :: ThemeInfo

-- | Lake (blue/green) colours, by Kathryn Andersen
kavonLakeTheme :: ThemeInfo

-- | Peacock colours, by Kathryn Andersen
kavonPeacockTheme :: ThemeInfo

-- | Violet-Green colours, by Kathryn Andersen
kavonVioGreenTheme :: ThemeInfo

-- | Blue colours, by Kathryn Andersen
kavonBluesTheme :: ThemeInfo

-- | Autumn colours, by Kathryn Andersen
kavonAutumnTheme :: ThemeInfo

-- | Fire colours, by Kathryn Andersen
kavonFireTheme :: ThemeInfo

-- | Christmas colours, by Kathryn Andersen
kavonChristmasTheme :: ThemeInfo
data ThemeInfo
TI :: String -> String -> String -> Theme -> ThemeInfo
[themeName] :: ThemeInfo -> String
[themeAuthor] :: ThemeInfo -> String
[themeDescription] :: ThemeInfo -> String
[theme] :: ThemeInfo -> Theme


-- | A prompt for changing the theme of the current workspace
module XMonad.Prompt.Theme
themePrompt :: XPConfig -> X ()
data ThemePrompt
instance XMonad.Prompt.XPrompt XMonad.Prompt.Theme.ThemePrompt


-- | A layout combinator that support Shrink, Expand, and IncMasterN just
--   as the <a>Tall</a> layout, and also support operations of two master
--   windows: a main master, which is the original master window; a sub
--   master, the first window of the second pane. This combinator can be
--   nested, and has a good support for using <a>XMonad.Layout.Tabbed</a>
--   as a sublayout.
module XMonad.Layout.TallMastersCombo

-- | Combine two layouts l1 l2 with default behaviors.
tmsCombineTwoDefault :: (LayoutClass l1 Window, LayoutClass l2 Window) => l1 Window -> l2 Window -> TMSCombineTwo l1 l2 Window

-- | A more flexible way of merging two layouts. User can specify if merge
--   them vertical or horizontal, the number of windows in the first pane
--   (master pane), the shink and expand increment, and the proportion
--   occupied by the master pane.
tmsCombineTwo :: (LayoutClass l1 Window, LayoutClass l2 Window) => Bool -> Int -> Rational -> Rational -> l1 Window -> l2 Window -> TMSCombineTwo l1 l2 Window
data TMSCombineTwo l1 l2 a
TMSCombineTwo :: [a] -> [a] -> [a] -> Bool -> !Int -> !Rational -> !Rational -> l1 a -> l2 a -> TMSCombineTwo l1 l2 a
[focusLst] :: TMSCombineTwo l1 l2 a -> [a]
[ws1] :: TMSCombineTwo l1 l2 a -> [a]
[ws2] :: TMSCombineTwo l1 l2 a -> [a]

-- | merge two layouts in a column or a row
[rowMod] :: TMSCombineTwo l1 l2 a -> Bool

-- | number of windows in the master pane
[nMaster] :: TMSCombineTwo l1 l2 a -> !Int

-- | percent of screen to increment by when resizing panes
[rationInc] :: TMSCombineTwo l1 l2 a -> !Rational

-- | default proportion of screen occupied by master pane
[tallComboRatio] :: TMSCombineTwo l1 l2 a -> !Rational

-- | layout for the master pane
[layoutFst] :: TMSCombineTwo l1 l2 a -> l1 a

-- | layout for the second pane
[layoutSnd] :: TMSCombineTwo l1 l2 a -> l2 a

-- | A simple layout that arranges windows in a row or a column with equal
--   sizes. It can switch between row mode and column mode by listening to
--   the message <a>SwitchOrientation</a>.
newtype RowsOrColumns a
RowsOrColumns :: Bool -> RowsOrColumns a

-- | arrange windows in rows or columns
[rowMode] :: RowsOrColumns a -> Bool

-- | This is same as the Choose combination operator.
(|||) :: l a -> r a -> ChooseWrapper l r a

-- | A message that switches the orientation of TallMasterCombo layout and
--   the RowsOrColumns layout. This is similar to the <a>Mirror</a>
--   message, but <a>Mirror</a> cannot apply to hidden layouts, and when
--   <a>Mirror</a> applies to the <a>Tabbed</a> decoration, it will also
--   mirror the tabs, which may lead to unintended visualizations. The
--   <a>SwitchOrientation</a> message refreshes layouts according to the
--   orientation of the parent layout, and will not affect the
--   <a>Tabbed</a> decoration.
data SwitchOrientation
SwitchOrientation :: SwitchOrientation

-- | This message swaps the current focused window with the sub master
--   window (first window in the second pane).
data SwapSubMaster
SwapSubMaster :: SwapSubMaster

-- | This message changes the focus to the sub master window (first window
--   in the second pane).
data FocusSubMaster
FocusSubMaster :: FocusSubMaster

-- | This message triggers the <a>NextLayout</a> message in the pane that
--   contains the focused window.
data FocusedNextLayout
FocusedNextLayout :: FocusedNextLayout

-- | This is a message for changing to the previous or next focused window
--   across all the sub-layouts.
data ChangeFocus
NextFocus :: ChangeFocus
PrevFocus :: ChangeFocus
data ChooseWrapper l r a
ChooseWrapper :: LR -> l a -> r a -> Choose l r a -> ChooseWrapper l r a

-- | Swap a given window with the focused window.
swapWindow :: Eq a => a -> Stack a -> Stack a

-- | Focus a given window.
focusWindow :: Eq a => a -> Stack a -> Stack a

-- | Handle a list of messages one by one, then return the last refreshed
--   layout.
handleMessages :: LayoutClass l a => l a -> [SomeMessage] -> X (Maybe (l a))
instance GHC.Read.Read (XMonad.Layout.TallMastersCombo.RowsOrColumns a)
instance GHC.Show.Show (XMonad.Layout.TallMastersCombo.RowsOrColumns a)
instance (GHC.Read.Read a, GHC.Read.Read (l1 a), GHC.Read.Read (l2 a)) => GHC.Read.Read (XMonad.Layout.TallMastersCombo.TMSCombineTwo l1 l2 a)
instance (GHC.Show.Show a, GHC.Show.Show (l1 a), GHC.Show.Show (l2 a)) => GHC.Show.Show (XMonad.Layout.TallMastersCombo.TMSCombineTwo l1 l2 a)
instance GHC.Show.Show XMonad.Layout.TallMastersCombo.Orientation
instance GHC.Read.Read XMonad.Layout.TallMastersCombo.Orientation
instance GHC.Show.Show XMonad.Layout.TallMastersCombo.SwitchOrientation
instance GHC.Read.Read XMonad.Layout.TallMastersCombo.SwitchOrientation
instance GHC.Show.Show XMonad.Layout.TallMastersCombo.SwapSubMaster
instance GHC.Read.Read XMonad.Layout.TallMastersCombo.SwapSubMaster
instance GHC.Show.Show XMonad.Layout.TallMastersCombo.FocusSubMaster
instance GHC.Read.Read XMonad.Layout.TallMastersCombo.FocusSubMaster
instance GHC.Show.Show XMonad.Layout.TallMastersCombo.FocusedNextLayout
instance GHC.Read.Read XMonad.Layout.TallMastersCombo.FocusedNextLayout
instance GHC.Show.Show XMonad.Layout.TallMastersCombo.ChangeFocus
instance GHC.Read.Read XMonad.Layout.TallMastersCombo.ChangeFocus
instance GHC.Classes.Eq XMonad.Layout.TallMastersCombo.LR
instance GHC.Read.Read XMonad.Layout.TallMastersCombo.LR
instance GHC.Show.Show XMonad.Layout.TallMastersCombo.LR
instance (GHC.Read.Read (l a), GHC.Read.Read (r a)) => GHC.Read.Read (XMonad.Layout.TallMastersCombo.ChooseWrapper l r a)
instance (GHC.Show.Show (l a), GHC.Show.Show (r a)) => GHC.Show.Show (XMonad.Layout.TallMastersCombo.ChooseWrapper l r a)
instance GHC.Show.Show XMonad.Layout.TallMastersCombo.NextNoWrap
instance GHC.Classes.Eq XMonad.Layout.TallMastersCombo.NextNoWrap
instance (XMonad.Layout.TallMastersCombo.GetFocused l1 Graphics.X11.Types.Window, XMonad.Layout.TallMastersCombo.GetFocused l2 Graphics.X11.Types.Window) => XMonad.Core.LayoutClass (XMonad.Layout.TallMastersCombo.TMSCombineTwo l1 l2) Graphics.X11.Types.Window
instance (XMonad.Layout.TallMastersCombo.GetFocused l a, XMonad.Layout.TallMastersCombo.GetFocused r a) => XMonad.Core.LayoutClass (XMonad.Layout.TallMastersCombo.ChooseWrapper l r) a
instance (XMonad.Layout.TallMastersCombo.GetFocused l Graphics.X11.Types.Window, XMonad.Layout.TallMastersCombo.GetFocused r Graphics.X11.Types.Window) => XMonad.Layout.TallMastersCombo.GetFocused (XMonad.Layout.TallMastersCombo.TMSCombineTwo l r) Graphics.X11.Types.Window
instance (XMonad.Layout.TallMastersCombo.GetFocused l a, XMonad.Layout.TallMastersCombo.GetFocused r a) => XMonad.Layout.TallMastersCombo.GetFocused (XMonad.Layout.TallMastersCombo.ChooseWrapper l r) a
instance Data.Typeable.Internal.Typeable a => XMonad.Layout.TallMastersCombo.GetFocused XMonad.Layout.Simplest.Simplest a
instance Data.Typeable.Internal.Typeable a => XMonad.Layout.TallMastersCombo.GetFocused XMonad.Layout.TallMastersCombo.RowsOrColumns a
instance Data.Typeable.Internal.Typeable a => XMonad.Layout.TallMastersCombo.GetFocused XMonad.Layout.Full a
instance Data.Typeable.Internal.Typeable a => XMonad.Layout.TallMastersCombo.GetFocused XMonad.Layout.Tall a
instance (Data.Typeable.Internal.Typeable l, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable m, XMonad.Layout.LayoutModifier.LayoutModifier m a, XMonad.Core.LayoutClass l a) => XMonad.Layout.TallMastersCombo.GetFocused (XMonad.Layout.LayoutModifier.ModifiedLayout m l) a
instance XMonad.Core.Message XMonad.Layout.TallMastersCombo.NextNoWrap
instance XMonad.Core.Message XMonad.Layout.TallMastersCombo.ChangeFocus
instance XMonad.Core.Message XMonad.Layout.TallMastersCombo.FocusedNextLayout
instance XMonad.Core.Message XMonad.Layout.TallMastersCombo.FocusSubMaster
instance XMonad.Core.Message XMonad.Layout.TallMastersCombo.SwapSubMaster
instance XMonad.Core.Message XMonad.Layout.TallMastersCombo.SwitchOrientation
instance XMonad.Core.LayoutClass XMonad.Layout.TallMastersCombo.RowsOrColumns a
instance XMonad.Core.Message XMonad.Layout.TallMastersCombo.Orientation


-- | A tabbed layout for the Xmonad Window Manager
module XMonad.Layout.Tabbed

-- | A tabbed layout with the default xmonad Theme.
--   
--   This is a minimal working configuration:
--   
--   <pre>
--   import XMonad
--   import XMonad.Layout.Tabbed
--   main = xmonad def { layoutHook = simpleTabbed }
--   </pre>
simpleTabbed :: ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest Window

-- | A layout decorated with tabs and the possibility to set a custom
--   shrinker and theme.
tabbed :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabbedDecoration s) Simplest a

-- | A layout modifier that uses the provided shrinker and theme to add
--   tabs to any layout.
addTabs :: (Eq a, LayoutClass l a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration TabbedDecoration s) l a
simpleTabbedAlways :: ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest Window
tabbedAlways :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabbedDecoration s) Simplest a
addTabsAlways :: (Eq a, LayoutClass l a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration TabbedDecoration s) l a

-- | A bottom-tabbed layout with the default xmonad Theme.
simpleTabbedBottom :: ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest Window

-- | A layout decorated with tabs at the bottom and the possibility to set
--   a custom shrinker and theme.
tabbedBottom :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabbedDecoration s) Simplest a

-- | A layout modifier that uses the provided shrinker and theme to add
--   tabs to the bottom of any layout.
addTabsBottom :: (Eq a, LayoutClass l a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration TabbedDecoration s) l a

-- | A side-tabbed layout with the default xmonad Theme.
simpleTabbedLeft :: ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest Window

-- | A layout decorated with tabs and the possibility to set a custom
--   shrinker and theme.
tabbedLeft :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabbedDecoration s) Simplest a

-- | A layout modifier that uses the provided shrinker and theme to add
--   tabs to the side of any layout.
addTabsLeft :: (Eq a, LayoutClass l a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration TabbedDecoration s) l a

-- | A side-tabbed layout with the default xmonad Theme.
simpleTabbedRight :: ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest Window

-- | A layout decorated with tabs and the possibility to set a custom
--   shrinker and theme.
tabbedRight :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabbedDecoration s) Simplest a

-- | A layout modifier that uses the provided shrinker and theme to add
--   tabs to the side of any layout.
addTabsRight :: (Eq a, LayoutClass l a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration TabbedDecoration s) l a

-- | A bottom-tabbed layout with the default xmonad Theme.
simpleTabbedBottomAlways :: ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest Window
tabbedBottomAlways :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabbedDecoration s) Simplest a
addTabsBottomAlways :: (Eq a, LayoutClass l a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration TabbedDecoration s) l a

-- | A side-tabbed layout with the default xmonad Theme.
simpleTabbedLeftAlways :: ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest Window

-- | A layout decorated with tabs and the possibility to set a custom
--   shrinker and theme.
tabbedLeftAlways :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabbedDecoration s) Simplest a
addTabsLeftAlways :: (Eq a, LayoutClass l a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration TabbedDecoration s) l a

-- | A side-tabbed layout with the default xmonad Theme.
simpleTabbedRightAlways :: ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest Window

-- | A layout decorated with tabs and the possibility to set a custom
--   shrinker and theme.
tabbedRightAlways :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabbedDecoration s) Simplest a
addTabsRightAlways :: (Eq a, LayoutClass l a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration TabbedDecoration s) l a

-- | A <a>Theme</a> is a record of colors, font etc., to customize a
--   <a>DecorationStyle</a>.
--   
--   For a collection of <a>Theme</a>s see <a>XMonad.Util.Themes</a>
data Theme
Theme :: String -> String -> String -> String -> String -> String -> Dimension -> Dimension -> Dimension -> String -> String -> String -> String -> Dimension -> Dimension -> [(String, Align)] -> [([[Bool]], Placement)] -> Theme

-- | Color of the active window
[activeColor] :: Theme -> String

-- | Color of the inactive window
[inactiveColor] :: Theme -> String

-- | Color of the urgent window
[urgentColor] :: Theme -> String

-- | Color of the border of the active window
[activeBorderColor] :: Theme -> String

-- | Color of the border of the inactive window
[inactiveBorderColor] :: Theme -> String

-- | Color of the border of the urgent window
[urgentBorderColor] :: Theme -> String

-- | Width of the border of the active window
[activeBorderWidth] :: Theme -> Dimension

-- | Width of the border of the inactive window
[inactiveBorderWidth] :: Theme -> Dimension

-- | Width of the border of the urgent window
[urgentBorderWidth] :: Theme -> Dimension

-- | Color of the text of the active window
[activeTextColor] :: Theme -> String

-- | Color of the text of the inactive window
[inactiveTextColor] :: Theme -> String

-- | Color of the text of the urgent window
[urgentTextColor] :: Theme -> String

-- | Font name
[fontName] :: Theme -> String

-- | Maximum width of the decorations (if supported by the
--   <a>DecorationStyle</a>)
[decoWidth] :: Theme -> Dimension

-- | Height of the decorations
[decoHeight] :: Theme -> Dimension

-- | Extra text to appear in a window's title bar. Refer to for a use
--   <a>XMonad.Layout.ImageButtonDecoration</a>
[windowTitleAddons] :: Theme -> [(String, Align)]

-- | Extra icons to appear in a window's title bar. Inner <tt>[Bool]</tt>
--   is a row in a icon bitmap.
[windowTitleIcons] :: Theme -> [([[Bool]], Placement)]

-- | The default value for this type.
def :: Default a => a
data TabbedDecoration a
Tabbed :: Direction2D -> TabbarShown -> TabbedDecoration a
shrinkText :: DefaultShrinker
data CustomShrink
CustomShrink :: CustomShrink
class (Read s, Show s) => Shrinker s
shrinkIt :: Shrinker s => s -> String -> [String]
data TabbarShown

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D
instance GHC.Classes.Eq XMonad.Layout.Tabbed.TabbarShown
instance GHC.Show.Show XMonad.Layout.Tabbed.TabbarShown
instance GHC.Read.Read XMonad.Layout.Tabbed.TabbarShown
instance GHC.Show.Show (XMonad.Layout.Tabbed.TabbedDecoration a)
instance GHC.Read.Read (XMonad.Layout.Tabbed.TabbedDecoration a)
instance GHC.Classes.Eq a => XMonad.Layout.Decoration.DecorationStyle XMonad.Layout.Tabbed.TabbedDecoration a



-- | <i>Deprecated: This module contains a personal configuration, to be
--   removed from xmonad-contrib. If you use this module, please copy the
--   relevant parts to your configuration or obtain a copy of it on
--   <a>https://xmonad.org/configurations.html</a> and include it as a
--   local module.</i>
module XMonad.Config.Sjanssen
sjanssenConfig :: XConfig (ModifiedLayout AvoidStruts (ModifiedLayout SmartBorder (Choose (Choose HintedTile (Choose HintedTile Full)) (ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest))))



-- | <i>Deprecated: This module contains a personal configuration, to be
--   removed from xmonad-contrib. If you use this module, please copy the
--   relevant parts to your configuration or obtain a copy of it on
--   <a>https://xmonad.org/configurations.html</a> and include it as a
--   local module.</i>
module XMonad.Config.Droundy
config :: XConfig (ModifiedLayout ShowWName (ModifiedLayout WorkspaceDir (ModifiedLayout BoringWindows (ModifiedLayout SmartBorder (ModifiedLayout WindowNavigation (ModifiedLayout Magnifier (ToggleLayouts Full (ModifiedLayout AvoidStruts (Choose (ModifiedLayout Rename (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest)) (Choose (ModifiedLayout Rename (CombineTwo (DragPane ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (CombineTwo (Square ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest)))) (Choose (ModifiedLayout Rename (CombineTwo (DragPane ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (CombineTwo (DragPane ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (CombineTwo (Square ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest))))) (ModifiedLayout Rename (CombineTwo (DragPane ()) (CombineTwo (DragPane ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest)) (CombineTwo (Square ()) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest) (ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest)))))))))))))))
mytab :: ModifiedLayout (Decoration TabbedDecoration CustomShrink) Simplest Window
instance XMonad.Layout.Decoration.Shrinker XMonad.Layout.Decoration.CustomShrink


-- | A layout combinator that allows layouts to be nested.
module XMonad.Layout.SubLayouts

-- | The main layout modifier arguments:
--   
--   <pre>
--   subLayout advanceInnerLayouts innerLayout outerLayout
--   </pre>
--   
--   <ul>
--   <li><i><tt>advanceInnerLayouts</tt></i> When a new group at index
--   <tt>n</tt> in the outer layout is created (even with one element), the
--   <tt>innerLayout</tt> is used as the layout within that group after
--   being advanced with <tt>advanceInnerLayouts !! n</tt>
--   <a>NextLayout</a> messages. If there is no corresponding element in
--   the <tt>advanceInnerLayouts</tt> list, then <tt>innerLayout</tt> is
--   not given any <a>NextLayout</a> messages.</li>
--   <li><i><tt>innerLayout</tt></i> The single layout given to be run as a
--   sublayout.</li>
--   <li><i><tt>outerLayout</tt></i> The layout that determines the
--   rectangles given to each group.</li>
--   </ul>
--   
--   Ex. The second group is <a>Tall</a>, the third is <a>circle</a>, all
--   others are tabbed with:
--   
--   <pre>
--   myLayout = addTabs shrinkText def
--            $ subLayout [0,1,2] (Simplest ||| Tall 1 0.2 0.5 ||| circle)
--            $ Tall 1 0.2 0.5 ||| Full
--   </pre>
subLayout :: [Int] -> subl a -> l a -> ModifiedLayout (Sublayout subl) l a

-- | <tt>subTabbed</tt> is a use of <a>subLayout</a> with <a>addTabs</a> to
--   show decorations.
subTabbed :: (Eq a, LayoutModifier (Sublayout Simplest) a, LayoutClass l a) => l a -> ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) (ModifiedLayout (Sublayout Simplest) l) a

-- | <tt>pullGroup</tt>, <tt>pushGroup</tt> allow you to merge windows or
--   groups inheriting the position of the current window (pull) or the
--   other window (push).
--   
--   <tt>pushWindow</tt> and <tt>pullWindow</tt> move individual windows
--   between groups. They are less effective at preserving window
--   positions.
pushGroup :: Direction2D -> Navigate

-- | <tt>pullGroup</tt>, <tt>pushGroup</tt> allow you to merge windows or
--   groups inheriting the position of the current window (pull) or the
--   other window (push).
--   
--   <tt>pushWindow</tt> and <tt>pullWindow</tt> move individual windows
--   between groups. They are less effective at preserving window
--   positions.
pullGroup :: Direction2D -> Navigate

-- | <tt>pullGroup</tt>, <tt>pushGroup</tt> allow you to merge windows or
--   groups inheriting the position of the current window (pull) or the
--   other window (push).
--   
--   <tt>pushWindow</tt> and <tt>pullWindow</tt> move individual windows
--   between groups. They are less effective at preserving window
--   positions.
pushWindow :: Direction2D -> Navigate

-- | <tt>pullGroup</tt>, <tt>pushGroup</tt> allow you to merge windows or
--   groups inheriting the position of the current window (pull) or the
--   other window (push).
--   
--   <tt>pushWindow</tt> and <tt>pullWindow</tt> move individual windows
--   between groups. They are less effective at preserving window
--   positions.
pullWindow :: Direction2D -> Navigate

-- | Apply a function on the stack belonging to the currently focused
--   group. It works for rearranging windows and for changing focus.
onGroup :: (Stack Window -> Stack Window) -> X ()

-- | Send a message to the currently focused sublayout.
toSubl :: Message a => a -> X ()

-- | merge the window that would be focused by the function when applied to
--   the W.Stack of all windows, with the current group removed. The given
--   window should be focused by a sublayout. Example usage:
--   <tt>withFocused (sendMessage . mergeDir W.focusDown')</tt>
mergeDir :: (Stack Window -> Stack Window) -> Window -> GroupMsg Window

-- | GroupMsg take window parameters to determine which group the action
--   should be applied to
data GroupMsg a

-- | free the focused window from its tab stack
UnMerge :: a -> GroupMsg a

-- | separate the focused group into singleton groups
UnMergeAll :: a -> GroupMsg a

-- | merge the first group into the second group
Merge :: a -> a -> GroupMsg a

-- | make one large group, keeping the parameter focused
MergeAll :: a -> GroupMsg a

-- | used to the window named in the first argument to the second
--   argument's group, this may be replaced by a combination of
--   <a>UnMerge</a> and <a>Merge</a>
Migrate :: a -> a -> GroupMsg a
WithGroup :: (Stack a -> X (Stack a)) -> a -> GroupMsg a

-- | the sublayout with the given window will get the message
SubMessage :: SomeMessage -> a -> GroupMsg a
newtype Broadcast

-- | send a message to all sublayouts
Broadcast :: SomeMessage -> Broadcast

-- | <tt>defaultSublMap</tt> is an attempt to create a set of keybindings
--   like the defaults ones but to be used as a <tt>submap</tt> for sending
--   messages to the sublayout.
defaultSublMap :: XConfig l -> Map (KeyMask, KeySym) (X ())
data Sublayout l a
instance (GHC.Show.Show a, GHC.Show.Show (l a)) => GHC.Show.Show (XMonad.Layout.SubLayouts.Sublayout l a)
instance (GHC.Read.Read a, GHC.Read.Read (l a)) => GHC.Read.Read (XMonad.Layout.SubLayouts.Sublayout l a)
instance XMonad.Core.Message XMonad.Layout.SubLayouts.Broadcast
instance (GHC.Read.Read (l Graphics.X11.Types.Window), GHC.Show.Show (l Graphics.X11.Types.Window), XMonad.Core.LayoutClass l Graphics.X11.Types.Window) => XMonad.Layout.LayoutModifier.LayoutModifier (XMonad.Layout.SubLayouts.Sublayout l) Graphics.X11.Types.Window
instance Data.Typeable.Internal.Typeable a => XMonad.Core.Message (XMonad.Layout.SubLayouts.GroupMsg a)


-- | Provides a handleEventHook that implements window swallowing.
--   
--   If you open a GUI-window (i.e. feh) from the terminal, the terminal
--   will normally still be shown on screen, unnecessarily taking up space
--   on the screen. With window swallowing, can detect that you opened a
--   window from within another window, and allows you "swallow" that
--   parent window for the time the new window is running.
--   
--   <b>NOTE</b> that this does not always work perfectly:
--   
--   <ul>
--   <li>Because window swallowing needs to check the process hierarchy, it
--   requires both the child and the parent to be distinct processes. This
--   means that applications which implement instance sharing cannot be
--   supported by window swallowing. Most notably, this excludes some
--   terminal emulators as well as tmux from functioning as the parent
--   process. It also excludes a good amount of child programs, because
--   many graphical applications do implement instance sharing. For
--   example, window swallowing will probably not work with your
--   browser.</li>
--   <li>To check the process hierarchy, we need to be able to get the
--   process ID by looking at the window. This requires the
--   <tt>_NET_WM_PID</tt> X-property to be set. If any application you want
--   to use this with does not provide the <tt>_NET_WM_PID</tt>, there is
--   not much you can do except for reaching out to the author of that
--   application and asking them to set that property. Additionally,
--   applications running in their own PID namespace, such as those in
--   Flatpak, can't set a correct <tt>_NET_WM_PID</tt> even if they wanted
--   to.</li>
--   </ul>
module XMonad.Hooks.WindowSwallowing

-- | handleEventHook that will swallow child windows when they are opened
--   from another window.
swallowEventHook :: Query Bool -> Query Bool -> Event -> X All

-- | handleEventHook that will merge child windows via
--   <a>XMonad.Layout.SubLayouts</a> when they are opened from another
--   window.
swallowEventHookSub :: Query Bool -> Query Bool -> Event -> X All
instance GHC.Show.Show XMonad.Hooks.WindowSwallowing.SwallowingState
instance XMonad.Core.ExtensionClass XMonad.Hooks.WindowSwallowing.SwallowingState


-- | A layout modifier for adding simple decorations to the windows of a
--   given layout. The decorations are in the form of ion-like tabs for
--   window titles.
module XMonad.Layout.SimpleDecoration

-- | Add simple decorations to windows of a layout.
simpleDeco :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration SimpleDecoration s) l a

-- | A <a>Theme</a> is a record of colors, font etc., to customize a
--   <a>DecorationStyle</a>.
--   
--   For a collection of <a>Theme</a>s see <a>XMonad.Util.Themes</a>
data Theme
Theme :: String -> String -> String -> String -> String -> String -> Dimension -> Dimension -> Dimension -> String -> String -> String -> String -> Dimension -> Dimension -> [(String, Align)] -> [([[Bool]], Placement)] -> Theme

-- | Color of the active window
[activeColor] :: Theme -> String

-- | Color of the inactive window
[inactiveColor] :: Theme -> String

-- | Color of the urgent window
[urgentColor] :: Theme -> String

-- | Color of the border of the active window
[activeBorderColor] :: Theme -> String

-- | Color of the border of the inactive window
[inactiveBorderColor] :: Theme -> String

-- | Color of the border of the urgent window
[urgentBorderColor] :: Theme -> String

-- | Width of the border of the active window
[activeBorderWidth] :: Theme -> Dimension

-- | Width of the border of the inactive window
[inactiveBorderWidth] :: Theme -> Dimension

-- | Width of the border of the urgent window
[urgentBorderWidth] :: Theme -> Dimension

-- | Color of the text of the active window
[activeTextColor] :: Theme -> String

-- | Color of the text of the inactive window
[inactiveTextColor] :: Theme -> String

-- | Color of the text of the urgent window
[urgentTextColor] :: Theme -> String

-- | Font name
[fontName] :: Theme -> String

-- | Maximum width of the decorations (if supported by the
--   <a>DecorationStyle</a>)
[decoWidth] :: Theme -> Dimension

-- | Height of the decorations
[decoHeight] :: Theme -> Dimension

-- | Extra text to appear in a window's title bar. Refer to for a use
--   <a>XMonad.Layout.ImageButtonDecoration</a>
[windowTitleAddons] :: Theme -> [(String, Align)]

-- | Extra icons to appear in a window's title bar. Inner <tt>[Bool]</tt>
--   is a row in a icon bitmap.
[windowTitleIcons] :: Theme -> [([[Bool]], Placement)]

-- | The default value for this type.
def :: Default a => a
newtype SimpleDecoration a
Simple :: Bool -> SimpleDecoration a
shrinkText :: DefaultShrinker
data CustomShrink
CustomShrink :: CustomShrink
class (Read s, Show s) => Shrinker s
shrinkIt :: Shrinker s => s -> String -> [String]
instance GHC.Read.Read (XMonad.Layout.SimpleDecoration.SimpleDecoration a)
instance GHC.Show.Show (XMonad.Layout.SimpleDecoration.SimpleDecoration a)
instance GHC.Classes.Eq a => XMonad.Layout.Decoration.DecorationStyle XMonad.Layout.SimpleDecoration.SimpleDecoration a


-- | This module allows for having a configurable border position around
--   windows; i.e., it can move the border to any cardinal direction.
module XMonad.Layout.SideBorderDecoration

-- | Move the default XMonad border to any of the four cardinal directions.
--   
--   Note that this function should only be applied once to your
--   configuration and should <i>not</i> be combined with
--   <a>sideBorderLayout</a>.
sideBorder :: SideBorderConfig -> XConfig l -> XConfig (SideBorder l)

-- | Configuring how the border looks like.
data SideBorderConfig
SideBorderConfig :: !Direction2D -> !String -> !String -> !Dimension -> SideBorderConfig

-- | Which side to have the border on.
[sbSide] :: SideBorderConfig -> !Direction2D

-- | Active border colour.
[sbActiveColor] :: SideBorderConfig -> !String

-- | Inactive border colour.
[sbInactiveColor] :: SideBorderConfig -> !String

-- | Size of the border. This will be the height if <a>sbSide</a> is
--   <a>U</a> or <a>Direction2D</a> and the width if it is <a>L</a> or
--   <a>R</a>.
[sbSize] :: SideBorderConfig -> !Dimension

-- | The default value for this type.
def :: Default a => a

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D

-- | Layout hook to only enable the side border for some layouts. For
--   example:
--   
--   <pre>
--   myLayout = Full ||| sideBorderLayout def tall ||| somethingElse
--   </pre>
--   
--   Note that, unlike <a>sideBorder</a>, this does <i>not</i> disable the
--   normal border in XMonad, you will have to do this yourself. Remove
--   this function from your layout hook and use <a>sideBorder</a> if you
--   want a side border in every layout (do not use the two functions
--   together).
sideBorderLayout :: Eq a => SideBorderConfig -> l a -> SideBorder l a
instance GHC.Read.Read (XMonad.Layout.SideBorderDecoration.SideBorderDecoration a)
instance GHC.Show.Show (XMonad.Layout.SideBorderDecoration.SideBorderDecoration a)
instance GHC.Show.Show XMonad.Layout.SideBorderDecoration.BorderShrinker
instance GHC.Read.Read XMonad.Layout.SideBorderDecoration.BorderShrinker
instance XMonad.Layout.Decoration.Shrinker XMonad.Layout.SideBorderDecoration.BorderShrinker
instance GHC.Classes.Eq a => XMonad.Layout.Decoration.DecorationStyle XMonad.Layout.SideBorderDecoration.SideBorderDecoration a
instance Data.Default.Class.Default XMonad.Layout.SideBorderDecoration.SideBorderConfig


-- | A layout transformer to have a layout respect a given screen geometry.
--   Mostly used with <a>XMonad.Layout.Decoration</a> (the Horizontal and
--   the Vertical version will react to SetTheme and change their dimension
--   accordingly.
module XMonad.Layout.ResizeScreen
resizeHorizontal :: Int -> l a -> ModifiedLayout ResizeScreen l a
resizeVertical :: Int -> l a -> ModifiedLayout ResizeScreen l a
resizeHorizontalRight :: Int -> l a -> ModifiedLayout ResizeScreen l a
resizeVerticalBottom :: Int -> l a -> ModifiedLayout ResizeScreen l a
withNewRectangle :: Rectangle -> l a -> ModifiedLayout ResizeScreen l a
data ResizeScreen a
ResizeScreen :: ResizeMode -> Int -> ResizeScreen a
WithNewScreen :: Rectangle -> ResizeScreen a
data ResizeMode
instance GHC.Show.Show XMonad.Layout.ResizeScreen.ResizeMode
instance GHC.Read.Read XMonad.Layout.ResizeScreen.ResizeMode
instance GHC.Show.Show (XMonad.Layout.ResizeScreen.ResizeScreen a)
instance GHC.Read.Read (XMonad.Layout.ResizeScreen.ResizeScreen a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.ResizeScreen.ResizeScreen a


-- | A layout modifier to add a bar of tabs to your layouts.
module XMonad.Layout.TabBarDecoration

-- | Add, on the top of the screen, a simple bar of tabs to a given |
--   layout, with the default theme and the default shrinker.
simpleTabBar :: Eq a => l a -> ModifiedLayout (Decoration TabBarDecoration DefaultShrinker) (ModifiedLayout ResizeScreen l) a

-- | Same of <a>simpleTabBar</a>, but with the possibility of setting a
--   custom shrinker, a custom theme and the position: <a>Top</a> or
--   <a>Bottom</a>.
tabBar :: (Eq a, Shrinker s) => s -> Theme -> XPPosition -> l a -> ModifiedLayout (Decoration TabBarDecoration s) l a

-- | The default value for this type.
def :: Default a => a
shrinkText :: DefaultShrinker
newtype TabBarDecoration a
TabBar :: XPPosition -> TabBarDecoration a
data XPPosition
Top :: XPPosition
Bottom :: XPPosition

-- | Prompt will be placed in the center horizontally and in the certain
--   place of screen vertically. If it's in the upper part of the screen,
--   completion window will be placed below (like in <a>Top</a>) and
--   otherwise above (like in <a>Bottom</a>)
CenteredAt :: Rational -> Rational -> XPPosition

-- | Rational between 0 and 1, giving y coordinate of center of the prompt
--   relative to the screen height.
[xpCenterY] :: XPPosition -> Rational

-- | Rational between 0 and 1, giving width of the prompt relative to the
--   screen width.
[xpWidth] :: XPPosition -> Rational
instance GHC.Show.Show (XMonad.Layout.TabBarDecoration.TabBarDecoration a)
instance GHC.Read.Read (XMonad.Layout.TabBarDecoration.TabBarDecoration a)
instance GHC.Classes.Eq a => XMonad.Layout.Decoration.DecorationStyle XMonad.Layout.TabBarDecoration.TabBarDecoration a


-- | Provides a simple transformer for use with
--   <a>XMonad.Layout.MultiToggle</a> to dynamically toggle
--   <a>XMonad.Layout.TabBarDecoration</a>.
module XMonad.Layout.MultiToggle.TabBarDecoration

-- | Transformer for <a>XMonad.Layout.TabBarDecoration</a>.
data SimpleTabBar
SIMPLETABBAR :: SimpleTabBar
instance GHC.Classes.Eq XMonad.Layout.MultiToggle.TabBarDecoration.SimpleTabBar
instance GHC.Show.Show XMonad.Layout.MultiToggle.TabBarDecoration.SimpleTabBar
instance GHC.Read.Read XMonad.Layout.MultiToggle.TabBarDecoration.SimpleTabBar
instance XMonad.Layout.MultiToggle.Transformer XMonad.Layout.MultiToggle.TabBarDecoration.SimpleTabBar Graphics.X11.Types.Window


-- | Most basic version of decoration for windows without any additional
--   modifications. In contrast to <a>XMonad.Layout.SimpleDecoration</a>
--   this will result in title bars that span the entire window instead of
--   being only the length of the window title.
module XMonad.Layout.NoFrillsDecoration

-- | Add very simple decorations to windows of a layout.
noFrillsDeco :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration NoFrillsDecoration s) l a
data NoFrillsDecoration a
instance GHC.Read.Read (XMonad.Layout.NoFrillsDecoration.NoFrillsDecoration a)
instance GHC.Show.Show (XMonad.Layout.NoFrillsDecoration.NoFrillsDecoration a)
instance GHC.Classes.Eq a => XMonad.Layout.Decoration.DecorationStyle XMonad.Layout.NoFrillsDecoration.NoFrillsDecoration a


-- | Make layouts respect size hints.
module XMonad.Layout.LayoutHints
layoutHints :: LayoutClass l a => l a -> ModifiedLayout LayoutHints l a

-- | <tt>layoutHintsWithPlacement (rx, ry) layout</tt> will adapt the sizes
--   of a layout's windows according to their size hints, and position them
--   inside their originally assigned area according to the <tt>rx</tt> and
--   <tt>ry</tt> parameters. (0, 0) places the window at the top left, (1,
--   0) at the top right, (0.5, 0.5) at the center, etc.
layoutHintsWithPlacement :: LayoutClass l a => (Double, Double) -> l a -> ModifiedLayout LayoutHints l a

-- | <tt>layoutHintsToCenter layout</tt> applies hints, sliding the window
--   to the center of the screen and expanding its neighbors to fill the
--   gaps. Windows are never expanded in a way that increases overlap.
--   
--   <tt>layoutHintsToCenter</tt> only makes one pass at resizing the
--   neighbors of hinted windows, so with some layouts (ex. the arrangement
--   with two <tt>Mirror</tt> <tt>Tall</tt> stacked vertically),
--   <tt>layoutHintsToCenter</tt> may leave some gaps. Simple layouts like
--   <tt>Tall</tt> are unaffected.
layoutHintsToCenter :: LayoutClass l a => l a -> ModifiedLayout LayoutHintsToCenter l a
data LayoutHints a
data LayoutHintsToCenter a

-- | Event hook that refreshes the layout whenever a window changes its
--   hints.
hintsEventHook :: Event -> X All

-- | <tt>placeRectangle (rx, ry) r0 r</tt> will return a new rectangle with
--   the same dimensions as <tt>r</tt>, but positioned inside of
--   <tt>r0</tt> as specified by the (rx, ry) parameters (see
--   <a>layoutHintsWithPlacement</a>).
placeRectangle :: RealFrac r => (r, r) -> Rectangle -> Rectangle -> Rectangle
instance GHC.Show.Show (XMonad.Layout.LayoutHints.LayoutHints a)
instance GHC.Read.Read (XMonad.Layout.LayoutHints.LayoutHints a)
instance GHC.Show.Show (XMonad.Layout.LayoutHints.LayoutHintsToCenter a)
instance GHC.Read.Read (XMonad.Layout.LayoutHints.LayoutHintsToCenter a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.LayoutHints.LayoutHintsToCenter Graphics.X11.Types.Window
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.LayoutHints.LayoutHints Graphics.X11.Types.Window


-- | Example layouts for <a>XMonad.Layout.Groups</a>.
module XMonad.Layout.Groups.Examples
rowOfColumns :: Groups (ModifiedLayout Rename (Mirror (ZoomRow ClassEQ))) (ZoomRow GroupEQ) Window

-- | Increase the width of the focused column
zoomColumnIn :: X ()

-- | Decrease the width of the focused column
zoomColumnOut :: X ()

-- | Reset the width of the focused column
zoomColumnReset :: X ()

-- | Toggle whether the currently focused column should take up all
--   available space whenever it has focus
toggleColumnFull :: X ()

-- | Increase the heigth of the focused window
zoomWindowIn :: X ()

-- | Decrease the height of the focused window
zoomWindowOut :: X ()

-- | Reset the height of the focused window
zoomWindowReset :: X ()

-- | Toggle whether the currently focused window should take up the whole
--   column whenever it has focus
toggleWindowFull :: X ()
tallTabs :: Shrinker s => TiledTabsConfig s -> ModifiedLayout Rename (ModifiedLayout (Decoration TabbedDecoration s) (Groups (ModifiedLayout Rename Simplest) (Choose (ModifiedLayout Rename Tall) (Choose (ModifiedLayout Rename (Mirror Tall)) Full)))) Window
mirrorTallTabs :: Shrinker s => TiledTabsConfig s -> ModifiedLayout Rename (ModifiedLayout (Decoration TabbedDecoration s) (Groups (ModifiedLayout Rename Simplest) (Choose (ModifiedLayout Rename (Mirror Tall)) (Choose Full (ModifiedLayout Rename Tall))))) Window
fullTabs :: Shrinker s => TiledTabsConfig s -> ModifiedLayout Rename (ModifiedLayout (Decoration TabbedDecoration s) (Groups (ModifiedLayout Rename Simplest) (Choose Full (Choose (ModifiedLayout Rename Tall) (ModifiedLayout Rename (Mirror Tall)))))) Window

-- | Configuration data for the "tiled tab groups" layout
data TiledTabsConfig s
TTC :: Int -> Rational -> Rational -> Int -> Rational -> Rational -> s -> Theme -> TiledTabsConfig s
[vNMaster] :: TiledTabsConfig s -> Int
[vRatio] :: TiledTabsConfig s -> Rational
[vIncrement] :: TiledTabsConfig s -> Rational
[hNMaster] :: TiledTabsConfig s -> Int
[hRatio] :: TiledTabsConfig s -> Rational
[hIncrement] :: TiledTabsConfig s -> Rational
[tabsShrinker] :: TiledTabsConfig s -> s
[tabsTheme] :: TiledTabsConfig s -> Theme

-- | The default value for this type.
def :: Default a => a

-- | Increase the number of master groups by one
increaseNMasterGroups :: X ()

-- | Decrease the number of master groups by one
decreaseNMasterGroups :: X ()

-- | Shrink the master area
shrinkMasterGroups :: X ()

-- | Expand the master area
expandMasterGroups :: X ()

-- | Rotate the available outer layout algorithms
nextOuterLayout :: X ()
shrinkText :: DefaultShrinker

-- | Compare two <tt>Group</tt>s by comparing the ids of their layouts.
data GroupEQ a
GroupEQ :: GroupEQ a
zoomRowG :: (Eq a, Show a, Read a, Show (l a), Read (l a)) => ZoomRow GroupEQ (Group l a)
instance GHC.Read.Read (XMonad.Layout.Groups.Examples.GroupEQ a)
instance GHC.Show.Show (XMonad.Layout.Groups.Examples.GroupEQ a)
instance (s GHC.Types.~ XMonad.Layout.Decoration.DefaultShrinker) => Data.Default.Class.Default (XMonad.Layout.Groups.Examples.TiledTabsConfig s)
instance GHC.Classes.Eq a => XMonad.Layout.ZoomRow.EQF XMonad.Layout.Groups.Examples.GroupEQ (XMonad.Layout.Groups.Group l a)


-- | A wmii-like layout algorithm.
module XMonad.Layout.Groups.Wmii

-- | A layout inspired by wmii
wmii :: Shrinker p => p -> Theme -> Groups (ModifiedLayout Rename (ModifiedLayout (Decoration TabbedDecoration p) (Ignore ChangeLayout (Ignore JumpToLayout (ModifiedLayout UnEscape (Choose (ModifiedLayout Rename Tall) (Choose (ModifiedLayout Rename Simplest) Full))))))) (ZoomRow GroupEQ) Window

-- | Increase the width of the focused group
zoomGroupIn :: X ()

-- | Decrease the size of the focused group
zoomGroupOut :: X ()

-- | Reset the size of the focused group to the default
zoomGroupReset :: X ()

-- | Toggle whether the currently focused group should be maximized
--   whenever it has focus.
toggleGroupFull :: X ()

-- | Rotate the layouts in the focused group.
groupToNextLayout :: X ()

-- | Switch the focused group to the "maximized" layout.
groupToFullLayout :: X ()

-- | Switch the focused group to the "tabbed" layout.
groupToTabbedLayout :: X ()

-- | Switch the focused group to the "column" layout.
groupToVerticalLayout :: X ()
shrinkText :: DefaultShrinker

-- | The default value for this type.
def :: Default a => a


-- | Layout modifier for user provided per-window aspect ratios.
module XMonad.Layout.FixedAspectRatio

-- | Similar to <tt>layoutHintsWithReplacement</tt>, but relies on the user
--   to provide the ratio for each window. <tt>aspectRatio (rx, ry)
--   layout</tt> will adapt the sizes of a layout's windows according to
--   the provided aspect ratio, and position them inside their originally
--   assigned area according to the <tt>rx</tt> and <tt>ry</tt> parameters.
--   (0, 0) places the window at the top left, (1, 0) at the top right,
--   (0.5, 0.5) at the center, etc.
fixedAspectRatio :: (Double, Double) -> l a -> ModifiedLayout FixedAspectRatio l a
data FixedAspectRatio a
data ManageAspectRatio

-- | Set the aspect ratio for the window
FixRatio :: Rational -> Window -> ManageAspectRatio

-- | Remove the aspect ratio for the window
ResetRatio :: Window -> ManageAspectRatio

-- | Toggle the reatio
ToggleRatio :: Rational -> Window -> ManageAspectRatio

-- | A <a>ManageHook</a> to set the aspect ratio for newly spawned windows
doFixAspect :: Rational -> ManageHook
instance GHC.Show.Show (XMonad.Layout.FixedAspectRatio.FixedAspectRatio a)
instance GHC.Read.Read (XMonad.Layout.FixedAspectRatio.FixedAspectRatio a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.FixedAspectRatio.FixedAspectRatio Graphics.X11.Types.Window
instance XMonad.Core.Message XMonad.Layout.FixedAspectRatio.ManageAspectRatio


-- | A layout modifier for decorating windows in a dwm like style.
module XMonad.Layout.DwmStyle

-- | Add simple old dwm-style decorations to windows of a layout.
dwmStyle :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration DwmStyle s) l a

-- | A <a>Theme</a> is a record of colors, font etc., to customize a
--   <a>DecorationStyle</a>.
--   
--   For a collection of <a>Theme</a>s see <a>XMonad.Util.Themes</a>
data Theme
Theme :: String -> String -> String -> String -> String -> String -> Dimension -> Dimension -> Dimension -> String -> String -> String -> String -> Dimension -> Dimension -> [(String, Align)] -> [([[Bool]], Placement)] -> Theme

-- | Color of the active window
[activeColor] :: Theme -> String

-- | Color of the inactive window
[inactiveColor] :: Theme -> String

-- | Color of the urgent window
[urgentColor] :: Theme -> String

-- | Color of the border of the active window
[activeBorderColor] :: Theme -> String

-- | Color of the border of the inactive window
[inactiveBorderColor] :: Theme -> String

-- | Color of the border of the urgent window
[urgentBorderColor] :: Theme -> String

-- | Width of the border of the active window
[activeBorderWidth] :: Theme -> Dimension

-- | Width of the border of the inactive window
[inactiveBorderWidth] :: Theme -> Dimension

-- | Width of the border of the urgent window
[urgentBorderWidth] :: Theme -> Dimension

-- | Color of the text of the active window
[activeTextColor] :: Theme -> String

-- | Color of the text of the inactive window
[inactiveTextColor] :: Theme -> String

-- | Color of the text of the urgent window
[urgentTextColor] :: Theme -> String

-- | Font name
[fontName] :: Theme -> String

-- | Maximum width of the decorations (if supported by the
--   <a>DecorationStyle</a>)
[decoWidth] :: Theme -> Dimension

-- | Height of the decorations
[decoHeight] :: Theme -> Dimension

-- | Extra text to appear in a window's title bar. Refer to for a use
--   <a>XMonad.Layout.ImageButtonDecoration</a>
[windowTitleAddons] :: Theme -> [(String, Align)]

-- | Extra icons to appear in a window's title bar. Inner <tt>[Bool]</tt>
--   is a row in a icon bitmap.
[windowTitleIcons] :: Theme -> [([[Bool]], Placement)]

-- | The default value for this type.
def :: Default a => a
data DwmStyle a
Dwm :: DwmStyle a
shrinkText :: DefaultShrinker
data CustomShrink
CustomShrink :: CustomShrink
class (Read s, Show s) => Shrinker s
shrinkIt :: Shrinker s => s -> String -> [String]
instance GHC.Read.Read (XMonad.Layout.DwmStyle.DwmStyle a)
instance GHC.Show.Show (XMonad.Layout.DwmStyle.DwmStyle a)
instance GHC.Classes.Eq a => XMonad.Layout.Decoration.DecorationStyle XMonad.Layout.DwmStyle.DwmStyle a


-- | This module defines <tt>DecorationGeometry</tt> type class, and
--   default implementation for it.
module XMonad.Layout.DecorationEx.Geometry

-- | Decoration geometry class. Decoration geometry is responsible for
--   placement of window decorations: whether they should be on the top of
--   the window or on the bottom, should they go for full window width or
--   only be of certain width, etc. This does not know what will be drawn
--   inside decorations.
class (Read (geom a), Show (geom a), Eq a) => DecorationGeometry geom a

-- | Give a name to decoration geometry implementation.
describeGeometry :: DecorationGeometry geom a => geom a -> String

-- | Reduce original window size to make space for decoration, if
--   necessary.
shrinkWindow :: DecorationGeometry geom a => geom a -> Rectangle -> Rectangle -> Rectangle

-- | The pure version of the main method, <tt>decorate</tt>. The method
--   should return a rectangle where to place window decoration, or
--   <a>Nothing</a> if this window is not to be decorated.
pureDecoration :: DecorationGeometry geom a => geom a -> Rectangle -> Stack a -> [(a, Rectangle)] -> (a, Rectangle) -> Maybe Rectangle

-- | The method should return a rectangle where to place window decoration,
--   or <a>Nothing</a> if this window is not to be decorated.
decorateWindow :: DecorationGeometry geom a => geom a -> Rectangle -> Stack a -> [(a, Rectangle)] -> (a, Rectangle) -> X (Maybe Rectangle)

-- | Data type for default implementation of <a>DecorationGeometry</a>.
--   This defines simple decorations: a horizontal bar at the top of each
--   window, running for full width of the window.
newtype DefaultGeometry a
DefaultGeometry :: Dimension -> DefaultGeometry a
[gDecorationHeight] :: DefaultGeometry a -> Dimension
instance GHC.Show.Show (XMonad.Layout.DecorationEx.Geometry.DefaultGeometry a)
instance GHC.Read.Read (XMonad.Layout.DecorationEx.Geometry.DefaultGeometry a)
instance GHC.Classes.Eq a => XMonad.Layout.DecorationEx.Geometry.DecorationGeometry XMonad.Layout.DecorationEx.Geometry.DefaultGeometry a
instance Data.Default.Class.Default (XMonad.Layout.DecorationEx.Geometry.DefaultGeometry a)


-- | This module exposes a number of types which are used by other
--   sub-modules of <a>XMonad.Layout.DecorationEx</a> module.
module XMonad.Layout.DecorationEx.Common

-- | Information about decoration of one window
data WindowDecoration
WindowDecoration :: !Window -> !Rectangle -> !Maybe Window -> !Maybe Rectangle -> ![WidgetPlace] -> WindowDecoration

-- | Original window (one being decorated)
[wdOrigWindow] :: WindowDecoration -> !Window

-- | Rectangle of original window
[wdOrigWinRect] :: WindowDecoration -> !Rectangle

-- | Decoration window, or Nothing if this window should not be decorated
[wdDecoWindow] :: WindowDecoration -> !Maybe Window

-- | Rectangle for decoration window
[wdDecoRect] :: WindowDecoration -> !Maybe Rectangle

-- | Places for widgets
[wdWidgets] :: WindowDecoration -> ![WidgetPlace]

-- | Type class for window commands (such as maximize or close window)
class (Read cmd, Show cmd) => WindowCommand cmd

-- | Execute the command
executeWindowCommand :: WindowCommand cmd => cmd -> Window -> X Bool

-- | Is the command currently in <tt>checked</tt> state. For example, for
--   <tt>sticky</tt> command, check if the window is currently sticky.
isCommandChecked :: WindowCommand cmd => cmd -> Window -> X Bool

-- | Type class for decoration widgets
class (WindowCommand (WidgetCommand widget), Read widget, Show widget) => DecorationWidget widget where {
    
    -- | Type of window commands which this type of widgets can execute
    type WidgetCommand widget;
}

-- | Get window command which is associated with this widget.
widgetCommand :: DecorationWidget widget => widget -> Int -> WidgetCommand widget

-- | Check if the widget is shrinkable, i.e. if it's width can be reduced
--   if there is not enough place in the decoration.
isShrinkable :: DecorationWidget widget => widget -> Bool

-- | Data type describing where the decoration widget (e.g. window button)
--   should be placed. All coordinates are relative to decoration
--   rectangle.
data WidgetPlace
WidgetPlace :: !Position -> !Rectangle -> WidgetPlace

-- | Y position of text base line (for widgets like window title or
--   text-based buttons)
[wpTextYPosition] :: WidgetPlace -> !Position

-- | Rectangle where to place the widget
[wpRectangle] :: WidgetPlace -> !Rectangle

-- | Layout of widgets
data WidgetLayout a
WidgetLayout :: ![a] -> ![a] -> ![a] -> WidgetLayout a

-- | Widgets that should be aligned to the left side of decoration
[wlLeft] :: WidgetLayout a -> ![a]

-- | Widgets that should be in the center of decoration
[wlCenter] :: WidgetLayout a -> ![a]

-- | Widgets taht should be aligned to the right side of decoration
[wlRight] :: WidgetLayout a -> ![a]

-- | Type class for themes, which claims that the theme contains the list
--   of widgets and their alignments.
class HasWidgets theme widget
themeWidgets :: HasWidgets theme widget => theme widget -> WidgetLayout widget

-- | Type class for themes, which claims that the theme can describe how
--   the decoration should respond to clicks on decoration itself (between
--   widgets).
class ClickHandler theme widget

-- | This is called when the user clicks on the decoration rectangle (not
--   on one of widgets).
onDecorationClick :: ClickHandler theme widget => theme widget -> Int -> Maybe (WidgetCommand widget)

-- | Determine if it is possible to drag window by it's decoration with
--   mouse button.
isDraggingEnabled :: ClickHandler theme widget => theme widget -> Int -> Bool

-- | Type class for themes, which claims that the theme is responsible for
--   determining looks of decoration.
class (Read theme, Show theme) => ThemeAttributes theme where {
    
    -- | Type which describes looks of decoration in one of window states
    --   (active, inactive, urgent, etc).
    type Style theme;
}

-- | Select style based on window state.
selectWindowStyle :: ThemeAttributes theme => theme -> Window -> X (Style theme)

-- | Define padding between decoration rectangle and widgets.
widgetsPadding :: ThemeAttributes theme => theme -> BoxBorders Dimension

-- | Initial background color of decoration rectangle. When decoration
--   widget is created, it is initially filled with this color.
defaultBgColor :: ThemeAttributes theme => theme -> String

-- | Font name defined in the theme.
themeFontName :: ThemeAttributes theme => theme -> String

-- | Painting context for decoration engines based on plain X11 calls.
type XPaintingContext = (Display, Pixmap, GC)

-- | Generic data type which is used to describe characteristics of
--   rectangle borders.
data BoxBorders a
BoxBorders :: !a -> !a -> !a -> !a -> BoxBorders a
[bxTop] :: BoxBorders a -> !a
[bxRight] :: BoxBorders a -> !a
[bxBottom] :: BoxBorders a -> !a
[bxLeft] :: BoxBorders a -> !a

-- | Convinience data type describing colors of decoration rectangle
--   borders.
type BorderColors = BoxBorders String

-- | Supported states of windows (on which looks of decorations can
--   depend).
data ThemeStyleType
ActiveWindow :: ThemeStyleType
UrgentWindow :: ThemeStyleType
InactiveWindow :: ThemeStyleType

-- | Data type describing look of window decoration in particular state
--   (active or inactive)
data SimpleStyle
SimpleStyle :: !String -> !String -> !String -> !Dimension -> !BorderColors -> SimpleStyle

-- | Decoration background color
[sBgColor] :: SimpleStyle -> !String

-- | Text (foreground) color
[sTextColor] :: SimpleStyle -> !String

-- | Text background color
[sTextBgColor] :: SimpleStyle -> !String

-- | Width of border of decoration rectangle. Set to 0 to disable the
--   border.
[sDecoBorderWidth] :: SimpleStyle -> !Dimension

-- | Colors of borders of decoration rectangle.
[sDecorationBorders] :: SimpleStyle -> !BorderColors

-- | Generic Theme data type. This is used by <tt>TextEngine</tt> and can
--   be used by other relatively simple decoration engines.
data GenericTheme style widget
GenericTheme :: !style -> !style -> !style -> !BoxBorders Dimension -> !String -> !Map Int (WidgetCommand widget) -> ![Int] -> ![widget] -> ![widget] -> ![widget] -> GenericTheme style widget

-- | Decoration style for active (focused) windows
[exActive] :: GenericTheme style widget -> !style

-- | Decoration style for inactive (unfocused) windows
[exInactive] :: GenericTheme style widget -> !style

-- | Decoration style for urgent windows
[exUrgent] :: GenericTheme style widget -> !style

-- | Padding between decoration rectangle and widgets
[exPadding] :: GenericTheme style widget -> !BoxBorders Dimension

-- | Font name
[exFontName] :: GenericTheme style widget -> !String

-- | Correspondence between mouse button number and window command.
[exOnDecoClick] :: GenericTheme style widget -> !Map Int (WidgetCommand widget)

-- | For which mouse buttons dragging is enabled
[exDragWindowButtons] :: GenericTheme style widget -> ![Int]

-- | Widgets that should appear at the left of decoration rectangle (listed
--   left to right)
[exWidgetsLeft] :: GenericTheme style widget -> ![widget]

-- | Widgets that should appear in the center of decoration rectangle
--   (listed left to right)
[exWidgetsCenter] :: GenericTheme style widget -> ![widget]

-- | Widgets that should appear at the right of decoration rectangle
--   (listed left to right)
[exWidgetsRight] :: GenericTheme style widget -> ![widget]

-- | Convience type for themes used by <tt>TextDecoration</tt>.
type ThemeEx widget = GenericTheme SimpleStyle widget

-- | Utility function to convert WidgetLayout to plain list of widgets.
widgetLayout :: WidgetLayout widget -> [widget]

-- | Detect type of style to be used from current state of the window.
windowStyleType :: Window -> X ThemeStyleType

-- | Generic utility function to select style from <tt>GenericTheme</tt>
--   based on current state of the window.
genericWindowStyle :: Window -> GenericTheme style widget -> X style

-- | Convert Theme type from <a>XMonad.Layout.Decoration</a> to theme type
--   used by <a>XMonad.Layout.DecorationEx.TextEngine</a>.
themeEx :: Default (WidgetCommand widget) => Theme -> ThemeEx widget
borderColor :: String -> BorderColors
shadowBorder :: String -> String -> BorderColors
instance GHC.Show.Show XMonad.Layout.DecorationEx.Common.WidgetPlace
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.DecorationEx.Common.BoxBorders a)
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Layout.DecorationEx.Common.BoxBorders a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (XMonad.Layout.DecorationEx.Common.BoxBorders a)
instance GHC.Read.Read XMonad.Layout.DecorationEx.Common.SimpleStyle
instance GHC.Show.Show XMonad.Layout.DecorationEx.Common.SimpleStyle
instance GHC.Read.Read XMonad.Layout.DecorationEx.Common.ThemeStyleType
instance GHC.Show.Show XMonad.Layout.DecorationEx.Common.ThemeStyleType
instance GHC.Classes.Eq XMonad.Layout.DecorationEx.Common.ThemeStyleType
instance (GHC.Show.Show widget, GHC.Show.Show (XMonad.Layout.DecorationEx.Common.WidgetCommand widget), GHC.Show.Show style) => GHC.Show.Show (XMonad.Layout.DecorationEx.Common.GenericTheme style widget)
instance (GHC.Read.Read widget, GHC.Read.Read (XMonad.Layout.DecorationEx.Common.WidgetCommand widget), GHC.Read.Read style) => GHC.Read.Read (XMonad.Layout.DecorationEx.Common.GenericTheme style widget)
instance (GHC.Show.Show widget, GHC.Read.Read widget, GHC.Read.Read (XMonad.Layout.DecorationEx.Common.WidgetCommand widget), GHC.Show.Show (XMonad.Layout.DecorationEx.Common.WidgetCommand widget)) => XMonad.Layout.DecorationEx.Common.ThemeAttributes (XMonad.Layout.DecorationEx.Common.ThemeEx widget)
instance Data.Default.Class.Default (XMonad.Layout.DecorationEx.Common.WidgetCommand widget) => Data.Default.Class.Default (XMonad.Layout.DecorationEx.Common.ThemeEx widget)
instance XMonad.Layout.DecorationEx.Common.HasWidgets (XMonad.Layout.DecorationEx.Common.GenericTheme style) widget
instance XMonad.Layout.DecorationEx.Common.ClickHandler (XMonad.Layout.DecorationEx.Common.GenericTheme XMonad.Layout.DecorationEx.Common.SimpleStyle) widget


-- | This module contains two hooks for the PositionStore (see
--   <a>XMonad.Util.PositionStore</a>) - a ManageHook and an EventHook.
--   
--   The ManageHook can be used to fill the PositionStore with position and
--   size information about new windows. The advantage of using this hook
--   is, that the information is recorded independent of the currently
--   active layout. So the floating shape of the window can later be
--   restored even if it was opened in a tiled layout initially.
--   
--   For windows, that do not request a particular position, a random
--   position will be assigned. This prevents windows from piling up
--   exactly on top of each other.
--   
--   The EventHook makes sure that windows are deleted from the
--   PositionStore when they are closed.
module XMonad.Hooks.PositionStoreHooks
positionStoreManageHook :: Maybe Theme -> ManageHook
positionStoreEventHook :: Event -> X All


-- | GridSelect displays items(e.g. the opened windows) in a 2D grid and
--   lets the user select from it with the cursor/hjkl keys or the mouse.
module XMonad.Actions.GridSelect

-- | The <a>Default</a> instance gives a basic configuration for
--   <a>gridselect</a>, with the colorizer chosen based on the type.
--   
--   If you want to replace the <a>gs_colorizer</a> field, use
--   <a>buildDefaultGSConfig</a> instead of <a>def</a> to avoid ambiguous
--   type variables.
data GSConfig a
GSConfig :: Integer -> Integer -> Integer -> (a -> Bool -> X (String, String)) -> String -> TwoD a (Maybe a) -> Rearranger a -> Double -> Double -> String -> Bool -> GSConfig a
[gs_cellheight] :: GSConfig a -> Integer
[gs_cellwidth] :: GSConfig a -> Integer
[gs_cellpadding] :: GSConfig a -> Integer
[gs_colorizer] :: GSConfig a -> a -> Bool -> X (String, String)
[gs_font] :: GSConfig a -> String

-- | Customize key bindings for a GridSelect
[gs_navigate] :: GSConfig a -> TwoD a (Maybe a)
[gs_rearranger] :: GSConfig a -> Rearranger a
[gs_originFractX] :: GSConfig a -> Double
[gs_originFractY] :: GSConfig a -> Double
[gs_bordercolor] :: GSConfig a -> String

-- | When True, click on empty space will cancel GridSelect
[gs_cancelOnEmptyClick] :: GSConfig a -> Bool

-- | The default value for this type.
def :: Default a => a
type TwoDPosition = (Integer, Integer)

-- | Builds a default gs config from a colorizer function.
buildDefaultGSConfig :: (a -> Bool -> X (String, String)) -> GSConfig a

-- | Brings up a 2D grid of elements in the center of the screen, and one
--   can select an element with cursors keys. The selected element is
--   returned.
gridselect :: GSConfig a -> [(String, a)] -> X (Maybe a)

-- | Like <tt>gridSelect</tt> but with the current windows and their titles
--   as elements
gridselectWindow :: GSConfig Window -> X (Maybe Window)

-- | Brings up a 2D grid of windows in the center of the screen, and one
--   can select a window with cursors keys. The selected window is then
--   passed to a callback function.
withSelectedWindow :: (Window -> X ()) -> GSConfig Window -> X ()

-- | Brings selected window to the current workspace.
bringSelected :: GSConfig Window -> X ()

-- | Switches to selected window's workspace and focuses that window.
goToSelected :: GSConfig Window -> X ()

-- | Select a workspace and view it using the given function (normally
--   <a>view</a> or <a>greedyView</a>)
--   
--   Another option is to shift the current window to the selected
--   workspace:
--   
--   <pre>
--   gridselectWorkspace (\ws -&gt; W.greedyView ws . W.shift ws)
--   </pre>
gridselectWorkspace :: GSConfig WorkspaceId -> (WorkspaceId -> WindowSet -> WindowSet) -> X ()

-- | Select a workspace and run an arbitrary action on it.
gridselectWorkspace' :: GSConfig WorkspaceId -> (WorkspaceId -> X ()) -> X ()

-- | Select an application to spawn from a given list
spawnSelected :: GSConfig String -> [String] -> X ()

-- | Select an action and run it in the X monad
runSelectedAction :: GSConfig (X ()) -> [(String, X ())] -> X ()

-- | That is <a>fromClassName</a> if you are selecting a <a>Window</a>, or
--   <a>defaultColorizer</a> if you are selecting a <a>String</a>. The
--   catch-all instance <tt>HasColorizer a</tt> uses the
--   <a>focusedBorderColor</a> and <a>normalBorderColor</a> colors.
class HasColorizer a
defaultColorizer :: HasColorizer a => a -> Bool -> X (String, String)

-- | Colorize a window depending on it's className.
fromClassName :: Window -> Bool -> X (String, String)

-- | Default colorizer for Strings
stringColorizer :: String -> Bool -> X (String, String)

-- | A colorizer that picks a color inside a range, and depending on the
--   window's class.
colorRangeFromClassName :: (Word8, Word8, Word8) -> (Word8, Word8, Word8) -> (Word8, Word8, Word8) -> (Word8, Word8, Word8) -> (Word8, Word8, Word8) -> Window -> Bool -> X (String, String)

-- | Generates a Double from a string, trying to achieve a random
--   distribution. We create a random seed from the hash of all characters
--   in the string, and use it to generate a ratio between 0 and 1
stringToRatio :: String -> Double
data TwoD a b

-- | Embeds a key handler into the X event handler that dispatches key
--   events to the key handler, while non-key event go to the standard
--   handler.
makeXEventhandler :: ((KeySym, String, KeyMask) -> TwoD a (Maybe a)) -> TwoD a (Maybe a)

-- | When the map contains (KeySym,KeyMask) tuple for the given event, the
--   associated action in the map associated shadows the default key
--   handler
shadowWithKeymap :: Map (KeyMask, KeySym) a -> ((KeySym, String, KeyMask) -> a) -> (KeySym, String, KeyMask) -> a

-- | By default gridselect used the defaultNavigation action, which binds
--   left,right,up,down and vi-style h,l,j,k navigation. Return quits
--   gridselect, returning the selected element, while Escape cancels the
--   selection. Slash enters the substring search mode. In substring search
--   mode, every string-associated keystroke is added to a search string,
--   which narrows down the object selection. Substring search mode comes
--   back to regular navigation via Return, while Escape cancels the
--   search. If you want that navigation style, add
--   <a>defaultNavigation</a> as <a>gs_navigate</a> to your <a>GSConfig</a>
--   object. This is done by <a>buildDefaultGSConfig</a> automatically.
defaultNavigation :: TwoD a (Maybe a)

-- | Navigation submode used for substring search. It returns to the first
--   argument navigation style when the user hits Return.
substringSearch :: TwoD a (Maybe a) -> TwoD a (Maybe a)

-- | This navigation style combines navigation and search into one mode at
--   the cost of losing vi style navigation. With this style, there is no
--   substring search submode, but every typed character is added to the
--   substring search.
navNSearch :: TwoD a (Maybe a)

-- | Sets the absolute position of the cursor.
setPos :: (Integer, Integer) -> TwoD a ()

-- | Moves the cursor by the offsets specified
move :: (Integer, Integer) -> TwoD a ()
moveNext :: TwoD a ()
movePrev :: TwoD a ()

-- | Closes gridselect returning the element under the cursor
select :: TwoD a (Maybe a)

-- | Closes gridselect returning no element.
cancel :: TwoD a (Maybe a)

-- | Apply a transformation function the current search string
transformSearchString :: (String -> String) -> TwoD a ()

-- | A function taking the search string and a list of elements, and
--   returning a potentially rearranged list of elements.
type Rearranger a = String -> [(String, a)] -> X [(String, a)]

-- | A rearranger that leaves the elements unmodified.
noRearranger :: Rearranger a

-- | A generator for rearrangers that append a single element based on the
--   search string, if doing so would not be redundant (empty string or
--   value already present).
searchStringRearrangerGenerator :: (String -> a) -> Rearranger a
data TwoDState a
instance Control.Monad.State.Class.MonadState (XMonad.Actions.GridSelect.TwoDState a) (XMonad.Actions.GridSelect.TwoD a)
instance GHC.Base.Monad (XMonad.Actions.GridSelect.TwoD a)
instance GHC.Base.Applicative (XMonad.Actions.GridSelect.TwoD a)
instance GHC.Base.Functor (XMonad.Actions.GridSelect.TwoD a)
instance XMonad.Actions.GridSelect.HasColorizer a => Data.Default.Class.Default (XMonad.Actions.GridSelect.GSConfig a)
instance XMonad.Actions.GridSelect.HasColorizer Graphics.X11.Types.Window
instance XMonad.Actions.GridSelect.HasColorizer GHC.Base.String
instance XMonad.Actions.GridSelect.HasColorizer a


-- | Uses <a>XMonad.Actions.GridSelect</a> to display a number of actions
--   related to window management in the center of the focused window.
--   Actions include: Closing, maximizing, minimizing and shifting the
--   window to another workspace.
--   
--   Note: For maximizing and minimizing to actually work, you will need to
--   integrate <a>XMonad.Layout.Maximize</a> and
--   <a>XMonad.Layout.Minimize</a> into your setup. See the documentation
--   of those modules for more information.
module XMonad.Actions.WindowMenu
windowMenu :: X ()


-- | Various stuff that can be added to the decoration. Most of it is
--   intended to be used by other modules. See
--   <a>XMonad.Layout.ButtonDecoration</a> for a module that makes use of
--   this.
module XMonad.Layout.DecorationAddons

-- | A function intended to be plugged into the
--   <a>decorationCatchClicksHook</a> of a decoration. It will intercept
--   clicks on the buttons of the decoration and invoke the associated
--   action. To actually see the buttons, you will need to use a theme that
--   includes them. See <a>defaultThemeWithButtons</a> below.
titleBarButtonHandler :: Window -> Int -> Int -> X Bool

-- | Intended to be used together with <a>titleBarButtonHandler</a>. See
--   above.
defaultThemeWithButtons :: Theme

-- | A function intended to be plugged into the
--   <a>decorationAfterDraggingHook</a> of a decoration. It will check if
--   the window has been dragged onto another screen and shift it there.
--   The PositionStore is also updated accordingly, as this is designed to
--   be used together with <a>XMonad.Layout.PositionStoreFloat</a>.
handleScreenCrossing :: Window -> Window -> X Bool


-- | A decoration that includes small image buttons on both ends which
--   invoke various actions when clicked on: Show a window menu (see
--   <a>XMonad.Actions.WindowMenu</a>), minimize, maximize or close the
--   window.
--   
--   Note: For maximizing and minimizing to actually work, you will need to
--   integrate <a>XMonad.Layout.Maximize</a> and
--   <a>XMonad.Layout.Minimize</a> into your setup. See the documentation
--   of those modules for more information.
module XMonad.Layout.ImageButtonDecoration
imageButtonDeco :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration ImageButtonDecoration s) l a
defaultThemeWithImageButtons :: Theme
shrinkText :: DefaultShrinker
data CustomShrink
CustomShrink :: CustomShrink
class (Read s, Show s) => Shrinker s

-- | A function intended to be plugged into the
--   <a>decorationCatchClicksHook</a> of a decoration. It will intercept
--   clicks on the buttons of the decoration and invoke the associated
--   action. To actually see the buttons, you will need to use a theme that
--   includes them. See <a>defaultThemeWithImageButtons</a> below.
imageTitleBarButtonHandler :: Window -> Int -> Int -> X Bool
data ImageButtonDecoration a
instance GHC.Read.Read (XMonad.Layout.ImageButtonDecoration.ImageButtonDecoration a)
instance GHC.Show.Show (XMonad.Layout.ImageButtonDecoration.ImageButtonDecoration a)
instance GHC.Classes.Eq a => XMonad.Layout.Decoration.DecorationStyle XMonad.Layout.ImageButtonDecoration.ImageButtonDecoration a


-- | A decoration that allows to switch the position of windows by dragging
--   them onto each other.
module XMonad.Layout.WindowSwitcherDecoration
windowSwitcherDecoration :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration WindowSwitcherDecoration s) l a
windowSwitcherDecorationWithButtons :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration WindowSwitcherDecoration s) l a
windowSwitcherDecorationWithImageButtons :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration ImageWindowSwitcherDecoration s) l a
data WindowSwitcherDecoration a
data ImageWindowSwitcherDecoration a
instance GHC.Read.Read (XMonad.Layout.WindowSwitcherDecoration.WindowSwitcherDecoration a)
instance GHC.Show.Show (XMonad.Layout.WindowSwitcherDecoration.WindowSwitcherDecoration a)
instance GHC.Read.Read (XMonad.Layout.WindowSwitcherDecoration.ImageWindowSwitcherDecoration a)
instance GHC.Show.Show (XMonad.Layout.WindowSwitcherDecoration.ImageWindowSwitcherDecoration a)
instance GHC.Classes.Eq a => XMonad.Layout.Decoration.DecorationStyle XMonad.Layout.WindowSwitcherDecoration.ImageWindowSwitcherDecoration a
instance GHC.Classes.Eq a => XMonad.Layout.Decoration.DecorationStyle XMonad.Layout.WindowSwitcherDecoration.WindowSwitcherDecoration a


-- | This module defines <tt>DecorationEngine</tt> type class, and default
--   implementation for it.
module XMonad.Layout.DecorationEx.Engine

-- | Decoration engines type class. Decoration engine is responsible for
--   drawing something inside decoration rectangle. It is also responsible
--   for handling X11 events (such as clicks) which happen within
--   decoration rectangle. Decoration rectangles are defined by
--   DecorationGeometry implementation.
class (Read (engine widget a), Show (engine widget a), Eq a, DecorationWidget widget, HasWidgets (Theme engine) widget, ClickHandler (Theme engine) widget, ThemeAttributes (Theme engine widget)) => DecorationEngine engine widget a where {
    
    -- | Type of themes used by decoration engine. This type must be
    --   parameterized over a widget type, because a theme will contain a list
    --   of widgets.
    type Theme engine :: Type -> Type;
    
    -- | Type of data used by engine as a context during painting; for plain
    --   X11-based implementation this is Display, Pixmap and GC.
    type DecorationPaintingContext engine;
    
    -- | Type of state used by the decoration engine. This can contain some
    --   resources that should be initialized and released at time, such as X11
    --   fonts.
    type DecorationEngineState engine;
}

-- | Give a name to decoration engine.
describeEngine :: DecorationEngine engine widget a => engine widget a -> String

-- | Initialize state of the engine.
initializeState :: DecorationEngine engine widget a => engine widget a -> geom a -> Theme engine widget -> X (DecorationEngineState engine)

-- | Release resources held in engine state.
releaseStateResources :: DecorationEngine engine widget a => engine widget a -> DecorationEngineState engine -> X ()

-- | Calculate place which will be occupied by one widget. NB: X coordinate
--   of the returned rectangle will be ignored, because the rectangle will
--   be moved to the right or to the left for proper alignment of widgets.
calcWidgetPlace :: DecorationEngine engine widget a => engine widget a -> DrawData engine widget -> widget -> X WidgetPlace

-- | Place widgets along the decoration bar.
placeWidgets :: (DecorationEngine engine widget a, Shrinker shrinker) => engine widget a -> Theme engine widget -> shrinker -> DecorationEngineState engine -> Rectangle -> Window -> WidgetLayout widget -> X (WidgetLayout WidgetPlace)

-- | Shrink window title so that it would fit in decoration.
getShrinkedWindowName :: (DecorationEngine engine widget a, Shrinker shrinker) => engine widget a -> shrinker -> DecorationEngineState engine -> String -> Dimension -> Dimension -> X String

-- | Shrink window title so that it would fit in decoration.
getShrinkedWindowName :: (DecorationEngine engine widget a, Shrinker shrinker, DecorationEngineState engine ~ XMonadFont) => engine widget a -> shrinker -> DecorationEngineState engine -> String -> Dimension -> Dimension -> X String

-- | Mask of X11 events on which the decoration engine should do something.
--   <tt>exposureMask</tt> should be included here so that decoration
--   engine could repaint decorations when they are shown on screen.
--   <tt>buttonPressMask</tt> should be included so that decoration engine
--   could response to mouse clicks. Other events can be added to custom
--   implementations of DecorationEngine.
decorationXEventMask :: DecorationEngine engine widget a => engine widget a -> EventMask

-- | List of X11 window property atoms of original (client) windows, change
--   of which should trigger repainting of decoration. For example, if
--   <tt>WM_NAME</tt> changes it means that we have to redraw window title.
propsToRepaintDecoration :: DecorationEngine engine widget a => engine widget a -> X [Atom]

-- | Generic event handler, which recieves X11 events on decoration window.
--   Default implementation handles mouse clicks and drags.
decorationEventHookEx :: (DecorationEngine engine widget a, Shrinker shrinker) => engine widget a -> Theme engine widget -> DecorationLayoutState engine -> shrinker -> Event -> X ()

-- | Event handler for clicks on decoration window. This is called from
--   default implementation of "decorationEventHookEx". This should return
--   True, if the click was handled (something happened because of that
--   click). If this returns False, the click can be considered as a
--   beginning of mouse drag.
handleDecorationClick :: DecorationEngine engine widget a => engine widget a -> Theme engine widget -> Rectangle -> [Rectangle] -> Window -> Int -> Int -> Int -> X Bool

-- | Event handler which is called during mouse dragging. This is called
--   from default implementation of "decorationEventHookEx".
decorationWhileDraggingHook :: DecorationEngine engine widget a => engine widget a -> CInt -> CInt -> (Window, Rectangle) -> Position -> Position -> X ()

-- | This hoook is called after a window has been dragged using the
--   decoration. This is called from default implementation of
--   "decorationEventHookEx".
decorationAfterDraggingHook :: DecorationEngine engine widget a => engine widget a -> (Window, Rectangle) -> Window -> X ()

-- | Draw everything required on the decoration window. This method should
--   draw background (flat or gradient or whatever), borders, and call
--   <tt>paintWidget</tt> method to draw window widgets (buttons and
--   title).
paintDecoration :: (DecorationEngine engine widget a, Shrinker shrinker) => engine widget a -> a -> Dimension -> Dimension -> shrinker -> DrawData engine widget -> Bool -> X ()

-- | Paint one widget on the decoration window.
paintWidget :: (DecorationEngine engine widget a, Shrinker shrinker) => engine widget a -> DecorationPaintingContext engine -> WidgetPlace -> shrinker -> DrawData engine widget -> widget -> Bool -> X ()

-- | Auxiliary type for data which are passed from decoration layout
--   modifier to decoration engine.
data DrawData engine widget
DrawData :: !DecorationEngineState engine -> !Style (Theme engine widget) -> !Window -> !String -> !Rectangle -> !WidgetLayout widget -> !WidgetLayout WidgetPlace -> DrawData engine widget

-- | Decoration engine state
[ddEngineState] :: DrawData engine widget -> !DecorationEngineState engine

-- | Graphics style of the decoration. This defines colors, fonts etc which
--   are to be used for this particular window in it's current state.
[ddStyle] :: DrawData engine widget -> !Style (Theme engine widget)

-- | Original window to be decorated
[ddOrigWindow] :: DrawData engine widget -> !Window

-- | Original window title (not shrinked yet)
[ddWindowTitle] :: DrawData engine widget -> !String

-- | Decoration rectangle
[ddDecoRect] :: DrawData engine widget -> !Rectangle

-- | Widgets to be placed on decoration
[ddWidgets] :: DrawData engine widget -> !WidgetLayout widget

-- | Places where widgets must be shown
[ddWidgetPlaces] :: DrawData engine widget -> !WidgetLayout WidgetPlace

-- | State of decoration engine
data DecorationLayoutState engine
DecorationLayoutState :: !DecorationEngineState engine -> ![WindowDecoration] -> DecorationLayoutState engine

-- | Engine-specific state
[dsStyleState] :: DecorationLayoutState engine -> !DecorationEngineState engine

-- | Mapping between decoration windows and original windows
[dsDecorations] :: DecorationLayoutState engine -> ![WindowDecoration]
class (Read s, Show s) => Shrinker s
shrinkIt :: Shrinker s => s -> String -> [String]
shrinkText :: DefaultShrinker

-- | Build an instance of <a>DrawData</a> type.
mkDrawData :: (DecorationEngine engine widget a, ThemeAttributes (Theme engine widget), HasWidgets (Theme engine) widget) => engine widget a -> Theme engine widget -> DecorationEngineState engine -> Window -> Rectangle -> X (DrawData engine widget)

-- | Simple implementation of <tt>paintDecoration</tt> method. This is used
--   by <tt>TextEngine</tt> and can be re-used by other decoration engines.
paintDecorationSimple :: forall engine shrinker widget. (DecorationEngine engine widget Window, DecorationPaintingContext engine ~ XPaintingContext, Shrinker shrinker, Style (Theme engine widget) ~ SimpleStyle) => engine widget Window -> Window -> Dimension -> Dimension -> shrinker -> DrawData engine widget -> Bool -> X ()


-- | This module contains data types and utilities to deal with decoration
--   widgets. A widget is anything that is displayed on window decoration,
--   and, optionally, can react on clicks. Examples of widgets are usual
--   window buttons (minimize, maximize, close), window icon and window
--   title.
module XMonad.Layout.DecorationEx.Widgets

-- | Standard window commands.
--   
--   One can extend this list by simply doing
--   
--   <pre>
--   data MyWindowCommand =
--       Std StandardCommand
--     | SomeFancyCommand
--   </pre>
--   
--   <pre>
--   instance WindowCommand MyWindowCommand where ...
--   </pre>
--   
--   <pre>
--   type MyWidget = GenericWidget MyWindowCommand
--   </pre>
data StandardCommand

-- | Focus the window
FocusWindow :: StandardCommand

-- | Move focus to previous window
FocusUp :: StandardCommand

-- | Move focus to following window
FocusDown :: StandardCommand

-- | Move the window to the next group (see <a>XMonad.Layout.Groups</a>)
MoveToNextGroup :: StandardCommand

-- | Move the window to the previous group
MoveToPrevGroup :: StandardCommand

-- | Execute <tt>dwmpromote</tt> (see <a>XMonad.Actions.DwmPromote</a>)
DwmPromote :: StandardCommand

-- | Make window sticky or unstick it (see
--   <a>XMonad.Actions.CopyWindow</a>)
ToggleSticky :: StandardCommand

-- | Maximize or restore window (see <a>XMonad.Layout.Maximize</a>)
ToggleMaximize :: StandardCommand

-- | Minimize window (see <a>XMonad.Actions.Minimize</a>)
Minimize :: StandardCommand

-- | Close the window
CloseWindow :: StandardCommand

-- | Show window menu via <a>XMonad.Actions.GridSelect</a> (see
--   <a>XMonad.Actions.WindowMenu</a>)
GridWindowMenu :: StandardCommand

-- | Type class for widgets that can be displayed as text fragments by
--   <tt>TextDecoration</tt> engine.
class DecorationWidget widget => TextWidget widget
widgetString :: TextWidget widget => DrawData engine widget -> widget -> X String

-- | Generic data type for decoration widgets.
data GenericWidget cmd

-- | Window title (just text label)
TitleWidget :: GenericWidget cmd

-- | Window icon with some associated command | Other widgets
WindowIcon :: !cmd -> GenericWidget cmd

-- | Window command
[swCommand] :: GenericWidget cmd -> !cmd
GenericWidget :: !String -> !String -> !cmd -> GenericWidget cmd

-- | Text for checked widget state
[swCheckedText] :: GenericWidget cmd -> !String

-- | Text for unchecked widget state
[swUncheckedText] :: GenericWidget cmd -> !String

-- | Window command
[swCommand] :: GenericWidget cmd -> !cmd

-- | Generic widget type specialized for <a>StandardCommand</a>
type StandardWidget = GenericWidget StandardCommand

-- | Check if the widget should be displayed in <tt>checked</tt> state.
isWidgetChecked :: DecorationWidget widget => widget -> Window -> X Bool

-- | Widget for window title
titleW :: StandardWidget

-- | Widget for ToggleSticky command.
toggleStickyW :: StandardWidget

-- | Widget for Minimize command
minimizeW :: StandardWidget

-- | Widget for ToggleMaximize command
maximizeW :: StandardWidget

-- | Widget for CloseWindow command
closeW :: StandardWidget
dwmpromoteW :: StandardWidget
moveToNextGroupW :: StandardWidget
moveToPrevGroupW :: StandardWidget
instance GHC.Read.Read XMonad.Layout.DecorationEx.Widgets.StandardCommand
instance GHC.Show.Show XMonad.Layout.DecorationEx.Widgets.StandardCommand
instance GHC.Classes.Eq XMonad.Layout.DecorationEx.Widgets.StandardCommand
instance GHC.Read.Read cmd => GHC.Read.Read (XMonad.Layout.DecorationEx.Widgets.GenericWidget cmd)
instance GHC.Show.Show cmd => GHC.Show.Show (XMonad.Layout.DecorationEx.Widgets.GenericWidget cmd)
instance XMonad.Layout.DecorationEx.Widgets.TextWidget XMonad.Layout.DecorationEx.Widgets.StandardWidget
instance (Data.Default.Class.Default cmd, GHC.Read.Read cmd, GHC.Show.Show cmd, XMonad.Layout.DecorationEx.Common.WindowCommand cmd) => XMonad.Layout.DecorationEx.Common.DecorationWidget (XMonad.Layout.DecorationEx.Widgets.GenericWidget cmd)
instance Data.Default.Class.Default XMonad.Layout.DecorationEx.Widgets.StandardCommand
instance XMonad.Layout.DecorationEx.Common.WindowCommand XMonad.Layout.DecorationEx.Widgets.StandardCommand


-- | Layout modifier, which is responsible for creation of decoration
--   rectangles (windows), updating and removing them when needed. It is
--   parameterized by <tt>DecorationGeometry</tt>, which says where
--   decorations should be placed, and by <tt>DecorationEngine</tt>, which
--   says how decorations should look.
module XMonad.Layout.DecorationEx.LayoutModifier

-- | Apply a DecorationEx modifier to an underlying layout
decorationEx :: (DecorationEngine engine widget a, DecorationGeometry geom a, Shrinker shrinker) => shrinker -> Theme engine widget -> engine widget a -> geom a -> l a -> ModifiedLayout (DecorationEx engine widget geom shrinker) l a

-- | The <a>DecorationEx</a> <a>LayoutModifier</a>. This data type is an
--   instance of the <a>LayoutModifier</a> class. This data type will be
--   passed, together with a layout, to the <a>ModifiedLayout</a> type
--   constructor to modify the layout by adding decorations according to a
--   <a>DecorationEngine</a>.
data DecorationEx engine widget geom shrinker a
instance (GHC.Show.Show (XMonad.Layout.DecorationEx.Engine.Theme engine widget), GHC.Show.Show shrinker, GHC.Show.Show (engine widget a), GHC.Show.Show (geom a)) => GHC.Show.Show (XMonad.Layout.DecorationEx.LayoutModifier.DecorationEx engine widget geom shrinker a)
instance (GHC.Read.Read (XMonad.Layout.DecorationEx.Engine.Theme engine widget), GHC.Read.Read shrinker, GHC.Read.Read (engine widget a), GHC.Read.Read (geom a)) => GHC.Read.Read (XMonad.Layout.DecorationEx.LayoutModifier.DecorationEx engine widget geom shrinker a)
instance (XMonad.Layout.DecorationEx.Engine.DecorationEngine engine widget Graphics.X11.Types.Window, XMonad.Layout.DecorationEx.Geometry.DecorationGeometry geom Graphics.X11.Types.Window, XMonad.Layout.Decoration.Shrinker shrinker) => XMonad.Layout.LayoutModifier.LayoutModifier (XMonad.Layout.DecorationEx.LayoutModifier.DecorationEx engine widget geom shrinker) Graphics.X11.Types.Window


-- | Window decoration engine, that uses text fragments (like
--   <tt>"[X]"</tt>) to indicate widgets (window buttons).
module XMonad.Layout.DecorationEx.TextEngine

-- | Add decoration to existing layout. Widgets are indicated by text
--   fragments, like <tt>"[+]"</tt>. Geometry is simple: a horizontal panel
--   at the top of each window, going for the full width of the window.
textDecoration :: Shrinker shrinker => shrinker -> Theme TextDecoration StandardWidget -> l Window -> ModifiedLayout (DecorationEx TextDecoration StandardWidget DefaultGeometry shrinker) l Window

-- | Decoration engine data type
data TextDecoration widget a
TextDecoration :: TextDecoration widget a
instance GHC.Read.Read (XMonad.Layout.DecorationEx.TextEngine.TextDecoration widget a)
instance GHC.Show.Show (XMonad.Layout.DecorationEx.TextEngine.TextDecoration widget a)
instance (XMonad.Layout.DecorationEx.Widgets.TextWidget widget, XMonad.Layout.DecorationEx.Common.ClickHandler (XMonad.Layout.DecorationEx.Common.GenericTheme XMonad.Layout.DecorationEx.Common.SimpleStyle) widget) => XMonad.Layout.DecorationEx.Engine.DecorationEngine XMonad.Layout.DecorationEx.TextEngine.TextDecoration widget Graphics.X11.Types.Window


-- | This module defines window decoration geometry based on tabs. The tabs
--   can follow horizontally and be placed above or below windows; in such
--   case, tabs can occupy full width of the window or be aligned to left
--   or right. Or tabs can go vertically near left or right side of the
--   window.
module XMonad.Layout.DecorationEx.TabbedGeometry

-- | Add tabbed decorations (with default settings) with text-based widgets
--   to a layout.
textTabbed :: Shrinker shrinker => shrinker -> ThemeEx StandardWidget -> l Window -> ModifiedLayout (DecorationEx TextDecoration StandardWidget TabbedGeometry shrinker) l Window
data TabbedGeometry a
HorizontalTabs :: !SingleTabMode -> !HorizontalTabPlacement -> !HorizontalTabsAlignment -> !HorizontalTabWidth -> !Dimension -> TabbedGeometry a

-- | What to do if there is only one tab
[showIfSingleWindow] :: TabbedGeometry a -> !SingleTabMode

-- | Where to place horizontal tabs
[hTabPlacement] :: TabbedGeometry a -> !HorizontalTabPlacement

-- | How to align horizontal tabs (makes sense with fixed width of tabs).
[hTabAlignment] :: TabbedGeometry a -> !HorizontalTabsAlignment

-- | Width of horizontal tabs
[hTabWidth] :: TabbedGeometry a -> !HorizontalTabWidth

-- | Height of horizontal tabs
[hTabHeight] :: TabbedGeometry a -> !Dimension
VerticalTabs :: !SingleTabMode -> !VerticalTabPlacement -> !Dimension -> !Dimension -> TabbedGeometry a

-- | What to do if there is only one tab
[showIfSingleWindow] :: TabbedGeometry a -> !SingleTabMode

-- | Where to place vertical tabs
[vTabPlacement] :: TabbedGeometry a -> !VerticalTabPlacement

-- | Width of vertical tabs
[vTabWidth] :: TabbedGeometry a -> !Dimension

-- | Height of vertical tabs
[vTabHeight] :: TabbedGeometry a -> !Dimension

-- | Placement of tabs when they go horizontally: should they be placed
--   above or below the window.
data HorizontalTabPlacement
Top :: HorizontalTabPlacement
Bottom :: HorizontalTabPlacement

-- | Placement of tabs when they go vertically: should they appear at left
--   or at right side of the window.
data VerticalTabPlacement
TabsAtLeft :: VerticalTabPlacement
TabsAtRight :: VerticalTabPlacement

-- | Width of tabs when they go horizontally.
data HorizontalTabWidth

-- | Define the width automatically by evenly dividing windows' width
AutoWidth :: HorizontalTabWidth

-- | Use fixed width of the tab
FixedWidth :: !Dimension -> HorizontalTabWidth

-- | Alignment of tabs when they go horizontally.
data HorizontalTabsAlignment
AlignTabsLeft :: HorizontalTabsAlignment
AlignTabsCenter :: HorizontalTabsAlignment
AlignTabsRight :: HorizontalTabsAlignment

-- | What to do if there is only one tab.
data SingleTabMode
ShowTab :: SingleTabMode
HideTab :: SingleTabMode
instance GHC.Show.Show XMonad.Layout.DecorationEx.TabbedGeometry.HorizontalTabPlacement
instance GHC.Read.Read XMonad.Layout.DecorationEx.TabbedGeometry.HorizontalTabPlacement
instance GHC.Classes.Eq XMonad.Layout.DecorationEx.TabbedGeometry.HorizontalTabPlacement
instance GHC.Show.Show XMonad.Layout.DecorationEx.TabbedGeometry.VerticalTabPlacement
instance GHC.Read.Read XMonad.Layout.DecorationEx.TabbedGeometry.VerticalTabPlacement
instance GHC.Classes.Eq XMonad.Layout.DecorationEx.TabbedGeometry.VerticalTabPlacement
instance GHC.Show.Show XMonad.Layout.DecorationEx.TabbedGeometry.HorizontalTabWidth
instance GHC.Read.Read XMonad.Layout.DecorationEx.TabbedGeometry.HorizontalTabWidth
instance GHC.Classes.Eq XMonad.Layout.DecorationEx.TabbedGeometry.HorizontalTabWidth
instance GHC.Show.Show XMonad.Layout.DecorationEx.TabbedGeometry.HorizontalTabsAlignment
instance GHC.Read.Read XMonad.Layout.DecorationEx.TabbedGeometry.HorizontalTabsAlignment
instance GHC.Classes.Eq XMonad.Layout.DecorationEx.TabbedGeometry.HorizontalTabsAlignment
instance GHC.Show.Show XMonad.Layout.DecorationEx.TabbedGeometry.SingleTabMode
instance GHC.Read.Read XMonad.Layout.DecorationEx.TabbedGeometry.SingleTabMode
instance GHC.Classes.Eq XMonad.Layout.DecorationEx.TabbedGeometry.SingleTabMode
instance GHC.Read.Read (XMonad.Layout.DecorationEx.TabbedGeometry.TabbedGeometry a)
instance GHC.Show.Show (XMonad.Layout.DecorationEx.TabbedGeometry.TabbedGeometry a)
instance Data.Default.Class.Default (XMonad.Layout.DecorationEx.TabbedGeometry.TabbedGeometry a)
instance XMonad.Layout.DecorationEx.Geometry.DecorationGeometry XMonad.Layout.DecorationEx.TabbedGeometry.TabbedGeometry Graphics.X11.Types.Window


-- | This defines window decorations which are shown as a bar of fixed
--   width on top of window.
module XMonad.Layout.DecorationEx.DwmGeometry

-- | Decoration geometry data type
data DwmGeometry a
DwmGeometry :: !Bool -> !Rational -> !Dimension -> !Dimension -> DwmGeometry a

-- | Whether to show decorations on focused windows
[dwmShowForFocused] :: DwmGeometry a -> !Bool

-- | Horizontal position of decoration rectangle. 0 means place it at left
--   corner, 1 - place it at right corner, <tt>1%2</tt> - place it at
--   center.
[dwmHorizontalPosition] :: DwmGeometry a -> !Rational

-- | Height of decoration rectangle
[dwmDecoHeight] :: DwmGeometry a -> !Dimension

-- | Width of decoration rectangle
[dwmDecoWidth] :: DwmGeometry a -> !Dimension

-- | Add a decoration to window layout. Widgets are indicated with text
--   fragments using TextDecoration; decoration placement is similar to
--   DWM.
dwmStyleDeco :: Shrinker shrinker => shrinker -> ThemeEx StandardWidget -> l Window -> ModifiedLayout (DecorationEx TextDecoration StandardWidget DwmGeometry shrinker) l Window

-- | Add a decoration to window layout. Widgets are indicated with text
--   fragments using TextDecoration; decoration placement can be adjusted.
dwmStyleDecoEx :: Shrinker shrinker => shrinker -> DwmGeometry Window -> ThemeEx StandardWidget -> l Window -> ModifiedLayout (DecorationEx TextDecoration StandardWidget DwmGeometry shrinker) l Window
instance GHC.Read.Read (XMonad.Layout.DecorationEx.DwmGeometry.DwmGeometry a)
instance GHC.Show.Show (XMonad.Layout.DecorationEx.DwmGeometry.DwmGeometry a)
instance Data.Default.Class.Default (XMonad.Layout.DecorationEx.DwmGeometry.DwmGeometry a)
instance XMonad.Layout.DecorationEx.Geometry.DecorationGeometry XMonad.Layout.DecorationEx.DwmGeometry.DwmGeometry Graphics.X11.Types.Window


-- | This set of modules contains a set of type classes and their
--   implementations which define a flexible and extensible mechanism of
--   window decorations.
--   
--   Click <a>here</a> for a larger version.
--   
--   Within this mechanism, there are the following entities which define
--   how decorations will look and work:
--   
--   <ul>
--   <li>Main object is <tt>DecorationEx</tt> layout modifier. It is from
--   where everything starts. It creates, shows and hides decoration
--   windows (rectangles) when needed. It is parameterized with decoration
--   geometry, decoration engine and theme. It calls these components to do
--   their parts of the work.</li>
--   <li><tt>DecorationGeometry</tt> defines where decoration rectangles
--   should be placed. For example, standard horizontal bar above each
--   window; or tab bar.</li>
--   <li><tt>DecorationEngine</tt> defines how decorations look and how
--   they react on clicks. Different implementations of the decoration
--   engine can use different APIs to draw decorations. Within this
--   package, there is one implementation (<tt>TextDecoration</tt>), which
--   uses plain Xlib calls, and displays decoration widgets with text
--   fragments, like <tt>[X]</tt> or <tt>[_]</tt>. Other engines can, for
--   example, use the Cairo library to draw nice gradients and image-based
--   widgets.</li>
--   <li>A Decoration widget is an element placed on a window decoration.
--   It defines how it looks and how it responds to clicks. Examples
--   include usual window buttons (minimize, maximize, close), window icon,
--   window title.</li>
--   <li>A Decoration theme defines colors and fonts for the decoration
--   engine. It also contains a list of decoration widgets and says where
--   to place them (at the left, at the right or in the center).</li>
--   </ul>
--   
--   This mechanism makes major use of parameterized data types and type
--   families, in order to make it possible to define different types of
--   decorations, and easily combine different aspects of decorations. For
--   example, each decoration engine can be combined with each decoration
--   geometry.
module XMonad.Layout.DecorationEx

-- | Apply a DecorationEx modifier to an underlying layout
decorationEx :: (DecorationEngine engine widget a, DecorationGeometry geom a, Shrinker shrinker) => shrinker -> Theme engine widget -> engine widget a -> geom a -> l a -> ModifiedLayout (DecorationEx engine widget geom shrinker) l a

-- | Add decoration to existing layout. Widgets are indicated by text
--   fragments, like <tt>"[+]"</tt>. Geometry is simple: a horizontal panel
--   at the top of each window, going for the full width of the window.
textDecoration :: Shrinker shrinker => shrinker -> Theme TextDecoration StandardWidget -> l Window -> ModifiedLayout (DecorationEx TextDecoration StandardWidget DefaultGeometry shrinker) l Window

-- | Add tabbed decorations (with default settings) with text-based widgets
--   to a layout.
textTabbed :: Shrinker shrinker => shrinker -> ThemeEx StandardWidget -> l Window -> ModifiedLayout (DecorationEx TextDecoration StandardWidget TabbedGeometry shrinker) l Window

-- | Add a decoration to window layout. Widgets are indicated with text
--   fragments using TextDecoration; decoration placement is similar to
--   DWM.
dwmStyleDeco :: Shrinker shrinker => shrinker -> ThemeEx StandardWidget -> l Window -> ModifiedLayout (DecorationEx TextDecoration StandardWidget DwmGeometry shrinker) l Window

-- | Decoration engine data type
data TextDecoration widget a
TextDecoration :: TextDecoration widget a

-- | Data type for default implementation of <a>DecorationGeometry</a>.
--   This defines simple decorations: a horizontal bar at the top of each
--   window, running for full width of the window.
newtype DefaultGeometry a
DefaultGeometry :: Dimension -> DefaultGeometry a
[gDecorationHeight] :: DefaultGeometry a -> Dimension
data TabbedGeometry a
HorizontalTabs :: !SingleTabMode -> !HorizontalTabPlacement -> !HorizontalTabsAlignment -> !HorizontalTabWidth -> !Dimension -> TabbedGeometry a

-- | What to do if there is only one tab
[showIfSingleWindow] :: TabbedGeometry a -> !SingleTabMode

-- | Where to place horizontal tabs
[hTabPlacement] :: TabbedGeometry a -> !HorizontalTabPlacement

-- | How to align horizontal tabs (makes sense with fixed width of tabs).
[hTabAlignment] :: TabbedGeometry a -> !HorizontalTabsAlignment

-- | Width of horizontal tabs
[hTabWidth] :: TabbedGeometry a -> !HorizontalTabWidth

-- | Height of horizontal tabs
[hTabHeight] :: TabbedGeometry a -> !Dimension
VerticalTabs :: !SingleTabMode -> !VerticalTabPlacement -> !Dimension -> !Dimension -> TabbedGeometry a

-- | What to do if there is only one tab
[showIfSingleWindow] :: TabbedGeometry a -> !SingleTabMode

-- | Where to place vertical tabs
[vTabPlacement] :: TabbedGeometry a -> !VerticalTabPlacement

-- | Width of vertical tabs
[vTabWidth] :: TabbedGeometry a -> !Dimension

-- | Height of vertical tabs
[vTabHeight] :: TabbedGeometry a -> !Dimension

-- | Decoration geometry data type
data DwmGeometry a
DwmGeometry :: !Bool -> !Rational -> !Dimension -> !Dimension -> DwmGeometry a

-- | Whether to show decorations on focused windows
[dwmShowForFocused] :: DwmGeometry a -> !Bool

-- | Horizontal position of decoration rectangle. 0 means place it at left
--   corner, 1 - place it at right corner, <tt>1%2</tt> - place it at
--   center.
[dwmHorizontalPosition] :: DwmGeometry a -> !Rational

-- | Height of decoration rectangle
[dwmDecoHeight] :: DwmGeometry a -> !Dimension

-- | Width of decoration rectangle
[dwmDecoWidth] :: DwmGeometry a -> !Dimension

-- | The <a>DecorationEx</a> <a>LayoutModifier</a>. This data type is an
--   instance of the <a>LayoutModifier</a> class. This data type will be
--   passed, together with a layout, to the <a>ModifiedLayout</a> type
--   constructor to modify the layout by adding decorations according to a
--   <a>DecorationEngine</a>.
data DecorationEx engine widget geom shrinker a

-- | Generic data type which is used to describe characteristics of
--   rectangle borders.
data BoxBorders a
BoxBorders :: !a -> !a -> !a -> !a -> BoxBorders a
[bxTop] :: BoxBorders a -> !a
[bxRight] :: BoxBorders a -> !a
[bxBottom] :: BoxBorders a -> !a
[bxLeft] :: BoxBorders a -> !a

-- | Convinience data type describing colors of decoration rectangle
--   borders.
type BorderColors = BoxBorders String

-- | Data type describing look of window decoration in particular state
--   (active or inactive)
data SimpleStyle
SimpleStyle :: !String -> !String -> !String -> !Dimension -> !BorderColors -> SimpleStyle

-- | Decoration background color
[sBgColor] :: SimpleStyle -> !String

-- | Text (foreground) color
[sTextColor] :: SimpleStyle -> !String

-- | Text background color
[sTextBgColor] :: SimpleStyle -> !String

-- | Width of border of decoration rectangle. Set to 0 to disable the
--   border.
[sDecoBorderWidth] :: SimpleStyle -> !Dimension

-- | Colors of borders of decoration rectangle.
[sDecorationBorders] :: SimpleStyle -> !BorderColors

-- | Generic Theme data type. This is used by <tt>TextEngine</tt> and can
--   be used by other relatively simple decoration engines.
data GenericTheme style widget
GenericTheme :: !style -> !style -> !style -> !BoxBorders Dimension -> !String -> !Map Int (WidgetCommand widget) -> ![Int] -> ![widget] -> ![widget] -> ![widget] -> GenericTheme style widget

-- | Decoration style for active (focused) windows
[exActive] :: GenericTheme style widget -> !style

-- | Decoration style for inactive (unfocused) windows
[exInactive] :: GenericTheme style widget -> !style

-- | Decoration style for urgent windows
[exUrgent] :: GenericTheme style widget -> !style

-- | Padding between decoration rectangle and widgets
[exPadding] :: GenericTheme style widget -> !BoxBorders Dimension

-- | Font name
[exFontName] :: GenericTheme style widget -> !String

-- | Correspondence between mouse button number and window command.
[exOnDecoClick] :: GenericTheme style widget -> !Map Int (WidgetCommand widget)

-- | For which mouse buttons dragging is enabled
[exDragWindowButtons] :: GenericTheme style widget -> ![Int]

-- | Widgets that should appear at the left of decoration rectangle (listed
--   left to right)
[exWidgetsLeft] :: GenericTheme style widget -> ![widget]

-- | Widgets that should appear in the center of decoration rectangle
--   (listed left to right)
[exWidgetsCenter] :: GenericTheme style widget -> ![widget]

-- | Widgets that should appear at the right of decoration rectangle
--   (listed left to right)
[exWidgetsRight] :: GenericTheme style widget -> ![widget]

-- | Convience type for themes used by <tt>TextDecoration</tt>.
type ThemeEx widget = GenericTheme SimpleStyle widget

-- | Standard window commands.
--   
--   One can extend this list by simply doing
--   
--   <pre>
--   data MyWindowCommand =
--       Std StandardCommand
--     | SomeFancyCommand
--   </pre>
--   
--   <pre>
--   instance WindowCommand MyWindowCommand where ...
--   </pre>
--   
--   <pre>
--   type MyWidget = GenericWidget MyWindowCommand
--   </pre>
data StandardCommand

-- | Focus the window
FocusWindow :: StandardCommand

-- | Move focus to previous window
FocusUp :: StandardCommand

-- | Move focus to following window
FocusDown :: StandardCommand

-- | Move the window to the next group (see <a>XMonad.Layout.Groups</a>)
MoveToNextGroup :: StandardCommand

-- | Move the window to the previous group
MoveToPrevGroup :: StandardCommand

-- | Execute <tt>dwmpromote</tt> (see <a>XMonad.Actions.DwmPromote</a>)
DwmPromote :: StandardCommand

-- | Make window sticky or unstick it (see
--   <a>XMonad.Actions.CopyWindow</a>)
ToggleSticky :: StandardCommand

-- | Maximize or restore window (see <a>XMonad.Layout.Maximize</a>)
ToggleMaximize :: StandardCommand

-- | Minimize window (see <a>XMonad.Actions.Minimize</a>)
Minimize :: StandardCommand

-- | Close the window
CloseWindow :: StandardCommand

-- | Show window menu via <a>XMonad.Actions.GridSelect</a> (see
--   <a>XMonad.Actions.WindowMenu</a>)
GridWindowMenu :: StandardCommand

-- | Generic data type for decoration widgets.
data GenericWidget cmd

-- | Window title (just text label)
TitleWidget :: GenericWidget cmd

-- | Window icon with some associated command | Other widgets
WindowIcon :: !cmd -> GenericWidget cmd

-- | Window command
[swCommand] :: GenericWidget cmd -> !cmd
GenericWidget :: !String -> !String -> !cmd -> GenericWidget cmd

-- | Text for checked widget state
[swCheckedText] :: GenericWidget cmd -> !String

-- | Text for unchecked widget state
[swUncheckedText] :: GenericWidget cmd -> !String

-- | Window command
[swCommand] :: GenericWidget cmd -> !cmd

-- | Generic widget type specialized for <a>StandardCommand</a>
type StandardWidget = GenericWidget StandardCommand

-- | Convert Theme type from <a>XMonad.Layout.Decoration</a> to theme type
--   used by <a>XMonad.Layout.DecorationEx.TextEngine</a>.
themeEx :: Default (WidgetCommand widget) => Theme -> ThemeEx widget
borderColor :: String -> BorderColors
shadowBorder :: String -> String -> BorderColors
class (Read s, Show s) => Shrinker s
shrinkIt :: Shrinker s => s -> String -> [String]
shrinkText :: DefaultShrinker

-- | Widget for window title
titleW :: StandardWidget

-- | Widget for ToggleSticky command.
toggleStickyW :: StandardWidget

-- | Widget for Minimize command
minimizeW :: StandardWidget

-- | Widget for ToggleMaximize command
maximizeW :: StandardWidget

-- | Widget for CloseWindow command
closeW :: StandardWidget
dwmpromoteW :: StandardWidget
moveToNextGroupW :: StandardWidget
moveToPrevGroupW :: StandardWidget


-- | A decoration that includes small buttons on both ends which invoke
--   various actions when clicked on: Show a window menu (see
--   <a>XMonad.Actions.WindowMenu</a>), minimize, maximize or close the
--   window.
--   
--   Note: For maximizing and minimizing to actually work, you will need to
--   integrate <a>XMonad.Layout.Maximize</a> and
--   <a>XMonad.Layout.Minimize</a> into your setup. See the documentation
--   of those modules for more information.
module XMonad.Layout.ButtonDecoration
buttonDeco :: (Eq a, Shrinker s) => s -> Theme -> l a -> ModifiedLayout (Decoration ButtonDecoration s) l a
data ButtonDecoration a
instance GHC.Read.Read (XMonad.Layout.ButtonDecoration.ButtonDecoration a)
instance GHC.Show.Show (XMonad.Layout.ButtonDecoration.ButtonDecoration a)
instance GHC.Classes.Eq a => XMonad.Layout.Decoration.DecorationStyle XMonad.Layout.ButtonDecoration.ButtonDecoration a


-- | This layout modifier will allow to resize windows by dragging their
--   borders with the mouse. However, it only works in layouts or modified
--   layouts that react to the <a>SetGeometry</a> message.
--   <a>XMonad.Layout.WindowArranger</a> can be used to create such a
--   setup, but it is probably must useful in a floating layout such as
--   <a>XMonad.Layout.PositionStoreFloat</a> with which it has been mainly
--   tested. See the documentation of PositionStoreFloat for a typical
--   usage example.
module XMonad.Layout.BorderResize
borderResize :: l a -> ModifiedLayout BorderResize l a

-- | Like <a>borderResize</a>, but takes the number of pixels near the
--   border up to which dragging still resizes a window.
borderResizeNear :: Dimension -> l a -> ModifiedLayout BorderResize l a
data BorderResize a
BR :: !Dimension -> !Map Window RectWithBorders -> BorderResize a

-- | Still resize when this number of pixels around the border.
[brBorderSize] :: BorderResize a -> !Dimension
[brWrsLastTime] :: BorderResize a -> !Map Window RectWithBorders
type RectWithBorders = (Rectangle, [BorderInfo])
data BorderInfo
instance GHC.Classes.Eq XMonad.Layout.BorderResize.BorderType
instance GHC.Read.Read XMonad.Layout.BorderResize.BorderType
instance GHC.Show.Show XMonad.Layout.BorderResize.BorderType
instance GHC.Read.Read XMonad.Layout.BorderResize.BorderInfo
instance GHC.Show.Show XMonad.Layout.BorderResize.BorderInfo
instance GHC.Read.Read (XMonad.Layout.BorderResize.BorderResize a)
instance GHC.Show.Show (XMonad.Layout.BorderResize.BorderResize a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Layout.BorderResize.BorderResize Graphics.X11.Types.Window


-- | This is the default configuration of Bluetile
--   (<a>http://projects.haskell.org/bluetile/</a>). If you are migrating
--   from Bluetile to xmonad or want to create a similar setup, then this
--   will give you pretty much the same thing, except for Bluetile's helper
--   applications such as the dock.
module XMonad.Config.Bluetile
bluetileConfig :: XConfig (ModifiedLayout AvoidStruts (ModifiedLayout Minimize (ModifiedLayout BoringWindows (Choose (ModifiedLayout Rename (ModifiedLayout (Decoration ButtonDecoration DefaultShrinker) (ModifiedLayout Maximize (ModifiedLayout BorderResize PositionStoreFloat)))) (Choose (ModifiedLayout Rename (ModifiedLayout (Decoration WindowSwitcherDecoration DefaultShrinker) (ModifiedLayout DraggingVisualizer (ModifiedLayout Maximize MouseResizableTile)))) (Choose (ModifiedLayout Rename (ModifiedLayout (Decoration WindowSwitcherDecoration DefaultShrinker) (ModifiedLayout DraggingVisualizer (ModifiedLayout Maximize MouseResizableTile)))) (ModifiedLayout Rename (ModifiedLayout (Decoration WindowSwitcherDecoration DefaultShrinker) (ModifiedLayout DraggingVisualizer (ModifiedLayout Maximize (ModifiedLayout SmartBorder Full)))))))))))


-- | Layout where new windows will split the focused window in half, based
--   off of BSPWM
module XMonad.Layout.BinarySpacePartition

-- | an empty BinarySpacePartition to use as a default for adding windows
--   to.
emptyBSP :: BinarySpacePartition a
data BinarySpacePartition a

-- | Message for rotating a split (horizontal/vertical) in the BSP
data Rotate
Rotate :: Rotate

-- | Message for swapping the left child of a split with the right child of
--   split
data Swap
Swap :: Swap

-- | Message for resizing one of the cells in the BSP
data ResizeDirectional
ExpandTowardsBy :: Direction2D -> Rational -> ResizeDirectional
ShrinkFromBy :: Direction2D -> Rational -> ResizeDirectional
MoveSplitBy :: Direction2D -> Rational -> ResizeDirectional

-- | <tt>ExpandTowards x</tt> is now the equivalent of <tt>ExpandTowardsBy
--   x 0.05</tt>
pattern ExpandTowards :: Direction2D -> ResizeDirectional

-- | <tt>ShrinkFrom x</tt> is now the equivalent of <tt>ShrinkFromBy x
--   0.05</tt>
pattern ShrinkFrom :: Direction2D -> ResizeDirectional

-- | <tt>MoveSplit x</tt> is now the equivalent of <tt>MoveSplitBy x
--   0.05</tt>
pattern MoveSplit :: Direction2D -> ResizeDirectional

-- | Message for rotating the binary tree around the parent node of the
--   window to the left or right
data TreeRotate
RotateL :: TreeRotate
RotateR :: TreeRotate

-- | Message to balance the tree in some way (Balance retiles the windows,
--   Equalize changes ratios)
data TreeBalance
Balance :: TreeBalance
Equalize :: TreeBalance

-- | Message to cyclically select the parent node instead of the leaf
data FocusParent
FocusParent :: FocusParent

-- | Message to move nodes inside the tree
data SelectMoveNode
SelectNode :: SelectMoveNode
MoveNode :: SelectMoveNode

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D

-- | Message for shifting window by splitting its neighbour
newtype SplitShiftDirectional
SplitShift :: Direction1D -> SplitShiftDirectional
instance GHC.Classes.Eq XMonad.Layout.BinarySpacePartition.Axis
instance GHC.Read.Read XMonad.Layout.BinarySpacePartition.Axis
instance GHC.Show.Show XMonad.Layout.BinarySpacePartition.Axis
instance GHC.Classes.Eq XMonad.Layout.BinarySpacePartition.Split
instance GHC.Read.Read XMonad.Layout.BinarySpacePartition.Split
instance GHC.Show.Show XMonad.Layout.BinarySpacePartition.Split
instance GHC.Classes.Eq a => GHC.Classes.Eq (XMonad.Layout.BinarySpacePartition.Tree a)
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Layout.BinarySpacePartition.Tree a)
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.BinarySpacePartition.Tree a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (XMonad.Layout.BinarySpacePartition.Crumb a)
instance GHC.Read.Read a => GHC.Read.Read (XMonad.Layout.BinarySpacePartition.Crumb a)
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Layout.BinarySpacePartition.Crumb a)
instance GHC.Classes.Eq XMonad.Layout.BinarySpacePartition.NodeRef
instance GHC.Read.Read XMonad.Layout.BinarySpacePartition.NodeRef
instance GHC.Show.Show XMonad.Layout.BinarySpacePartition.NodeRef
instance GHC.Classes.Eq (XMonad.Layout.BinarySpacePartition.BinarySpacePartition a)
instance GHC.Read.Read (XMonad.Layout.BinarySpacePartition.BinarySpacePartition a)
instance GHC.Show.Show (XMonad.Layout.BinarySpacePartition.BinarySpacePartition a)
instance XMonad.Core.LayoutClass XMonad.Layout.BinarySpacePartition.BinarySpacePartition Graphics.X11.Types.Window
instance XMonad.Core.Message XMonad.Layout.BinarySpacePartition.SplitShiftDirectional
instance XMonad.Core.Message XMonad.Layout.BinarySpacePartition.SelectMoveNode
instance XMonad.Core.Message XMonad.Layout.BinarySpacePartition.FocusParent
instance XMonad.Core.Message XMonad.Layout.BinarySpacePartition.Swap
instance XMonad.Core.Message XMonad.Layout.BinarySpacePartition.Rotate
instance XMonad.Core.Message XMonad.Layout.BinarySpacePartition.ResizeDirectional
instance XMonad.Core.Message XMonad.Layout.BinarySpacePartition.TreeBalance
instance XMonad.Core.Message XMonad.Layout.BinarySpacePartition.TreeRotate


-- | Flash the names of workspaces name when switching to them. This is a
--   reimplementation of <a>XMonad.Layout.ShowWName</a> as a logHook.
module XMonad.Hooks.ShowWName

-- | LogHook for flashing the name of a workspace upon entering it.
showWNameLogHook :: SWNConfig -> X ()
data SWNConfig
SWNC :: String -> String -> String -> Rational -> SWNConfig

-- | Font name
[swn_font] :: SWNConfig -> String

-- | Background color
[swn_bgcolor] :: SWNConfig -> String

-- | String color
[swn_color] :: SWNConfig -> String

-- | Time in seconds of the name visibility
[swn_fade] :: SWNConfig -> Rational

-- | Flash the name of the currently focused workspace.
flashName :: SWNConfig -> X ()
instance GHC.Read.Read XMonad.Hooks.ShowWName.LastShown
instance GHC.Show.Show XMonad.Hooks.ShowWName.LastShown
instance XMonad.Core.ExtensionClass XMonad.Hooks.ShowWName.LastShown


-- | A module that allows the user to create a sub-mapping of key bindings.
module XMonad.Actions.Submap

-- | Given a <a>Map</a> from key bindings to X () actions, return an action
--   which waits for a user keypress and executes the corresponding action,
--   or does nothing if the key is not found in the map.
submap :: Map (KeyMask, KeySym) (X ()) -> X ()

-- | Like <a>submap</a>, but visualise the relevant options.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   import qualified Data.Map as Map
--   import XMonad.Actions.Submap
--   
--   gotoLayout :: [(String, X ())]   -- for use with EZConfig
--   gotoLayout =  -- assumes you have a layout named "Tall" and one named "Full".
--     [("M-l", visualSubmap def $ Map.fromList $ map (\(k, s, a) -&gt; ((0, k), (s, a)))
--                [ (xK_t, "Tall", switchToLayout "Tall")     -- "M-l t" switches to "Tall"
--                , (xK_r, "Full", switchToLayout "Full")     -- "M-l r" switches to "full"
--                ])]
--   </pre>
--   
--   One could alternatively also write <tt>gotoLayout</tt> as
--   
--   <pre>
--   gotoLayout = [("M-l", visualSubmap def $ Map.fromList $
--                           [ ((0, xK_t), subName "Tall" $ switchToLayout "Tall")
--                           , ((0, xK_r), subName "Full" $ switchToLayout "Full")
--                           ])]
--   </pre>
visualSubmap :: WindowConfig -> Map (KeyMask, KeySym) (String, X ()) -> X ()

-- | Like <a>visualSubmap</a>, but is able to sort the descriptions. For
--   example,
--   
--   <pre>
--   import Data.Ord (comparing, Down)
--   
--   visualSubmapSorted (sortBy (comparing Down)) def
--   </pre>
--   
--   would sort the <tt>(key, description)</tt> pairs by their keys in
--   descending order.
visualSubmapSorted :: ([((KeyMask, KeySym), String)] -> [((KeyMask, KeySym), String)]) -> WindowConfig -> Map (KeyMask, KeySym) (String, X ()) -> X ()

-- | Like <a>submap</a>, but executes a default action if the key did not
--   match.
submapDefault :: X () -> Map (KeyMask, KeySym) (X ()) -> X ()

-- | Like <a>submapDefault</a>, but sends the unmatched key to the default
--   action as argument.
submapDefaultWithKey :: ((KeyMask, KeySym) -> X ()) -> Map (KeyMask, KeySym) (X ()) -> X ()

-- | Give a name to an action.
subName :: String -> X () -> (String, X ())


-- | A wrapper for keybinding configuration that can list the available
--   keybindings.
--   
--   Note that xmonad&gt;=0.11 has by default a list of the default
--   keybindings bound to <tt>M-S-/</tt> or <tt>M-?</tt>.
module XMonad.Util.NamedActions

-- | <a>sendMessage</a> but add a description that is <tt>show
--   message</tt>. Note that not all messages have show instances.
sendMessage' :: (Message a, Show a) => a -> NamedAction

-- | <a>spawn</a> but the description is the string passed
spawn' :: String -> NamedAction

-- | <a>submap</a>, but propagate the descriptions of the actions. Does
--   this belong in <a>XMonad.Actions.Submap</a>?
submapName :: HasName a => [((KeyMask, KeySym), a)] -> NamedAction

-- | Merge the supplied keys with <a>defaultKeysDescr</a>, also adding a
--   keybinding to run an action for showing the keybindings.
addDescrKeys :: (HasName b1, HasName b) => ((KeyMask, KeySym), [((KeyMask, KeySym), NamedAction)] -> b) -> (XConfig Layout -> [((KeyMask, KeySym), b1)]) -> XConfig l -> XConfig l

-- | Without merging with <a>defaultKeysDescr</a>
addDescrKeys' :: HasName b => ((KeyMask, KeySym), [((KeyMask, KeySym), NamedAction)] -> b) -> (XConfig Layout -> [((KeyMask, KeySym), NamedAction)]) -> XConfig l -> XConfig l

-- | An action to send to <a>addDescrKeys</a> for showing the keybindings.
--   See also <a>showKm</a> and <a>showKmSimple</a>
xMessage :: [((KeyMask, KeySym), NamedAction)] -> NamedAction
showKmSimple :: [((KeyMask, KeySym), NamedAction)] -> [[Char]]
showKm :: [((KeyMask, KeySym), NamedAction)] -> [String]

-- | These are just the <tt>NamedAction</tt> constructor but with a more
--   specialized type, so that you don't have to supply any annotations,
--   for ex coercing spawn to <tt>X ()</tt> from the more general
--   <tt>MonadIO m =&gt; m ()</tt>
noName :: X () -> NamedAction
oneName :: (X (), String) -> NamedAction
addName :: String -> X () -> NamedAction

-- | For a prettier presentation: keymask, keysym of 0 are reserved for
--   this purpose: they do not happen, afaik, and keysymToString 0 would
--   raise an error otherwise
separator :: ((KeyMask, KeySym), NamedAction)
subtitle :: String -> ((KeyMask, KeySym), NamedAction)

-- | Combine keymap lists with actions that may or may not have names
(^++^) :: (HasName b, HasName b1) => [(d, b)] -> [(d, b1)] -> [(d, NamedAction)]

-- | An existential wrapper so that different types can be combined in
--   lists, and maps
data NamedAction
NamedAction :: a -> NamedAction
class HasName a

-- | A version of the default keys from the default configuration, but with
--   <a>NamedAction</a> instead of <tt>X ()</tt>
defaultKeysDescr :: XConfig Layout -> [((KeyMask, KeySym), NamedAction)]
instance GHC.Show.Show XMonad.Layout.Resize
instance GHC.Show.Show XMonad.Layout.IncMasterN
instance XMonad.Util.NamedActions.HasName (XMonad.Util.NamedActions.NamedAction, GHC.Base.String)
instance XMonad.Util.NamedActions.HasName XMonad.Util.NamedActions.NamedAction
instance XMonad.Util.NamedActions.HasName (XMonad.Core.X ())
instance XMonad.Util.NamedActions.HasName (GHC.Types.IO ())
instance XMonad.Util.NamedActions.HasName [GHC.Types.Char]
instance XMonad.Util.NamedActions.HasName (XMonad.Core.X (), GHC.Base.String)
instance XMonad.Util.NamedActions.HasName (XMonad.Core.X (), [GHC.Base.String])


-- | Useful helper functions for amending the default configuration, and
--   for parsing keybindings specified in a special (emacs-like) format.
--   
--   (See also <a>XMonad.Util.CustomKeys</a> in xmonad-contrib.)
module XMonad.Util.EZConfig

-- | Add or override keybindings from the existing set. Example use:
--   
--   <pre>
--   main = xmonad $ def { terminal = "urxvt" }
--                   `additionalKeys`
--                   [ ((mod1Mask, xK_m        ), spawn "echo 'Hi, mom!' | dzen2 -p 4")
--                   , ((mod1Mask, xK_BackSpace), withFocused hide) -- N.B. this is an absurd thing to do
--                   ]
--   </pre>
--   
--   This overrides the previous definition of mod-m.
--   
--   Note that, unlike in xmonad 0.4 and previous, you can't use modMask to
--   refer to the modMask you configured earlier. You must specify mod1Mask
--   (or whichever), or add your own <tt>myModMask = mod1Mask</tt> line.
additionalKeys :: XConfig a -> [((KeyMask, KeySym), X ())] -> XConfig a
infixl 4 `additionalKeys`

-- | Like <a>additionalKeys</a>, except using short <tt>String</tt> key
--   descriptors like <tt>"M-m"</tt> instead of <tt>(modMask, xK_m)</tt>,
--   as described in the documentation for <a>mkKeymap</a>. For example:
--   
--   <pre>
--   main = xmonad $ def { terminal = "urxvt" }
--                   `additionalKeysP`
--                   [ ("M-m", spawn "echo 'Hi, mom!' | dzen2 -p 4")
--                   , ("M-&lt;Backspace&gt;", withFocused hide) -- N.B. this is an absurd thing to do
--                   ]
--   </pre>
additionalKeysP :: XConfig l -> [(String, X ())] -> XConfig l
infixl 4 `additionalKeysP`

-- | Remap keybindings from one binding to another. More precisely, the
--   input list contains pairs of the form <tt>(TO, FROM)</tt>, and maps
--   the action bound to <tt>FROM</tt> to the key <tt>TO</tt>. For example,
--   the following would bind <tt>"M-m"</tt> to what's bound to
--   <tt>"M-c"</tt> (which is to close the focused window, in this case):
--   
--   <pre>
--   main :: IO ()
--   main = xmonad $ def `remapKeysP` [("M-m", "M-c")]
--   </pre>
--   
--   NOTE: Submaps are not transparent, and thus these keys can't be
--   accessed in this way: more explicitly, the <tt>FROM</tt> string may
--   **not** be a submap. However, the <tt>TO</tt> can be a submap without
--   problems. This means that
--   
--   <pre>
--   xmonad $ def `remapKeysP` [("M-m", "M-c a")]
--   </pre>
--   
--   is illegal (and indeed will just disregard the binding altogether),
--   while
--   
--   <pre>
--   xmonad $ def `remapKeysP` [("M-c a", "M-m")]
--   </pre>
--   
--   is totally fine.
remapKeysP :: XConfig l -> [(String, String)] -> XConfig l
infixl 4 `remapKeysP`

-- | Remove standard keybindings you're not using. Example use:
--   
--   <pre>
--   main = xmonad $ def { terminal = "urxvt" }
--                   `removeKeys` [(mod1Mask .|. shiftMask, n) | n &lt;- [xK_1 .. xK_9]]
--   </pre>
removeKeys :: XConfig a -> [(KeyMask, KeySym)] -> XConfig a
infixl 4 `removeKeys`

-- | Like <a>removeKeys</a>, except using short <tt>String</tt> key
--   descriptors like <tt>"M-m"</tt> instead of <tt>(modMask, xK_m)</tt>,
--   as described in the documentation for <a>mkKeymap</a>. For example:
--   
--   <pre>
--   main = xmonad $ def { terminal = "urxvt" }
--                   `removeKeysP` ["M-S-" ++ [n] | n &lt;- ['1'..'9']]
--   </pre>
removeKeysP :: XConfig l -> [String] -> XConfig l
infixl 4 `removeKeysP`

-- | Like <a>additionalKeys</a>, but for mouse bindings.
additionalMouseBindings :: XConfig a -> [((ButtonMask, Button), Window -> X ())] -> XConfig a
infixl 4 `additionalMouseBindings`

-- | Like <a>removeKeys</a>, but for mouse bindings.
removeMouseBindings :: XConfig a -> [(ButtonMask, Button)] -> XConfig a
infixl 4 `removeMouseBindings`

-- | Given a config (used to determine the proper modifier key to use) and
--   a list of <tt>(String, X ())</tt> pairs, create a key map by parsing
--   the key sequence descriptions contained in the Strings. The key
--   sequence descriptions are "emacs-style": <tt>M-</tt>, <tt>C-</tt>,
--   <tt>S-</tt>, and <tt>M#-</tt> denote mod, control, shift, and
--   mod1-mod5 (where <tt>#</tt> is replaced by the appropriate number)
--   respectively. Note that if you want to make a keybinding using 'alt'
--   even though you use a different key (like the 'windows' key) for
--   'mod', you can use something like <tt>"M1-x"</tt> for alt+x (check the
--   output of <tt>xmodmap</tt> to see which mod key 'alt' is bound to).
--   Some special keys can also be specified by enclosing their name in
--   angle brackets.
--   
--   For example, <tt>"M-C-x"</tt> denotes mod+ctrl+x;
--   <tt>"S-&lt;Escape&gt;"</tt> denotes shift-escape;
--   <tt>"M1-C-&lt;Delete&gt;"</tt> denotes alt+ctrl+delete (assuming alt
--   is bound to mod1, which is common).
--   
--   Sequences of keys can also be specified by separating the key
--   descriptions with spaces. For example, <tt>"M-x y &lt;Down&gt;"</tt>
--   denotes the sequence of keys mod+x, y, down. Submaps (see
--   <a>XMonad.Actions.Submap</a>) will be automatically generated to
--   correctly handle these cases.
--   
--   So, for example, a complete key map might be specified as
--   
--   <pre>
--   keys = \c -&gt; mkKeymap c $
--       [ ("M-S-&lt;Return&gt;", spawn $ terminal c)
--       , ("M-x w", spawn "xmessage 'woohoo!'")  -- type mod+x then w to pop up 'woohoo!'
--       , ("M-x y", spawn "xmessage 'yay!'")     -- type mod+x then y to pop up 'yay!'
--       , ("M-S-c", kill)
--       ]
--   </pre>
--   
--   Alternatively, you can use <a>additionalKeysP</a> to automatically
--   create a keymap and add it to your config.
--   
--   Here is a complete list of supported special keys. Note that a few
--   keys, such as the arrow keys, have synonyms. If there are other
--   special keys you would like to see supported, feel free to submit a
--   patch, or ask on the xmonad mailing list; adding special keys is quite
--   simple.
--   
--   <pre>
--   &lt;Backspace&gt;
--   &lt;Tab&gt;
--   &lt;Return&gt;
--   &lt;Pause&gt;
--   &lt;Num_Lock&gt;
--   &lt;Caps_Lock&gt;
--   &lt;Scroll_lock&gt;
--   &lt;Sys_Req&gt;
--   &lt;Print&gt;
--   &lt;Escape&gt;, &lt;Esc&gt;
--   &lt;Delete&gt;
--   &lt;Home&gt;
--   &lt;Left&gt;, &lt;L&gt;
--   &lt;Up&gt;, &lt;U&gt;
--   &lt;Right&gt;, &lt;R&gt;
--   &lt;Down&gt;, &lt;D&gt;
--   &lt;Page_Up&gt;
--   &lt;Page_Down&gt;
--   &lt;End&gt;
--   &lt;Insert&gt;
--   &lt;Break&gt;
--   &lt;Space&gt;
--   &lt;Control_L&gt;
--   &lt;Control_R&gt;
--   &lt;Shift_L&gt;
--   &lt;Shift_R&gt;
--   &lt;Alt_L&gt;
--   &lt;Alt_R&gt;
--   &lt;Meta_L&gt;
--   &lt;Meta_R&gt;
--   &lt;Super_L&gt;
--   &lt;Super_R&gt;
--   &lt;Hyper_L&gt;
--   &lt;Hyper_R&gt;
--   &lt;F1&gt;-&lt;F24&gt;
--   &lt;KP_Space&gt;
--   &lt;KP_Tab&gt;
--   &lt;KP_Enter&gt;
--   &lt;KP_F1&gt;
--   &lt;KP_F2&gt;
--   &lt;KP_F3&gt;
--   &lt;KP_F4&gt;
--   &lt;KP_Home&gt;
--   &lt;KP_Left&gt;
--   &lt;KP_Up&gt;
--   &lt;KP_Right&gt;
--   &lt;KP_Down&gt;
--   &lt;KP_Prior&gt;
--   &lt;KP_Page_Up&gt;
--   &lt;KP_Next&gt;
--   &lt;KP_Page_Down&gt;
--   &lt;KP_End&gt;
--   &lt;KP_Begin&gt;
--   &lt;KP_Insert&gt;
--   &lt;KP_Delete&gt;
--   &lt;KP_Equal&gt;
--   &lt;KP_Multiply&gt;
--   &lt;KP_Add&gt;
--   &lt;KP_Separator&gt;
--   &lt;KP_Subtract&gt;
--   &lt;KP_Decimal&gt;
--   &lt;KP_Divide&gt;
--   &lt;KP_0&gt;-&lt;KP_9&gt;
--   </pre>
--   
--   Long list of multimedia keys. Please note that not all keys may be
--   present in your particular setup although most likely they will do.
--   
--   <pre>
--   &lt;XF86ModeLock&gt;
--   &lt;XF86MonBrightnessUp&gt;
--   &lt;XF86MonBrightnessDown&gt;
--   &lt;XF86KbdLightOnOff&gt;
--   &lt;XF86KbdBrightnessUp&gt;
--   &lt;XF86KbdBrightnessDown&gt;
--   &lt;XF86Standby&gt;
--   &lt;XF86AudioLowerVolume&gt;
--   &lt;XF86AudioMute&gt;
--   &lt;XF86AudioRaiseVolume&gt;
--   &lt;XF86AudioPlay&gt;
--   &lt;XF86AudioStop&gt;
--   &lt;XF86AudioPrev&gt;
--   &lt;XF86AudioNext&gt;
--   &lt;XF86HomePage&gt;
--   &lt;XF86Mail&gt;
--   &lt;XF86Start&gt;
--   &lt;XF86Search&gt;
--   &lt;XF86AudioRecord&gt;
--   &lt;XF86Calculator&gt;
--   &lt;XF86Memo&gt;
--   &lt;XF86ToDoList&gt;
--   &lt;XF86Calendar&gt;
--   &lt;XF86PowerDown&gt;
--   &lt;XF86ContrastAdjust&gt;
--   &lt;XF86RockerUp&gt;
--   &lt;XF86RockerDown&gt;
--   &lt;XF86RockerEnter&gt;
--   &lt;XF86Back&gt;
--   &lt;XF86Forward&gt;
--   &lt;XF86Stop&gt;
--   &lt;XF86Refresh&gt;
--   &lt;XF86PowerOff&gt;
--   &lt;XF86WakeUp&gt;
--   &lt;XF86Eject&gt;
--   &lt;XF86ScreenSaver&gt;
--   &lt;XF86WWW&gt;
--   &lt;XF86Sleep&gt;
--   &lt;XF86Favorites&gt;
--   &lt;XF86AudioPause&gt;
--   &lt;XF86AudioMedia&gt;
--   &lt;XF86MyComputer&gt;
--   &lt;XF86VendorHome&gt;
--   &lt;XF86LightBulb&gt;
--   &lt;XF86Shop&gt;
--   &lt;XF86History&gt;
--   &lt;XF86OpenURL&gt;
--   &lt;XF86AddFavorite&gt;
--   &lt;XF86HotLinks&gt;
--   &lt;XF86BrightnessAdjust&gt;
--   &lt;XF86Finance&gt;
--   &lt;XF86Community&gt;
--   &lt;XF86AudioRewind&gt;
--   &lt;XF86XF86BackForward&gt;
--   &lt;XF86Launch0&gt;-&lt;XF86Launch9&gt;, &lt;XF86LaunchA&gt;-&lt;XF86LaunchF&gt;
--   &lt;XF86ApplicationLeft&gt;
--   &lt;XF86ApplicationRight&gt;
--   &lt;XF86Book&gt;
--   &lt;XF86CD&gt;
--   &lt;XF86Calculater&gt;
--   &lt;XF86Clear&gt;
--   &lt;XF86Close&gt;
--   &lt;XF86Copy&gt;
--   &lt;XF86Cut&gt;
--   &lt;XF86Display&gt;
--   &lt;XF86DOS&gt;
--   &lt;XF86Documents&gt;
--   &lt;XF86Excel&gt;
--   &lt;XF86Explorer&gt;
--   &lt;XF86Game&gt;
--   &lt;XF86Go&gt;
--   &lt;XF86iTouch&gt;
--   &lt;XF86LogOff&gt;
--   &lt;XF86Market&gt;
--   &lt;XF86Meeting&gt;
--   &lt;XF86MenuKB&gt;
--   &lt;XF86MenuPB&gt;
--   &lt;XF86MySites&gt;
--   &lt;XF86New&gt;
--   &lt;XF86News&gt;
--   &lt;XF86OfficeHome&gt;
--   &lt;XF86Open&gt;
--   &lt;XF86Option&gt;
--   &lt;XF86Paste&gt;
--   &lt;XF86Phone&gt;
--   &lt;XF86Q&gt;
--   &lt;XF86Reply&gt;
--   &lt;XF86Reload&gt;
--   &lt;XF86RotateWindows&gt;
--   &lt;XF86RotationPB&gt;
--   &lt;XF86RotationKB&gt;
--   &lt;XF86Save&gt;
--   &lt;XF86ScrollUp&gt;
--   &lt;XF86ScrollDown&gt;
--   &lt;XF86ScrollClick&gt;
--   &lt;XF86Send&gt;
--   &lt;XF86Spell&gt;
--   &lt;XF86SplitScreen&gt;
--   &lt;XF86Support&gt;
--   &lt;XF86TaskPane&gt;
--   &lt;XF86Terminal&gt;
--   &lt;XF86Tools&gt;
--   &lt;XF86Travel&gt;
--   &lt;XF86UserPB&gt;
--   &lt;XF86User1KB&gt;
--   &lt;XF86User2KB&gt;
--   &lt;XF86Video&gt;
--   &lt;XF86WheelButton&gt;
--   &lt;XF86Word&gt;
--   &lt;XF86Xfer&gt;
--   &lt;XF86ZoomIn&gt;
--   &lt;XF86ZoomOut&gt;
--   &lt;XF86Away&gt;
--   &lt;XF86Messenger&gt;
--   &lt;XF86WebCam&gt;
--   &lt;XF86MailForward&gt;
--   &lt;XF86Pictures&gt;
--   &lt;XF86Music&gt;
--   &lt;XF86TouchpadToggle&gt;
--   &lt;XF86AudioMicMute&gt;
--   &lt;XF86_Switch_VT_1&gt;-&lt;XF86_Switch_VT_12&gt;
--   &lt;XF86_Ungrab&gt;
--   &lt;XF86_ClearGrab&gt;
--   &lt;XF86_Next_VMode&gt;
--   &lt;XF86_Prev_VMode&gt;
--   &lt;XF86Bluetooth&gt;
--   </pre>
mkKeymap :: XConfig l -> [(String, X ())] -> Map (KeyMask, KeySym) (X ())

-- | Given a configuration record and a list of (key sequence description,
--   action) pairs, check the key sequence descriptions for validity, and
--   warn the user (via a popup xmessage window) of any unparseable or
--   duplicate key sequences. This function is appropriate for adding to
--   your <tt>startupHook</tt>, and you are highly encouraged to do so;
--   otherwise, duplicate or unparseable keybindings will be silently
--   ignored.
--   
--   For example, you might do something like this:
--   
--   <pre>
--   main = xmonad $ myConfig
--   
--   myKeymap = [("S-M-c", kill), ...]
--   myConfig = def {
--       ...
--       keys = \c -&gt; mkKeymap c myKeymap
--       startupHook = return () &gt;&gt; checkKeymap myConfig myKeymap
--       ...
--   }
--   </pre>
--   
--   NOTE: the <tt>return ()</tt> in the example above is very important!
--   Otherwise, you might run into problems with infinite mutual recursion:
--   the definition of myConfig depends on the definition of startupHook,
--   which depends on the definition of myConfig, ... and so on. Actually,
--   it's likely that the above example in particular would be OK without
--   the <tt>return ()</tt>, but making <tt>myKeymap</tt> take
--   <tt>myConfig</tt> as a parameter would definitely lead to problems.
--   Believe me. It, uh, happened to my friend. In... a dream. Yeah. In any
--   event, the <tt>return () &gt;&gt;</tt> introduces enough laziness to
--   break the deadlock.
checkKeymap :: XConfig l -> [(String, a)] -> X ()
mkNamedKeymap :: XConfig l -> [(String, NamedAction)] -> [((KeyMask, KeySym), NamedAction)]

-- | Parse an unmodified basic key, like <tt>"x"</tt>,
--   <tt>"&lt;F1&gt;"</tt>, etc.
parseKey :: Parser KeySym

-- | Parse a modifier-key combination such as "M-C-s" (mod+ctrl+s).
parseKeyCombo :: XConfig l -> Parser (KeyMask, KeySym)

-- | Parse a sequence of key combinations separated by spaces, e.g.
--   <tt>"M-c x C-S-2"</tt> (mod+c, x, ctrl+shift+2).
parseKeySequence :: XConfig l -> Parser [(KeyMask, KeySym)]

-- | Parse a sequence of keys, returning Nothing if there is a parse
--   failure (no parse, or ambiguous parse).
readKeySequence :: XConfig l -> String -> Maybe (NonEmpty (KeyMask, KeySym))


-- | A module for sending key presses to windows. This modules provides
--   generalized and specialized functions for this task.
module XMonad.Util.Paste

-- | Paste the current X mouse selection. Note that this uses
--   <a>getSelection</a> from <a>XMonad.Util.XSelection</a> and so is heir
--   to its flaws.
pasteSelection :: X ()

-- | Send a string to the window which is currently focused. This function
--   correctly handles capitalization. Warning: in dealing with capitalized
--   characters, this assumes a QWERTY layout.
pasteString :: String -> X ()

-- | Send a character to the current window. This is more low-level.
--   Remember that you must handle the case of capitalization
--   appropriately. That is, from the window's perspective:
--   
--   <pre>
--   pasteChar mod2Mask 'F' ~&gt; "f"
--   </pre>
--   
--   You would want to do something like:
--   
--   <pre>
--   pasteChar shiftMask 'F'
--   </pre>
--   
--   Note that this function will probably have trouble with any
--   <a>Char</a> outside ASCII.
pasteChar :: KeyMask -> Char -> X ()

-- | Send a key with a modifier to the currently focused window.
sendKey :: KeyMask -> KeySym -> X ()

-- | The primitive. Allows you to send any combination of <a>KeyMask</a>
--   and <a>KeySym</a> to any <a>Window</a> you specify.
sendKeyWindow :: KeyMask -> KeySym -> Window -> X ()
noModMask :: KeyMask


-- | Remap Keybinding on the fly, e.g having Dvorak char, but everything
--   with Control/Shift is left us Layout
module XMonad.Actions.KeyRemap

-- | Using this in the keybindings to set the actual Key Translation table
setKeyRemap :: KeymapTable -> X ()

-- | Append the output of this function to your keybindings with ++
buildKeyRemapBindings :: [KeymapTable] -> [((KeyMask, KeySym), X ())]

-- | Adding this to your startupHook, to select your default Key
--   Translation table. You also must give it all the KeymapTables you are
--   willing to use
setDefaultKeyRemap :: KeymapTable -> [KeymapTable] -> X ()
newtype KeymapTable
KeymapTable :: [((KeyMask, KeySym), (KeyMask, KeySym))] -> KeymapTable

-- | The empty KeymapTable, does no translation
emptyKeyRemap :: KeymapTable

-- | The dvorak Programmers keymap, translates from us keybindings to
--   dvorak programmers
dvorakProgrammerKeyRemap :: KeymapTable
instance GHC.Show.Show XMonad.Actions.KeyRemap.KeymapTable
instance XMonad.Core.ExtensionClass XMonad.Actions.KeyRemap.KeymapTable


-- | This module implements modal keybindings for xmonad.
module XMonad.Hooks.Modal

-- | Adds the provided modes to the user's config, and sets up the bells
--   and whistles needed for them to work.
modal :: [Mode] -> XConfig l -> XConfig l

-- | Create a <a>Mode</a> from the given binding to <a>exitMode</a>, label
--   and keybindings.
modeWithExit :: String -> String -> (XConfig Layout -> Map (KeyMask, KeySym) (X ())) -> Mode

-- | Create a <a>Mode</a> from the given label and keybindings. Sets the
--   <tt>escape</tt> key to <a>exitMode</a>.
mode :: String -> (XConfig Layout -> Map (KeyMask, KeySym) (X ())) -> Mode

-- | The mode type. Use <a>mode</a> or <a>modeWithExit</a> to create modes.
data Mode

-- | From a list of <a>XMonad.Util.EZConfig</a>-style bindings, generate a
--   key representation.
--   
--   <pre>
--   &gt;&gt;&gt; mkKeysEz [("h", xmessage "Hello, world!")]
--   </pre>
mkKeysEz :: [(String, X ())] -> XConfig Layout -> Map (ButtonMask, KeySym) (X ())

-- | Set the current <a>Mode</a> based on its label.
setMode :: String -> X ()

-- | Exits the current mode.
exitMode :: X ()
noModModeLabel :: String

-- | In this <a>Mode</a>, all keybindings are available without the need
--   for pressing the modifier. Pressing <tt>escape</tt> exits the mode.
noModMode :: Mode
floatModeLabel :: String

-- | A mode to control floating windows with <tt>{hijk}</tt>,
--   <tt>M-{hijk}</tt> and <tt>M-S-{hijk}</tt> in order to respectively
--   move, enlarge and shrink windows.
floatMode :: Int -> Mode
overlayedFloatModeLabel :: String

-- | Similar to <tt>resizeMode</tt>, but keeps the bindings of the original
--   config active.
overlayedFloatMode :: Int -> Mode

-- | Generates the keybindings for <a>floatMode</a> and
--   <a>overlayedFloatMode</a>.
floatMap :: KeyMask -> KeyMask -> KeyMask -> Int -> Map (ButtonMask, KeySym) (X ())

-- | Modifies a mode so that the keybindings are merged with those from the
--   config instead of replacing them.
overlay :: String -> Mode -> Mode

-- | A <a>Logger</a> to display the current mode.
logMode :: Logger
instance GHC.Base.Semigroup XMonad.Hooks.Modal.ModeConfig
instance XMonad.Core.ExtensionClass XMonad.Hooks.Modal.CurrentMode


-- | A <tt>manageHook</tt> and associated <tt>logHook</tt> for debugging
--   <a>ManageHook</a>s. Simplest usage: wrap your xmonad config in the
--   <tt>debugManageHook</tt> combinator. Or use <tt>debugManageHookOn</tt>
--   for a triggerable version, specifying the triggering key sequence in
--   <a>XMonad.Util.EZConfig</a> syntax. Or use the individual hooks in
--   whatever way you see fit.
module XMonad.Hooks.ManageDebug

-- | A combinator to add full <a>ManageHook</a> debugging in a single
--   operation.
debugManageHook :: XConfig l -> XConfig l

-- | A combinator to add triggerable <a>ManageHook</a> debugging in a
--   single operation. Specify a key sequence as a string in
--   <a>XMonad.Util.EZConfig</a> syntax; press this key before opening the
--   window to get just that logged.
debugManageHookOn :: String -> XConfig l -> XConfig l

-- | Place this at the start of a <a>ManageHook</a>, or possibly other
--   places for a more limited view. It will show the current
--   <tt>StackSet</tt> state and the new window, and set a flag so that
--   <tt>manageDebugLogHook</tt> will display the final <tt>StackSet</tt>
--   state.
--   
--   Note that the initial state shows only the current workspace; the
--   final one shows all workspaces, since your <a>manageHook</a> might use
--   e.g. <a>doShift</a>,
manageDebug :: ManageHook

-- | <tt>manageDebug</tt> only if the user requested it with
--   <tt>debugNextManagedWindow</tt>.
maybeManageDebug :: ManageHook

-- | If <tt>manageDebug</tt> has set the debug-stack flag, show the stack.
manageDebugLogHook :: X ()

-- | Request that the next window to be managed be <tt>manageDebug</tt>-ed.
--   This can be used anywhere an X action can, such as key bindings, mouse
--   bindings (presumably with <a>const</a>), <a>startupHook</a>, etc.
debugNextManagedWindow :: X ()
instance GHC.Show.Show XMonad.Hooks.ManageDebug.MSDFinal
instance GHC.Show.Show XMonad.Hooks.ManageDebug.MSDTrigger
instance GHC.Show.Show XMonad.Hooks.ManageDebug.ManageStackDebug
instance XMonad.Core.ExtensionClass XMonad.Hooks.ManageDebug.ManageStackDebug


-- | This is a draft of a brand new config syntax for xmonad. It aims to
--   be:
--   
--   <ul>
--   <li>easier to copy/paste snippets from the docs</li>
--   <li>easier to get the gist for what's going on, for you imperative
--   programmers</li>
--   </ul>
--   
--   It's brand new, so it's pretty much guaranteed to break or change
--   syntax. But what's the worst that could happen? Xmonad crashes and
--   logs you out? It probably won't do that. Give it a try.

-- | <i>Deprecated: This module is a perpetual draft and will therefore be
--   removed from xmonad-contrib in the near future.</i>
module XMonad.Config.Prime

-- | This is the xmonad main function. It passes <a>def</a> (the default
--   <a>XConfig</a>) into your do-block, takes the modified config out of
--   your do-block, and then runs xmonad.
--   
--   The do-block is a <a>Prime</a>. Advanced readers can skip right to
--   that definition.
xmonad :: (Default a, Read (l Window), LayoutClass l Window) => (a -> IO (XConfig l)) -> IO ()

-- | This doesn't modify the config in any way. It's just here for your
--   initial config because Haskell doesn't allow empty do-blocks. Feel
--   free to delete it once you've added other stuff.
nothing :: Prime l l

-- | Non-focused windows border color. Default: <tt>"#dddddd"</tt>
normalBorderColor :: Settable String (XConfig l)

-- | Focused windows border color. Default: <tt>"#ff0000"</tt>
focusedBorderColor :: Settable String (XConfig l)

-- | The preferred terminal application. Default: <tt>"xterm"</tt>
terminal :: Settable String (XConfig l)

-- | The mod modifier, as used by key bindings. Default: <tt>mod1Mask</tt>
--   (which is probably alt on your computer).
modMask :: Settable KeyMask (XConfig l)

-- | The border width (in pixels). Default: <tt>1</tt>
borderWidth :: Settable Dimension (XConfig l)

-- | Whether window focus follows the mouse cursor on move, or requires a
--   mouse click. (Mouse? What's that?) Default: <tt>True</tt>
focusFollowsMouse :: Settable Bool (XConfig l)

-- | If True, a mouse click on an inactive window focuses it, but the click
--   is not passed to the window. If False, the click is also passed to the
--   window. Default <tt>True</tt>
clickJustFocuses :: Settable Bool (XConfig l)
class SettableClass s x y | s -> x y

-- | This lets you modify an attribute.
(=:) :: SettableClass s x y => s c -> y -> Arr c c
class UpdateableClass s x y | s -> x y

-- | This lets you apply a function to an attribute (i.e. read, modify,
--   write).
(=.) :: UpdateableClass s x y => s c -> (x -> y) -> Arr c c

-- | The action to run when a new window is opened. Default:
--   
--   <pre>
--   manageHook =: composeAll [className =? "MPlayer" --&gt; doFloat, className =? "Gimp" --&gt; doFloat]
--   </pre>
--   
--   To add more rules to this list, you can say, for instance:
--   
--   <pre>
--   import XMonad.StackSet
--   ...
--     manageHook =+ (className =? "Emacs" --&gt; doF kill)
--     manageHook =+ (className =? "Vim" --&gt; doF shiftMaster)
--   </pre>
--   
--   Note that operator precedence mandates the parentheses here.
manageHook :: Summable ManageHook ManageHook (XConfig l)

-- | Custom X event handler. Return <tt>All True</tt> if the default
--   handler should also be run afterwards. Default does nothing. To add an
--   event handler:
--   
--   <pre>
--   import XMonad.Hooks.ServerMode
--   ...
--     handleEventHook =+ serverModeEventHook
--   </pre>
handleEventHook :: Summable (Event -> X All) (Event -> X All) (XConfig l)

-- | List of workspaces' names. Default: <tt>map show [1 .. 9 :: Int]</tt>.
--   Adding appends to the end:
--   
--   <pre>
--   workspaces =+ ["0"]
--   </pre>
--   
--   This is useless unless you also create keybindings for this.
workspaces :: Summable [String] [String] (XConfig l)

-- | The action to perform when the windows set is changed. This happens
--   whenever focus change, a window is moved, etc. <tt>logHook =+</tt>
--   takes an <tt>X ()</tt> and appends it via <a>(&gt;&gt;)</a>. For
--   instance:
--   
--   <pre>
--   import XMonad.Hooks.ICCCMFocus
--   ...
--     logHook =+ takeTopFocus
--   </pre>
--   
--   Note that if your expression is parametrically typed (e.g. of type
--   <tt>MonadIO m =&gt; m ()</tt>), you'll need to explicitly annotate it,
--   like so:
--   
--   <pre>
--   logHook =+ (io $ putStrLn "Hello, world!" :: X ())
--   </pre>
logHook :: Summable (X ()) (X ()) (XConfig l)

-- | The action to perform on startup. <tt>startupHook =+</tt> takes an
--   <tt>X ()</tt> and appends it via <a>(&gt;&gt;)</a>. For instance:
--   
--   <pre>
--   import XMonad.Hooks.SetWMName
--   ...
--     startupHook =+ setWMName "LG3D"
--   </pre>
--   
--   Note that if your expression is parametrically typed (e.g. of type
--   <tt>MonadIO m =&gt; m ()</tt>), you'll need to explicitly annotate it,
--   as documented in <a>logHook</a>.
startupHook :: Summable (X ()) (X ()) (XConfig l)

-- | The client events that xmonad is interested in. This is useful in
--   combination with handleEventHook. Default: <tt>structureNotifyMask .|.
--   enterWindowMask .|. propertyChangeMask</tt>
--   
--   <pre>
--   clientMask =+ keyPressMask .|. keyReleaseMask
--   </pre>
clientMask :: Summable EventMask EventMask (XConfig l)

-- | The root events that xmonad is interested in. This is useful in
--   combination with handleEventHook. Default:
--   <tt>substructureRedirectMask .|. substructureNotifyMask .|.
--   enterWindowMask .|. leaveWindowMask .|. structureNotifyMask .|.
--   buttonPressMask</tt>
rootMask :: Summable EventMask EventMask (XConfig l)
class SummableClass s y | s -> y

-- | This lets you add to an attribute.
(=+) :: SummableClass s y => s c -> y -> Arr c c
infix 0 =+

-- | Key bindings to <a>X</a> actions. Default: see <tt>`man xmonad`</tt>.
--   <a>keys</a> takes a list of keybindings specified emacs-style, as
--   documented in <a>mkKeyMap</a>. For example, to change the "kill
--   window" key:
--   
--   <pre>
--   keys =- ["M-S-c"]
--   keys =+ [("M-M1-x", kill)]
--   </pre>
keys :: Keys (XConfig l)

-- | Mouse button bindings to an <a>X</a> actions on a window. Default: see
--   <tt>`man xmonad`</tt>. To make <tt>mod-&lt;scrollwheel&gt;</tt> switch
--   workspaces:
--   
--   <pre>
--   import XMonad.Actions.CycleWS (nextWS, prevWS)
--   ...
--     mouseBindings =+ [((mod4Mask, button4), const prevWS),
--                       ((mod4Mask, button5), const nextWS)]
--   </pre>
--   
--   Note that you need to specify the numbered mod-mask e.g.
--   <a>mod4Mask</a> instead of just <a>modMask</a>.
mouseBindings :: MouseBindings (XConfig l)
class RemovableClass r y | r -> y

-- | This lets you remove from an attribute.
(=-) :: RemovableClass r y => r c -> y -> Arr c c
infix 0 =-

-- | Configure workspaces through a Prime-like interface. Example:
--   
--   <pre>
--   withWorkspaces $ do
--     wsKeys =+ ["0"]
--     wsActions =+ [("M-M1-", windows . swapWithCurrent)]
--     wsSetName 1 "mail"
--   </pre>
--   
--   This will set <a>workspaces</a> and add the necessary keybindings to
--   <a>keys</a>. Note that it won't remove old keybindings; it's just not
--   that clever.
withWorkspaces :: Arr WorkspaceConfig WorkspaceConfig -> Prime l l

-- | The list of workspace names, like <a>workspaces</a> but with two
--   differences:
--   
--   <ol>
--   <li>If any entry is the empty string, it'll be replaced with the
--   corresponding entry in <a>wsKeys</a>.</li>
--   <li>The list is truncated to the size of <a>wsKeys</a>.</li>
--   </ol>
--   
--   The default value is <tt><a>repeat</a> ""</tt>.
--   
--   If you'd like to create workspaces without associated keyspecs, you
--   can do that afterwards, outside the <a>withWorkspaces</a> block, with
--   <tt><a>workspaces</a> =+</tt>.
wsNames :: Settable [String] WorkspaceConfig

-- | The list of workspace keys. These are combined with the modifiers in
--   <a>wsActions</a> to form the keybindings for navigating to workspaces.
--   Default: <tt>["1","2",...,"9"]</tt>.
wsKeys :: Summable [String] [String] WorkspaceConfig

-- | Mapping from key prefix to command. Its type is <tt>[(String, String
--   -&gt; X())]</tt>. The key prefix may be a modifier such as
--   <tt>"M-"</tt>, or a submap prefix such as <tt>"M-a "</tt>, or both, as
--   in <tt>"M-a M-"</tt>. The command is a function that takes a workspace
--   name and returns an <tt>X ()</tt>. <a>withWorkspaces</a> creates
--   keybindings for the cartesian product of <a>wsKeys</a> and
--   <a>wsActions</a>.
--   
--   Default:
--   
--   <pre>
--   [("M-", windows . W.greedyView),
--    ("M-S-", windows . W.shift)]
--   </pre>
wsActions :: Summable [(String, String -> X ())] [(String, String -> X ())] WorkspaceConfig

-- | A convenience for just modifying one entry in <a>wsNames</a>, in case
--   you only want a few named workspaces. Example:
--   
--   <pre>
--   wsSetName 1 "mail"
--   wsSetName 2 "web"
--   </pre>
wsSetName :: Int -> String -> Arr WorkspaceConfig WorkspaceConfig

-- | Configure screen keys through a Prime-like interface:
--   
--   <pre>
--   withScreens $ do
--     sKeys =: ["e", "r"]
--   </pre>
--   
--   This will add the necessary keybindings to <a>keys</a>. Note that it
--   won't remove old keybindings; it's just not that clever.
withScreens :: Arr ScreenConfig ScreenConfig -> Prime l l

-- | The list of screen keys. These are combined with the modifiers in
--   <a>sActions</a> to form the keybindings for navigating to workspaces.
--   Default: <tt>["w","e","r"]</tt>.
sKeys :: Summable [String] [String] ScreenConfig

-- | Mapping from key prefix to command. Its type is <tt>[(String, ScreenId
--   -&gt; X())]</tt>. Works the same as <a>wsActions</a> except for a
--   different function type.
--   
--   Default:
--   
--   <pre>
--   [("M-", windows . onScreens W.view),
--    ("M-S-", windows . onScreens W.shift)]
--   </pre>
sActions :: Summable [(String, ScreenId -> X ())] [(String, ScreenId -> X ())] ScreenConfig

-- | Converts a stackset transformer parameterized on the workspace type
--   into one parameterized on the screen type. For example, you can use
--   <tt>onScreens W.view 0</tt> to navigate to the workspace on the 0th
--   screen. If the screen id is not recognized, the returned transformer
--   acts as an identity function.
onScreens :: Eq s => (i -> StackSet i l a s sd -> StackSet i l a s sd) -> s -> StackSet i l a s sd -> StackSet i l a s sd

-- | Add a layout to the list of layouts choosable with mod-space. For
--   instance:
--   
--   <pre>
--   import XMonad.Layout.Tabbed
--   ...
--     addLayout simpleTabbed
--   </pre>
addLayout :: (LayoutClass l Window, LayoutClass r Window) => r Window -> Prime l (Choose l r)

-- | Reset the layoutHook from scratch. For instance, to get rid of the
--   wide layout:
--   
--   <pre>
--   resetLayout $ Tall 1 (3/100) (1/2) ||| Full
--   </pre>
--   
--   (The dollar is like an auto-closing parenthesis, so all the stuff to
--   the right of it is treated like an argument to resetLayout.)
resetLayout :: LayoutClass r Window => r Window -> Prime l r

-- | Modify your <tt>layoutHook</tt> with some wrapper function. You
--   probably want to call this after you're done calling <a>addLayout</a>.
--   Example:
--   
--   <pre>
--   import XMonad.Layout.NoBorders
--   ...
--     modifyLayout smartBorders
--   </pre>
modifyLayout :: LayoutClass r Window => (l Window -> r Window) -> Prime l r

-- | Replace the current <a>XConfig</a> with the given one. If you use
--   this, you probably want it to be the first line of your config.
startWith :: XConfig l' -> Prime l l'

-- | Turns a pure function on <a>XConfig</a> into a <a>Prime</a>.
apply :: (XConfig l -> XConfig l') -> Prime l l'

-- | Turns an IO function on <a>XConfig</a> into a <a>Prime</a>.
applyIO :: (XConfig l -> IO (XConfig l')) -> Prime l l'

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)
getModifierMapping :: Display -> IO [(Modifier, [KeyCode])]
getCommand :: Display -> Window -> IO [String]

-- | Retrieves error event data from a pointer to an XErrorEvent and puts
--   it into an ErrorEvent.
getErrorEvent :: XErrorEventPtr -> IO ErrorEvent

-- | A binding to XSetErrorHandler. NOTE: This is pretty experimental
--   because of safe vs. unsafe calls. I changed sync to a safe call, but
--   there *might* be other calls that cause a problem
setErrorHandler :: XErrorHandler -> IO ()
setWMHints :: Display -> Window -> WMHints -> IO Status
getWMHints :: Display -> Window -> IO WMHints
allHintsBitmask :: CLong
urgencyHintBit :: Int
windowGroupHintBit :: Int
iconMaskHintBit :: Int
iconPositionHintBit :: Int
iconWindowHintBit :: Int
iconPixmapHintBit :: Int
stateHintBit :: Int
inputHintBit :: Int
iconicState :: Int
normalState :: Int
withdrawnState :: Int

-- | Set the <tt>WM_CLASS</tt> property for the given window.
setClassHint :: Display -> Window -> ClassHint -> IO ()
getClassHint :: Display -> Window -> IO ClassHint
setWMNormalHints :: Display -> Window -> SizeHints -> IO ()
getWMNormalHints :: Display -> Window -> IO SizeHints
pWinGravityBit :: Int
pBaseSizeBit :: Int
pAspectBit :: Int
pResizeIncBit :: Int
pMaxSizeBit :: Int
pMinSizeBit :: Int
unmapWindow :: Display -> Window -> IO ()
deleteProperty :: Display -> Window -> Atom -> IO ()
propModeAppend :: CInt
propModePrepend :: CInt
propModeReplace :: CInt
changeProperty32 :: Display -> Window -> Atom -> Atom -> CInt -> [CLong] -> IO ()
changeProperty16 :: Display -> Window -> Atom -> Atom -> CInt -> [CShort] -> IO ()
changeProperty8 :: Display -> Window -> Atom -> Atom -> CInt -> [CChar] -> IO ()
getWindowProperty32 :: Display -> Atom -> Window -> IO (Maybe [CLong])
getWindowProperty16 :: Display -> Atom -> Window -> IO (Maybe [CShort])
getWindowProperty8 :: Display -> Atom -> Window -> IO (Maybe [CChar])
rawGetWindowProperty :: Storable a => Int -> Display -> Atom -> Window -> IO (Maybe [a])
anyPropertyType :: Atom

-- | refreshKeyboardMapping. TODO Remove this binding when the fix has been
--   commited to X11
refreshKeyboardMapping :: Event -> IO ()
setKeyEvent :: XEventPtr -> Window -> Window -> Window -> KeyMask -> KeyCode -> Bool -> IO ()
setConfigureEvent :: XEventPtr -> Window -> Window -> CInt -> CInt -> CInt -> CInt -> CInt -> Window -> Bool -> IO ()
setClientMessageEvent' :: XEventPtr -> Window -> Atom -> CInt -> [CInt] -> IO ()
setClientMessageEvent :: XEventPtr -> Window -> Atom -> CInt -> Atom -> Time -> IO ()
setSelectionNotify :: XEventPtr -> Window -> Atom -> Atom -> Atom -> Time -> IO ()
setEventType :: XEventPtr -> EventType -> IO ()

-- | The XGetWMProtocols function returns the list of atoms stored in the
--   WM_PROTOCOLS property on the specified window. These atoms describe
--   window manager protocols in which the owner of this window is willing
--   to participate. If the property exists, is of type ATOM, is of format
--   32, and the atom WM_PROTOCOLS can be interned, XGetWMProtocols sets
--   the protocols_return argument to a list of atoms, sets the
--   count_return argument to the number of elements in the list, and
--   returns a nonzero status. Otherwise, it sets neither of the return
--   arguments and returns a zero status. To release the list of atoms, use
--   XFree.
getWMProtocols :: Display -> Window -> IO [Atom]
getTransientForHint :: Display -> Window -> IO (Maybe Window)
fetchName :: Display -> Window -> IO (Maybe String)
wcTextEscapement :: FontSet -> String -> Int32
wcDrawImageString :: Display -> Drawable -> FontSet -> GC -> Position -> Position -> String -> IO ()
wcDrawString :: Display -> Drawable -> FontSet -> GC -> Position -> Position -> String -> IO ()
wcTextExtents :: FontSet -> String -> (Rectangle, Rectangle)
createFontSet :: Display -> String -> IO ([String], String, FontSet)
wcTextPropertyToTextList :: Display -> TextProperty -> IO [String]
getTextProperty :: Display -> Window -> Atom -> IO TextProperty

-- | Run an action with the server
withServer :: Display -> IO () -> IO ()
getWindowAttributes :: Display -> Window -> IO WindowAttributes
waIsViewable :: CInt
waIsUnviewable :: CInt
waIsUnmapped :: CInt
queryTree :: Display -> Window -> IO (Window, Window, [Window])
configureWindow :: Display -> Window -> CULong -> WindowChanges -> IO ()
currentTime :: Time
anyKey :: KeyCode
anyButton :: Button
none :: XID
getEvent :: XEventPtr -> IO Event
eventName :: Event -> String
eventTable :: [(EventType, String)]
xConfigureWindow :: Display -> Window -> CULong -> Ptr WindowChanges -> IO CInt
killClient :: Display -> Window -> IO CInt
xQueryTree :: Display -> Window -> Ptr Window -> Ptr Window -> Ptr (Ptr Window) -> Ptr CInt -> IO Status
xGetWindowAttributes :: Display -> Window -> Ptr WindowAttributes -> IO Status

-- | interface to the X11 library function
--   <tt>XChangeWindowAttributes()</tt>.
changeWindowAttributes :: Display -> Window -> AttributeMask -> Ptr SetWindowAttributes -> IO ()
xGetTextProperty :: Display -> Window -> Ptr TextProperty -> Atom -> IO Status
xwcTextPropertyToTextList :: Display -> Ptr TextProperty -> Ptr (Ptr CWString) -> Ptr CInt -> IO CInt
wcFreeStringList :: Ptr CWString -> IO ()
xCreateFontSet :: Display -> CString -> Ptr (Ptr CString) -> Ptr CInt -> Ptr CString -> IO (Ptr FontSet)
freeStringList :: Ptr CString -> IO ()
freeFontSet :: Display -> FontSet -> IO ()
xwcTextExtents :: FontSet -> CWString -> CInt -> Ptr Rectangle -> Ptr Rectangle -> IO CInt
xwcDrawString :: Display -> Drawable -> FontSet -> GC -> Position -> Position -> CWString -> CInt -> IO ()
xwcDrawImageString :: Display -> Drawable -> FontSet -> GC -> Position -> Position -> CWString -> CInt -> IO ()
xwcTextEscapement :: FontSet -> CWString -> CInt -> IO Int32
xFetchName :: Display -> Window -> Ptr CString -> IO Status
xGetTransientForHint :: Display -> Window -> Ptr Window -> IO Status
xGetWMProtocols :: Display -> Window -> Ptr (Ptr Atom) -> Ptr CInt -> IO Status
xSetErrorHandler :: IO ()
xRefreshKeyboardMapping :: Ptr () -> IO CInt
xChangeProperty :: Display -> Window -> Atom -> Atom -> CInt -> CInt -> Ptr CUChar -> CInt -> IO Status
xDeleteProperty :: Display -> Window -> Atom -> IO Status
xGetWindowProperty :: Display -> Window -> Atom -> CLong -> CLong -> Bool -> Atom -> Ptr Atom -> Ptr CInt -> Ptr CULong -> Ptr CULong -> Ptr (Ptr CUChar) -> IO Status
xUnmapWindow :: Display -> Window -> IO CInt
xGetWMNormalHints :: Display -> Window -> Ptr SizeHints -> Ptr CLong -> IO Status
xAllocSizeHints :: IO (Ptr SizeHints)
xSetWMNormalHints :: Display -> Window -> Ptr SizeHints -> IO ()
xGetClassHint :: Display -> Window -> Ptr ClassHint -> IO Status
xSetClassHint :: Display -> Window -> Ptr ClassHint -> IO ()
xGetWMHints :: Display -> Window -> IO (Ptr WMHints)
xAllocWMHints :: IO (Ptr WMHints)
xSetWMHints :: Display -> Window -> Ptr WMHints -> IO Status
isCursorKey :: KeySym -> Bool
isFunctionKey :: KeySym -> Bool
isKeypadKey :: KeySym -> Bool
isMiscFunctionKey :: KeySym -> Bool
isModifierKey :: KeySym -> Bool
isPFKey :: KeySym -> Bool
isPrivateKeypadKey :: KeySym -> Bool
xSetSelectionOwner :: Display -> Atom -> Window -> Time -> IO ()
xGetSelectionOwner :: Display -> Atom -> IO Window
xConvertSelection :: Display -> Atom -> Atom -> Atom -> Window -> Time -> IO ()
mkXErrorHandler :: CXErrorHandler -> IO (FunPtr CXErrorHandler)
getXErrorHandler :: FunPtr CXErrorHandler -> CXErrorHandler
_xSetErrorHandler :: FunPtr CXErrorHandler -> IO (FunPtr CXErrorHandler)

-- | A binding to XMapRaised.
mapRaised :: Display -> Window -> IO CInt
xGetCommand :: Display -> Window -> Ptr (Ptr CWString) -> Ptr CInt -> IO Status
xGetModifierMapping :: Display -> IO (Ptr ())
xFreeModifiermap :: Ptr () -> IO (Ptr CInt)
data Event
AnyEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
ConfigureRequestEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Window -> !CInt -> !CInt -> !CInt -> !CInt -> !CInt -> !Window -> !NotifyDetail -> !CULong -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_parent] :: Event -> !Window
[ev_window] :: Event -> !Window
[ev_x] :: Event -> !CInt
[ev_y] :: Event -> !CInt
[ev_width] :: Event -> !CInt
[ev_height] :: Event -> !CInt
[ev_border_width] :: Event -> !CInt
[ev_above] :: Event -> !Window
[ev_detail] :: Event -> !NotifyDetail
[ev_value_mask] :: Event -> !CULong
ConfigureEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Window -> !CInt -> !CInt -> !CInt -> !CInt -> !CInt -> !Window -> !Bool -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_event] :: Event -> !Window
[ev_window] :: Event -> !Window
[ev_x] :: Event -> !CInt
[ev_y] :: Event -> !CInt
[ev_width] :: Event -> !CInt
[ev_height] :: Event -> !CInt
[ev_border_width] :: Event -> !CInt
[ev_above] :: Event -> !Window
[ev_override_redirect] :: Event -> !Bool
MapRequestEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Window -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_parent] :: Event -> !Window
[ev_window] :: Event -> !Window
KeyEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Window -> !Window -> !Time -> !CInt -> !CInt -> !CInt -> !CInt -> !KeyMask -> !KeyCode -> !Bool -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_root] :: Event -> !Window
[ev_subwindow] :: Event -> !Window
[ev_time] :: Event -> !Time
[ev_x] :: Event -> !CInt
[ev_y] :: Event -> !CInt
[ev_x_root] :: Event -> !CInt
[ev_y_root] :: Event -> !CInt
[ev_state] :: Event -> !KeyMask
[ev_keycode] :: Event -> !KeyCode
[ev_same_screen] :: Event -> !Bool
ButtonEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Window -> !Window -> !Time -> !CInt -> !CInt -> !CInt -> !CInt -> !KeyMask -> !Button -> !Bool -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_root] :: Event -> !Window
[ev_subwindow] :: Event -> !Window
[ev_time] :: Event -> !Time
[ev_x] :: Event -> !CInt
[ev_y] :: Event -> !CInt
[ev_x_root] :: Event -> !CInt
[ev_y_root] :: Event -> !CInt
[ev_state] :: Event -> !KeyMask
[ev_button] :: Event -> !Button
[ev_same_screen] :: Event -> !Bool
MotionEvent :: !EventType -> !CULong -> !Bool -> Display -> !CInt -> !CInt -> !Window -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_x] :: Event -> !CInt
[ev_y] :: Event -> !CInt
[ev_window] :: Event -> !Window
DestroyWindowEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Window -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_event] :: Event -> !Window
[ev_window] :: Event -> !Window
UnmapEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Window -> !Bool -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_event] :: Event -> !Window
[ev_window] :: Event -> !Window
[ev_from_configure] :: Event -> !Bool
MapNotifyEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Window -> !Bool -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_event] :: Event -> !Window
[ev_window] :: Event -> !Window
[ev_override_redirect] :: Event -> !Bool
MappingNotifyEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !MappingRequest -> !KeyCode -> !CInt -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_request] :: Event -> !MappingRequest
[ev_first_keycode] :: Event -> !KeyCode
[ev_count] :: Event -> !CInt
CrossingEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Window -> !Window -> !Time -> !CInt -> !CInt -> !CInt -> !CInt -> !NotifyMode -> !NotifyDetail -> !Bool -> !Bool -> !Modifier -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_root] :: Event -> !Window
[ev_subwindow] :: Event -> !Window
[ev_time] :: Event -> !Time
[ev_x] :: Event -> !CInt
[ev_y] :: Event -> !CInt
[ev_x_root] :: Event -> !CInt
[ev_y_root] :: Event -> !CInt
[ev_mode] :: Event -> !NotifyMode
[ev_detail] :: Event -> !NotifyDetail
[ev_same_screen] :: Event -> !Bool
[ev_focus] :: Event -> !Bool
[ev_state] :: Event -> !Modifier
SelectionRequest :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Window -> !Atom -> !Atom -> !Atom -> !Time -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_owner] :: Event -> !Window
[ev_requestor] :: Event -> !Window
[ev_selection] :: Event -> !Atom
[ev_target] :: Event -> !Atom
[ev_property] :: Event -> !Atom
[ev_time] :: Event -> !Time
SelectionClear :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Atom -> !Time -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_selection] :: Event -> !Atom
[ev_time] :: Event -> !Time
PropertyEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Atom -> !Time -> !CInt -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_atom] :: Event -> !Atom
[ev_time] :: Event -> !Time
[ev_propstate] :: Event -> !CInt
ExposeEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !CInt -> !CInt -> !CInt -> !CInt -> !CInt -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_x] :: Event -> !CInt
[ev_y] :: Event -> !CInt
[ev_width] :: Event -> !CInt
[ev_height] :: Event -> !CInt
[ev_count] :: Event -> !CInt
FocusChangeEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !NotifyMode -> !NotifyDetail -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_mode] :: Event -> !NotifyMode
[ev_detail] :: Event -> !NotifyDetail
ClientMessageEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Atom -> ![CInt] -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_message_type] :: Event -> !Atom
[ev_data] :: Event -> ![CInt]
RRScreenChangeNotifyEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Window -> !Time -> !Time -> !SizeID -> !SubpixelOrder -> !Rotation -> !CInt -> !CInt -> !CInt -> !CInt -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_root] :: Event -> !Window
[ev_timestamp] :: Event -> !Time
[ev_config_timestamp] :: Event -> !Time
[ev_size_index] :: Event -> !SizeID
[ev_subpixel_order] :: Event -> !SubpixelOrder
[ev_rotation] :: Event -> !Rotation
[ev_width] :: Event -> !CInt
[ev_height] :: Event -> !CInt
[ev_mwidth] :: Event -> !CInt
[ev_mheight] :: Event -> !CInt
RRNotifyEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !CInt -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_subtype] :: Event -> !CInt
RRCrtcChangeNotifyEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !CInt -> !RRCrtc -> !RRMode -> !Rotation -> !CInt -> !CInt -> !CUInt -> !CUInt -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_subtype] :: Event -> !CInt
[ev_crtc] :: Event -> !RRCrtc
[ev_rr_mode] :: Event -> !RRMode
[ev_rotation] :: Event -> !Rotation
[ev_x] :: Event -> !CInt
[ev_y] :: Event -> !CInt
[ev_rr_width] :: Event -> !CUInt
[ev_rr_height] :: Event -> !CUInt
RROutputChangeNotifyEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !CInt -> !RROutput -> !RRCrtc -> !RRMode -> !Rotation -> !Connection -> !SubpixelOrder -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_subtype] :: Event -> !CInt
[ev_output] :: Event -> !RROutput
[ev_crtc] :: Event -> !RRCrtc
[ev_rr_mode] :: Event -> !RRMode
[ev_rotation] :: Event -> !Rotation
[ev_connection] :: Event -> !Connection
[ev_subpixel_order] :: Event -> !SubpixelOrder
RROutputPropertyNotifyEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !CInt -> !RROutput -> !Atom -> !Time -> !CInt -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_subtype] :: Event -> !CInt
[ev_output] :: Event -> !RROutput
[ev_property] :: Event -> !Atom
[ev_timestamp] :: Event -> !Time
[ev_rr_state] :: Event -> !CInt
ScreenSaverNotifyEvent :: !EventType -> !CULong -> !Bool -> Display -> !Window -> !Window -> !XScreenSaverState -> !XScreenSaverKind -> !Bool -> !Time -> Event
[ev_event_type] :: Event -> !EventType
[ev_serial] :: Event -> !CULong
[ev_send_event] :: Event -> !Bool
[ev_event_display] :: Event -> Display
[ev_window] :: Event -> !Window
[ev_root] :: Event -> !Window
[ev_ss_state] :: Event -> !XScreenSaverState
[ev_ss_kind] :: Event -> !XScreenSaverKind
[ev_forced] :: Event -> !Bool
[ev_time] :: Event -> !Time
data WindowChanges
WindowChanges :: CInt -> CInt -> CInt -> CInt -> CInt -> Window -> CInt -> WindowChanges
[wc_x] :: WindowChanges -> CInt
[wc_y] :: WindowChanges -> CInt
[wc_width] :: WindowChanges -> CInt
[wc_height] :: WindowChanges -> CInt
[wc_border_width] :: WindowChanges -> CInt
[wc_sibling] :: WindowChanges -> Window
[wc_stack_mode] :: WindowChanges -> CInt
data WindowAttributes
WindowAttributes :: CInt -> CInt -> CInt -> CInt -> CInt -> Colormap -> Bool -> CInt -> EventMask -> EventMask -> EventMask -> Bool -> WindowAttributes
[wa_x] :: WindowAttributes -> CInt
[wa_y] :: WindowAttributes -> CInt
[wa_width] :: WindowAttributes -> CInt
[wa_height] :: WindowAttributes -> CInt
[wa_border_width] :: WindowAttributes -> CInt
[wa_colormap] :: WindowAttributes -> Colormap
[wa_map_installed] :: WindowAttributes -> Bool
[wa_map_state] :: WindowAttributes -> CInt
[wa_all_event_masks] :: WindowAttributes -> EventMask
[wa_your_event_mask] :: WindowAttributes -> EventMask
[wa_do_not_propagate_mask] :: WindowAttributes -> EventMask
[wa_override_redirect] :: WindowAttributes -> Bool
data TextProperty
TextProperty :: CString -> Atom -> CInt -> Word64 -> TextProperty
[tp_value] :: TextProperty -> CString
[tp_encoding] :: TextProperty -> Atom
[tp_format] :: TextProperty -> CInt
[tp_nitems] :: TextProperty -> Word64
newtype FontSet
FontSet :: Ptr FontSet -> FontSet
data SizeHints
SizeHints :: Maybe (Dimension, Dimension) -> Maybe (Dimension, Dimension) -> Maybe (Dimension, Dimension) -> Maybe ((Dimension, Dimension), (Dimension, Dimension)) -> Maybe (Dimension, Dimension) -> Maybe BitGravity -> SizeHints
[sh_min_size] :: SizeHints -> Maybe (Dimension, Dimension)
[sh_max_size] :: SizeHints -> Maybe (Dimension, Dimension)
[sh_resize_inc] :: SizeHints -> Maybe (Dimension, Dimension)
[sh_aspect] :: SizeHints -> Maybe ((Dimension, Dimension), (Dimension, Dimension))
[sh_base_size] :: SizeHints -> Maybe (Dimension, Dimension)
[sh_win_gravity] :: SizeHints -> Maybe BitGravity
data ClassHint
ClassHint :: String -> String -> ClassHint
[resName] :: ClassHint -> String
[resClass] :: ClassHint -> String
data WMHints
WMHints :: CLong -> Bool -> CInt -> Pixmap -> Window -> CInt -> CInt -> Pixmap -> XID -> WMHints
[wmh_flags] :: WMHints -> CLong
[wmh_input] :: WMHints -> Bool
[wmh_initial_state] :: WMHints -> CInt
[wmh_icon_pixmap] :: WMHints -> Pixmap
[wmh_icon_window] :: WMHints -> Window
[wmh_icon_x] :: WMHints -> CInt
[wmh_icon_y] :: WMHints -> CInt
[wmh_icon_mask] :: WMHints -> Pixmap
[wmh_window_group] :: WMHints -> XID
type XErrorEventPtr = Ptr ()
type CXErrorHandler = Display -> XErrorEventPtr -> IO CInt
type XErrorHandler = Display -> XErrorEventPtr -> IO ()
data ErrorEvent
ErrorEvent :: !CInt -> Display -> !CULong -> !CUChar -> !CUChar -> !CUChar -> !XID -> ErrorEvent
[ev_type] :: ErrorEvent -> !CInt
[ev_display] :: ErrorEvent -> Display
[ev_serialnum] :: ErrorEvent -> !CULong
[ev_error_code] :: ErrorEvent -> !CUChar
[ev_request_code] :: ErrorEvent -> !CUChar
[ev_minor_code] :: ErrorEvent -> !CUChar
[ev_resourceid] :: ErrorEvent -> !XID

-- | interface to the X11 library function <tt>XRestackWindows()</tt>.
restackWindows :: Display -> [Window] -> IO ()

-- | interface to the X11 library function <tt>XWithdrawWindow()</tt>.
withdrawWindow :: Display -> Window -> ScreenNumber -> IO ()

-- | interface to the X11 library function <tt>XIconifyWindow()</tt>.
iconifyWindow :: Display -> Window -> ScreenNumber -> IO ()

-- | interface to the X11 library function
--   <tt>XTranslateCoordinates()</tt>.
translateCoordinates :: Display -> Window -> Window -> Position -> Position -> IO (Bool, Position, Position, Window)

-- | interface to the X11 library function <tt>XStoreName()</tt>.
storeName :: Display -> Window -> String -> IO ()

-- | interface to the X11 library function <tt>XCreateSimpleWindow()</tt>.
createSimpleWindow :: Display -> Window -> Position -> Position -> Dimension -> Dimension -> CInt -> Pixel -> Pixel -> IO Window

-- | interface to the X11 library function <tt>XCreateWindow()</tt>.
createWindow :: Display -> Window -> Position -> Position -> Dimension -> Dimension -> CInt -> CInt -> WindowClass -> Visual -> AttributeMask -> Ptr SetWindowAttributes -> IO Window

-- | interface to the X11 library function <tt>XMoveResizeWindow()</tt>.
moveResizeWindow :: Display -> Window -> Position -> Position -> Dimension -> Dimension -> IO ()

-- | interface to the X11 library function <tt>XResizeWindow()</tt>.
resizeWindow :: Display -> Window -> Dimension -> Dimension -> IO ()

-- | interface to the X11 library function <tt>XMoveWindow()</tt>.
moveWindow :: Display -> Window -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XReparentWindow()</tt>.
reparentWindow :: Display -> Window -> Window -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XMapSubwindows()</tt>.
mapSubwindows :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XUnmapSubwindows()</tt>.
unmapSubwindows :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XMapWindow()</tt>.
mapWindow :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XLowerWindow()</tt>.
lowerWindow :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XRaiseWindow()</tt>.
raiseWindow :: Display -> Window -> IO ()

-- | interface to the X11 library function
--   <tt>XCirculateSubwindowsDown()</tt>.
circulateSubwindowsDown :: Display -> Window -> IO ()

-- | interface to the X11 library function
--   <tt>XCirculateSubwindowsUp()</tt>.
circulateSubwindowsUp :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XCirculateSubwindows()</tt>.
circulateSubwindows :: Display -> Window -> CirculationDirection -> IO ()

-- | interface to the X11 library function <tt>XDestroyWindow()</tt>.
destroyWindow :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XDestroySubwindows()</tt>.
destroySubwindows :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XSetWindowBorder()</tt>.
setWindowBorder :: Display -> Window -> Pixel -> IO ()

-- | interface to the X11 library function
--   <tt>XSetWindowBorderPixmap()</tt>.
setWindowBorderPixmap :: Display -> Window -> Pixmap -> IO ()

-- | interface to the X11 library function
--   <tt>XSetWindowBorderWidth()</tt>.
setWindowBorderWidth :: Display -> Window -> Dimension -> IO ()

-- | interface to the X11 library function <tt>XSetWindowBackground()</tt>.
setWindowBackground :: Display -> Window -> Pixel -> IO ()

-- | interface to the X11 library function
--   <tt>XSetWindowBackgroundPixmap()</tt>.
setWindowBackgroundPixmap :: Display -> Window -> Pixmap -> IO ()

-- | interface to the X11 library function <tt>XSetWindowColormap()</tt>.
setWindowColormap :: Display -> Window -> Colormap -> IO ()

-- | interface to the X11 library function <tt>XAddToSaveSet()</tt>.
addToSaveSet :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XRemoveFromSaveSet()</tt>.
removeFromSaveSet :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XChangeSaveSet()</tt>.
changeSaveSet :: Display -> Window -> ChangeSaveSetMode -> IO ()

-- | interface to the X11 library function <tt>XClearWindow()</tt>.
clearWindow :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XClearArea()</tt>.
clearArea :: Display -> Window -> Position -> Position -> Dimension -> Dimension -> Bool -> IO ()

-- | interface to the X11 library function <tt>XSetTextProperty()</tt>.
setTextProperty :: Display -> Window -> String -> Atom -> IO ()

-- | interface to the X11 library function <tt>XRotateBuffers()</tt>.
rotateBuffers :: Display -> CInt -> IO ()

-- | interface to the X11 library function <tt>XFetchBytes()</tt>.
fetchBytes :: Display -> IO String

-- | interface to the X11 library function <tt>XFetchBuffer()</tt>.
fetchBuffer :: Display -> CInt -> IO String

-- | interface to the X11 library function <tt>XStoreBytes()</tt>.
storeBytes :: Display -> String -> IO ()

-- | interface to the X11 library function <tt>XStoreBuffer()</tt>.
storeBuffer :: Display -> String -> CInt -> IO ()

-- | interface to the X11 library function <tt>XDrawImageString()</tt>.
drawImageString :: Display -> Drawable -> GC -> Position -> Position -> String -> IO ()

-- | interface to the X11 library function <tt>XDrawString()</tt>.
drawString :: Display -> Drawable -> GC -> Position -> Position -> String -> IO ()

-- | interface to the X11 library function <tt>XFillArcs()</tt>.
fillArcs :: Display -> Drawable -> GC -> [Arc] -> IO ()

-- | interface to the X11 library function <tt>XFillPolygon()</tt>.
fillPolygon :: Display -> Drawable -> GC -> [Point] -> PolygonShape -> CoordinateMode -> IO ()

-- | interface to the X11 library function <tt>XFillRectangles()</tt>.
fillRectangles :: Display -> Drawable -> GC -> [Rectangle] -> IO ()

-- | interface to the X11 library function <tt>XDrawArcs()</tt>.
drawArcs :: Display -> Drawable -> GC -> [Arc] -> IO ()

-- | interface to the X11 library function <tt>XDrawRectangles()</tt>.
drawRectangles :: Display -> Drawable -> GC -> [Rectangle] -> IO ()

-- | interface to the X11 library function <tt>XDrawSegments()</tt>.
drawSegments :: Display -> Drawable -> GC -> [Segment] -> IO ()

-- | interface to the X11 library function <tt>XDrawLines()</tt>.
drawLines :: Display -> Drawable -> GC -> [Point] -> CoordinateMode -> IO ()

-- | interface to the X11 library function <tt>XDrawPoints()</tt>.
drawPoints :: Display -> Drawable -> GC -> [Point] -> CoordinateMode -> IO ()
set_cursor :: Ptr SetWindowAttributes -> Cursor -> IO ()
set_colormap :: Ptr SetWindowAttributes -> Colormap -> IO ()
set_override_redirect :: Ptr SetWindowAttributes -> Bool -> IO ()
set_do_not_propagate_mask :: Ptr SetWindowAttributes -> EventMask -> IO ()
set_event_mask :: Ptr SetWindowAttributes -> EventMask -> IO ()
set_save_under :: Ptr SetWindowAttributes -> Bool -> IO ()
set_backing_pixel :: Ptr SetWindowAttributes -> Pixel -> IO ()
set_backing_planes :: Ptr SetWindowAttributes -> Pixel -> IO ()
set_backing_store :: Ptr SetWindowAttributes -> BackingStore -> IO ()
set_win_gravity :: Ptr SetWindowAttributes -> WindowGravity -> IO ()
set_bit_gravity :: Ptr SetWindowAttributes -> BitGravity -> IO ()
set_border_pixel :: Ptr SetWindowAttributes -> Pixel -> IO ()
set_border_pixmap :: Ptr SetWindowAttributes -> Pixmap -> IO ()
set_background_pixel :: Ptr SetWindowAttributes -> Pixel -> IO ()
set_background_pixmap :: Ptr SetWindowAttributes -> Pixmap -> IO ()
allocaSetWindowAttributes :: (Ptr SetWindowAttributes -> IO a) -> IO a

-- | interface to the X11 library function <tt>XSetWMProtocols()</tt>.
setWMProtocols :: Display -> Window -> [Atom] -> IO ()

-- | interface to the X11 library function <tt>XRecolorCursor()</tt>.
recolorCursor :: Display -> Cursor -> Color -> Color -> IO ()

-- | interface to the X11 library function <tt>XCreateGlyphCursor()</tt>.
createGlyphCursor :: Display -> Font -> Font -> Glyph -> Glyph -> Color -> Color -> IO Cursor

-- | interface to the X11 library function <tt>XCreatePixmapCursor()</tt>.
createPixmapCursor :: Display -> Pixmap -> Pixmap -> Color -> Color -> Dimension -> Dimension -> IO Cursor

-- | interface to the X11 library function <tt>XSetIconName()</tt>.
setIconName :: Display -> Window -> String -> IO ()

-- | interface to the X11 library function <tt>XGetIconName()</tt>.
getIconName :: Display -> Window -> IO String

-- | interface to the X11 library function <tt>XLookupString()</tt>.
lookupString :: XKeyEventPtr -> IO (Maybe KeySym, String)
noSymbol :: KeySym

-- | interface to the X11 library function <tt>XStringToKeysym()</tt>.
stringToKeysym :: String -> KeySym

-- | interface to the X11 library function <tt>XKeysymToString()</tt>.
keysymToString :: KeySym -> String

-- | interface to the X11 library function <tt>XDisplayKeycodes()</tt>.
displayKeycodes :: Display -> (CInt, CInt)

-- | interface to the X11 library function <tt>XReadBitmapFile</tt>.
readBitmapFile :: Display -> Drawable -> String -> IO (Either String (Dimension, Dimension, Pixmap, Maybe CInt, Maybe CInt))

-- | interface to the X11 library function <tt>XMatchVisualInfo()</tt>
matchVisualInfo :: Display -> ScreenNumber -> CInt -> CInt -> IO (Maybe VisualInfo)
getVisualInfo :: Display -> VisualInfoMask -> VisualInfo -> IO [VisualInfo]
visualAllMask :: VisualInfoMask
visualBitsPerRGBMask :: VisualInfoMask
visualColormapSizeMask :: VisualInfoMask

-- | interface to the X11 library function <tt>XGetVisualInfo()</tt>
visualBlueMaskMask :: VisualInfoMask
visualGreenMaskMask :: VisualInfoMask
visualRedMaskMask :: VisualInfoMask
visualClassMask :: VisualInfoMask
visualDepthMask :: VisualInfoMask
visualScreenMask :: VisualInfoMask
visualIDMask :: VisualInfoMask
visualNoMask :: VisualInfoMask

-- | interface to the X11 library function <tt>XGetPointerControl()</tt>.
getPointerControl :: Display -> IO (CInt, CInt, CInt)
getScreenSaver :: Display -> IO (CInt, CInt, PreferBlankingMode, AllowExposuresMode)
screenSaverReset :: ScreenSaverMode
screenSaverActive :: ScreenSaverMode
defaultBlanking :: PreferBlankingMode
preferBlanking :: PreferBlankingMode
dontPreferBlanking :: PreferBlankingMode
defaultExposures :: AllowExposuresMode
allowExposures :: AllowExposuresMode
dontAllowExposures :: AllowExposuresMode

-- | interface to the X11 library function <tt>XSetLocaleModifiers()</tt>.
setLocaleModifiers :: String -> IO String

-- | interface to the X11 library function <tt>XGetGeometry()</tt>.
getGeometry :: Display -> Drawable -> IO (Window, Position, Position, Dimension, Dimension, Dimension, CInt)

-- | interface to the X11 library function <tt>XGeometry()</tt>.
geometry :: Display -> CInt -> String -> String -> Dimension -> Dimension -> Dimension -> CInt -> CInt -> IO (CInt, Position, Position, Dimension, Dimension)

-- | The Xlib library reports most errors by invoking a user-provided error
--   handler. This function installs an error handler that prints a textual
--   representation of the error.
setDefaultErrorHandler :: IO ()

-- | interface to the X11 library function <tt>XDisplayName()</tt>.
displayName :: String -> String

-- | interface to the X11 library function <tt>XQueryPointer()</tt>.
queryPointer :: Display -> Window -> IO (Bool, Window, Window, CInt, CInt, CInt, CInt, Modifier)

-- | interface to the X11 library function <tt>XQueryBestSize()</tt>.
queryBestSize :: Display -> QueryBestSizeClass -> Drawable -> Dimension -> Dimension -> IO (Dimension, Dimension)

-- | interface to the X11 library function <tt>XQueryBestCursor()</tt>.
queryBestCursor :: Display -> Drawable -> Dimension -> Dimension -> IO (Dimension, Dimension)

-- | interface to the X11 library function <tt>XQueryBestStipple()</tt>.
queryBestStipple :: Display -> Drawable -> Dimension -> Dimension -> IO (Dimension, Dimension)

-- | interface to the X11 library function <tt>XQueryBestTile()</tt>.
queryBestTile :: Display -> Drawable -> Dimension -> Dimension -> IO (Dimension, Dimension)

-- | interface to the X11 library function <tt>XGetInputFocus()</tt>.
getInputFocus :: Display -> IO (Window, FocusMode)

-- | interface to the X11 library function <tt>XrmInitialize()</tt>.
rmInitialize :: IO ()

-- | interface to the X11 library function <tt>XAutoRepeatOff()</tt>.
autoRepeatOff :: Display -> IO ()

-- | interface to the X11 library function <tt>XAutoRepeatOn()</tt>.
autoRepeatOn :: Display -> IO ()

-- | interface to the X11 library function <tt>XBell()</tt>.
bell :: Display -> CInt -> IO ()

-- | interface to the X11 library function <tt>XSetCloseDownMode()</tt>.
setCloseDownMode :: Display -> CloseDownMode -> IO ()

-- | interface to the X11 library function
--   <tt>XLastKnownRequestProcessed()</tt>.
lastKnownRequestProcessed :: Display -> IO CInt

-- | interface to the X11 library function <tt>XSetInputFocus()</tt>.
setInputFocus :: Display -> Window -> FocusMode -> Time -> IO ()

-- | interface to the X11 library function <tt>XGrabButton()</tt>.
grabButton :: Display -> Button -> ButtonMask -> Window -> Bool -> EventMask -> GrabMode -> GrabMode -> Window -> Cursor -> IO ()

-- | interface to the X11 library function <tt>XUngrabButton()</tt>.
ungrabButton :: Display -> Button -> ButtonMask -> Window -> IO ()

-- | interface to the X11 library function <tt>XGrabPointer()</tt>.
grabPointer :: Display -> Window -> Bool -> EventMask -> GrabMode -> GrabMode -> Window -> Cursor -> Time -> IO GrabStatus

-- | interface to the X11 library function <tt>XUngrabPointer()</tt>.
ungrabPointer :: Display -> Time -> IO ()

-- | interface to the X11 library function <tt>XGrabKey()</tt>.
grabKey :: Display -> KeyCode -> KeyMask -> Window -> Bool -> GrabMode -> GrabMode -> IO ()

-- | interface to the X11 library function <tt>XUngrabKey()</tt>.
ungrabKey :: Display -> KeyCode -> KeyMask -> Window -> IO ()

-- | interface to the X11 library function <tt>XGrabKeyboard()</tt>.
grabKeyboard :: Display -> Window -> Bool -> GrabMode -> GrabMode -> Time -> IO GrabStatus

-- | interface to the X11 library function <tt>XUngrabKeyboard()</tt>.
ungrabKeyboard :: Display -> Time -> IO ()

-- | interface to the X11 library function <tt>XGrabServer()</tt>.
grabServer :: Display -> IO ()

-- | interface to the X11 library function <tt>XUngrabServer()</tt>.
ungrabServer :: Display -> IO ()

-- | interface to the X11 library function <tt>XSupportsLocale()</tt>.
supportsLocale :: IO Bool

-- | interface to the X11 library function <tt>XSetScreenSaver()</tt>.
setScreenSaver :: Display -> CInt -> CInt -> PreferBlankingMode -> AllowExposuresMode -> IO ()

-- | interface to the X11 library function <tt>XActivateScreenSaver()</tt>.
activateScreenSaver :: Display -> IO ()

-- | interface to the X11 library function <tt>XResetScreenSaver()</tt>.
resetScreenSaver :: Display -> IO ()

-- | interface to the X11 library function <tt>XForceScreenSaver()</tt>.
forceScreenSaver :: Display -> ScreenSaverMode -> IO ()

-- | interface to the X11 library function <tt>XWarpPointer()</tt>.
warpPointer :: Display -> Window -> Window -> Position -> Position -> Dimension -> Dimension -> Position -> Position -> IO ()

-- | see <tt>XVisualIDFromVisual()</tt>
visualIDFromVisual :: Visual -> IO VisualID
initThreads :: IO Status
lockDisplay :: Display -> IO ()
unlockDisplay :: Display -> IO ()

-- | interface to the X11 library function <tt>XCreatePixmap()</tt>.
createPixmap :: Display -> Drawable -> Dimension -> Dimension -> CInt -> IO Pixmap

-- | interface to the X11 library function <tt>XFreePixmap()</tt>.
freePixmap :: Display -> Pixmap -> IO ()

-- | interface to the X11 library function <tt>XBitmapBitOrder()</tt>.
bitmapBitOrder :: Display -> ByteOrder

-- | interface to the X11 library function <tt>XBitmapUnit()</tt>.
bitmapUnit :: Display -> CInt

-- | interface to the X11 library function <tt>XBitmapPad()</tt>.
bitmapPad :: Display -> CInt

-- | interface to the X11 library function <tt>XLookupKeysym()</tt>.
lookupKeysym :: XKeyEventPtr -> CInt -> IO KeySym

-- | interface to the X11 library function <tt>XKeycodeToKeysym()</tt>.
keycodeToKeysym :: Display -> KeyCode -> CInt -> IO KeySym

-- | interface to the X11 library function <tt>XKeysymToKeycode()</tt>.
keysymToKeycode :: Display -> KeySym -> IO KeyCode

-- | interface to the X11 library function <tt>XDefineCursor()</tt>.
defineCursor :: Display -> Window -> Cursor -> IO ()

-- | interface to the X11 library function <tt>XUndefineCursor()</tt>.
undefineCursor :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XCreateFontCursor()</tt>.
createFontCursor :: Display -> Glyph -> IO Cursor

-- | interface to the X11 library function <tt>XFreeCursor()</tt>.
freeCursor :: Display -> Font -> IO ()

-- | interface to the X11 library function <tt>XDrawPoint()</tt>.
drawPoint :: Display -> Drawable -> GC -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XDrawLine()</tt>.
drawLine :: Display -> Drawable -> GC -> Position -> Position -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XDrawRectangle()</tt>.
drawRectangle :: Display -> Drawable -> GC -> Position -> Position -> Dimension -> Dimension -> IO ()

-- | interface to the X11 library function <tt>XDrawArc()</tt>.
drawArc :: Display -> Drawable -> GC -> Position -> Position -> Dimension -> Dimension -> Angle -> Angle -> IO ()

-- | interface to the X11 library function <tt>XFillRectangle()</tt>.
fillRectangle :: Display -> Drawable -> GC -> Position -> Position -> Dimension -> Dimension -> IO ()

-- | interface to the X11 library function <tt>XFillArc()</tt>.
fillArc :: Display -> Drawable -> GC -> Position -> Position -> Dimension -> Dimension -> Angle -> Angle -> IO ()

-- | interface to the X11 library function <tt>XCopyArea()</tt>.
copyArea :: Display -> Drawable -> Drawable -> GC -> Position -> Position -> Dimension -> Dimension -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XCopyPlane()</tt>.
copyPlane :: Display -> Drawable -> Drawable -> GC -> Position -> Position -> Dimension -> Dimension -> Position -> Position -> Pixel -> IO ()
type AllowExposuresMode = CInt
type PreferBlankingMode = CInt
type ScreenSaverMode = CInt
type VisualInfoMask = CLong
lAST_PREDEFINED :: Atom
wM_TRANSIENT_FOR :: Atom
wM_CLASS :: Atom
cAP_HEIGHT :: Atom
fULL_NAME :: Atom
fAMILY_NAME :: Atom
fONT_NAME :: Atom
nOTICE :: Atom
cOPYRIGHT :: Atom
rESOLUTION :: Atom
pOINT_SIZE :: Atom
wEIGHT :: Atom
qUAD_WIDTH :: Atom
x_HEIGHT :: Atom
iTALIC_ANGLE :: Atom
sTRIKEOUT_DESCENT :: Atom
sTRIKEOUT_ASCENT :: Atom
uNDERLINE_THICKNESS :: Atom
uNDERLINE_POSITION :: Atom
sUBSCRIPT_Y :: Atom
sUBSCRIPT_X :: Atom
sUPERSCRIPT_Y :: Atom
sUPERSCRIPT_X :: Atom
eND_SPACE :: Atom
mAX_SPACE :: Atom
nORM_SPACE :: Atom
mIN_SPACE :: Atom
wM_ZOOM_HINTS :: Atom
wM_SIZE_HINTS :: Atom
wM_NORMAL_HINTS :: Atom
wM_NAME :: Atom
wM_ICON_SIZE :: Atom
wM_ICON_NAME :: Atom
wM_CLIENT_MACHINE :: Atom
wM_HINTS :: Atom
wM_COMMAND :: Atom
wINDOW :: Atom
vISUALID :: Atom
sTRING :: Atom
rGB_RED_MAP :: Atom
rGB_GREEN_MAP :: Atom
rGB_GRAY_MAP :: Atom
rGB_DEFAULT_MAP :: Atom
rGB_BLUE_MAP :: Atom
rGB_BEST_MAP :: Atom
rGB_COLOR_MAP :: Atom
rESOURCE_MANAGER :: Atom
rECTANGLE :: Atom
pOINT :: Atom
pIXMAP :: Atom
iNTEGER :: Atom
fONT :: Atom
dRAWABLE :: Atom
cUT_BUFFER7 :: Atom
cUT_BUFFER6 :: Atom
cUT_BUFFER5 :: Atom
cUT_BUFFER4 :: Atom
cUT_BUFFER3 :: Atom
cUT_BUFFER2 :: Atom
cUT_BUFFER1 :: Atom
cUT_BUFFER0 :: Atom
cURSOR :: Atom
cOLORMAP :: Atom
cARDINAL :: Atom
bITMAP :: Atom
aTOM :: Atom
aRC :: Atom
sECONDARY :: Atom
pRIMARY :: Atom
getAtomNames :: Display -> [Atom] -> IO [String]
getAtomName :: Display -> Atom -> IO (Maybe String)

-- | interface to the X11 library function <tt>XInternAtom()</tt>.
internAtom :: Display -> String -> Bool -> IO Atom

-- | interface to the X11 library function <tt>XQueryColors()</tt>.
queryColors :: Display -> Colormap -> [Color] -> IO [Color]

-- | interface to the X11 library function <tt>XQueryColor()</tt>.
queryColor :: Display -> Colormap -> Color -> IO Color

-- | interface to the X11 library function <tt>XStoreColor()</tt>.
storeColor :: Display -> Colormap -> Color -> IO ()

-- | interface to the X11 library function <tt>XFreeColors()</tt>.
freeColors :: Display -> Colormap -> [Pixel] -> Pixel -> IO ()

-- | interface to the X11 library function <tt>XParseColor()</tt>.
parseColor :: Display -> Colormap -> String -> IO Color

-- | interface to the X11 library function <tt>XAllocColor()</tt>.
allocColor :: Display -> Colormap -> Color -> IO Color

-- | interface to the X11 library function <tt>XAllocNamedColor()</tt>.
allocNamedColor :: Display -> Colormap -> String -> IO (Color, Color)

-- | interface to the X11 library function <tt>XLookupColor()</tt>.
lookupColor :: Display -> Colormap -> String -> IO (Color, Color)

-- | interface to the X11 library function <tt>XInstallColormap()</tt>.
installColormap :: Display -> Colormap -> IO ()

-- | interface to the X11 library function <tt>XUninstallColormap()</tt>.
uninstallColormap :: Display -> Colormap -> IO ()

-- | interface to the X11 library function <tt>XCopyColormapAndFree()</tt>.
copyColormapAndFree :: Display -> Colormap -> IO Colormap

-- | interface to the X11 library function <tt>XCreateColormap()</tt>.
createColormap :: Display -> Window -> Visual -> ColormapAlloc -> IO Colormap

-- | interface to the X11 library function <tt>XFreeColormap()</tt>.
freeColormap :: Display -> Colormap -> IO ()

-- | partial interface to the X11 library function <tt>XCreateGC()</tt>.
createGC :: Display -> Drawable -> IO GC

-- | interface to the X11 library function <tt>XSetDashes()</tt>.
setDashes :: Display -> GC -> CInt -> String -> CInt -> IO ()

-- | interface to the X11 library function <tt>XSetArcMode()</tt>.
setArcMode :: Display -> GC -> ArcMode -> IO ()

-- | interface to the X11 library function <tt>XSetBackground()</tt>.
setBackground :: Display -> GC -> Pixel -> IO ()

-- | interface to the X11 library function <tt>XSetForeground()</tt>.
setForeground :: Display -> GC -> Pixel -> IO ()

-- | interface to the X11 library function <tt>XSetFunction()</tt>.
setFunction :: Display -> GC -> GXFunction -> IO ()

-- | interface to the X11 library function
--   <tt>XSetGraphicsExposures()</tt>.
setGraphicsExposures :: Display -> GC -> Bool -> IO ()

-- | interface to the X11 library function <tt>XSetClipMask()</tt>.
setClipMask :: Display -> GC -> Pixmap -> IO ()

-- | interface to the X11 library function <tt>XSetClipOrigin()</tt>.
setClipOrigin :: Display -> GC -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XSetFillRule()</tt>.
setFillRule :: Display -> GC -> FillRule -> IO ()

-- | interface to the X11 library function <tt>XSetFillStyle()</tt>.
setFillStyle :: Display -> GC -> FillStyle -> IO ()

-- | interface to the X11 library function <tt>XSetFont()</tt>.
setFont :: Display -> GC -> Font -> IO ()

-- | interface to the X11 library function <tt>XSetLineAttributes()</tt>.
setLineAttributes :: Display -> GC -> CInt -> LineStyle -> CapStyle -> JoinStyle -> IO ()

-- | interface to the X11 library function <tt>XSetPlaneMask()</tt>.
setPlaneMask :: Display -> GC -> Pixel -> IO ()

-- | interface to the X11 library function <tt>XSetState()</tt>.
setState :: Display -> GC -> Pixel -> Pixel -> GXFunction -> Pixel -> IO ()

-- | interface to the X11 library function <tt>XSetStipple()</tt>.
setStipple :: Display -> GC -> Pixmap -> IO ()

-- | interface to the X11 library function <tt>XSetSubwindowMode()</tt>.
setSubwindowMode :: Display -> GC -> SubWindowMode -> IO ()

-- | interface to the X11 library function <tt>XSetTSOrigin()</tt>.
setTSOrigin :: Display -> GC -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XSetTile()</tt>.
setTile :: Display -> GC -> Pixmap -> IO ()

-- | interface to the X11 library function <tt>XGContextFromGC()</tt>.
gContextFromGC :: GC -> GContext

-- | interface to the X11 library function <tt>XFreeGC()</tt>.
freeGC :: Display -> GC -> IO ()

-- | interface to the X11 library function <tt>XFlushGC()</tt>.
flushGC :: Display -> GC -> IO ()

-- | interface to the X11 library function <tt>XCopyGC()</tt>.
copyGC :: Display -> GC -> Mask -> GC -> IO ()

-- | interface to the X11 library function <tt>XSendEvent()</tt>.
sendEvent :: Display -> Window -> Bool -> EventMask -> XEventPtr -> IO ()

-- | This function is somewhat compatible with Win32's
--   <tt>TimeGetTime()</tt>
gettimeofday_in_milliseconds :: IO Integer

-- | Reads an event with a timeout (in microseconds). Returns True if
--   timeout occurs.
waitForEvent :: Display -> Word32 -> IO Bool
get_ConfigureEvent :: XEventPtr -> IO XConfigureEvent
get_ExposeEvent :: XEventPtr -> IO XExposeEvent
get_MotionEvent :: XEventPtr -> IO XMotionEvent
get_ButtonEvent :: XEventPtr -> IO XButtonEvent
asKeyEvent :: XEventPtr -> XKeyEventPtr
get_KeyEvent :: XEventPtr -> IO XKeyEvent
get_Window :: XEventPtr -> IO Window
get_EventType :: XEventPtr -> IO EventType
allocaXEvent :: (XEventPtr -> IO a) -> IO a
queuedAfterReading :: QueuedMode
queuedAfterFlush :: QueuedMode
queuedAlready :: QueuedMode

-- | interface to the X11 library function <tt>XFlush()</tt>.
flush :: Display -> IO ()

-- | interface to the X11 library function <tt>XSync()</tt>.
sync :: Display -> Bool -> IO ()

-- | interface to the X11 library function <tt>XPending()</tt>.
pending :: Display -> IO CInt

-- | interface to the X11 library function <tt>XEventsQueued()</tt>.
eventsQueued :: Display -> QueuedMode -> IO CInt

-- | interface to the X11 library function <tt>XNextEvent()</tt>.
nextEvent :: Display -> XEventPtr -> IO ()

-- | interface to the X11 library function <tt>XAllowEvents()</tt>.
allowEvents :: Display -> AllowEvents -> Time -> IO ()

-- | interface to the X11 library function <tt>XSelectInput()</tt>.
selectInput :: Display -> Window -> EventMask -> IO ()

-- | interface to the X11 library function <tt>XWindowEvent()</tt>.
windowEvent :: Display -> Window -> EventMask -> XEventPtr -> IO ()

-- | interface to the X11 library function <tt>XCheckWindowEvent()</tt>.
checkWindowEvent :: Display -> Window -> EventMask -> XEventPtr -> IO Bool

-- | interface to the X11 library function <tt>XMaskEvent()</tt>.
maskEvent :: Display -> EventMask -> XEventPtr -> IO ()

-- | interface to the X11 library function <tt>XCheckMaskEvent()</tt>.
checkMaskEvent :: Display -> EventMask -> XEventPtr -> IO Bool

-- | interface to the X11 library function <tt>XCheckTypedEvent()</tt>.
checkTypedEvent :: Display -> EventType -> XEventPtr -> IO Bool

-- | interface to the X11 library function
--   <tt>XCheckTypedWindowEvent()</tt>.
checkTypedWindowEvent :: Display -> Window -> EventType -> XEventPtr -> IO Bool

-- | interface to the X11 library function <tt>XPutBackEvent()</tt>.
putBackEvent :: Display -> XEventPtr -> IO ()

-- | interface to the X11 library function <tt>XPeekEvent()</tt>.
peekEvent :: Display -> XEventPtr -> IO ()
type QueuedMode = CInt
newtype XEvent
XEvent :: XEventPtr -> XEvent
type XEventPtr = Ptr XEvent
type XKeyEvent = (Window, Window, Time, CInt, CInt, CInt, CInt, Modifier, KeyCode, Bool)
type XKeyEventPtr = Ptr XKeyEvent
type XButtonEvent = (Window, Window, Time, CInt, CInt, CInt, CInt, Modifier, Button, Bool)
type XMotionEvent = (Window, Window, Time, CInt, CInt, CInt, CInt, Modifier, NotifyMode, Bool)
type XExposeEvent = (Position, Position, Dimension, Dimension, CInt)
type XMappingEvent = (MappingRequest, KeyCode, CInt)
type XConfigureEvent = (Position, Position, Dimension, Dimension)

-- | interface to the X11 library function <tt>XOpenDisplay()</tt>.
openDisplay :: String -> IO Display

-- | interface to the X11 library function <tt>XServerVendor()</tt>.
serverVendor :: Display -> String

-- | interface to the X11 library function <tt>XDisplayString()</tt>.
displayString :: Display -> String

-- | interface to the X11 library function
--   <tt>XScreenResourceString()</tt>.
screenResourceString :: Screen -> String

-- | interface to the X11 library function
--   <tt>XResourceManagerString()</tt>.
resourceManagerString :: Display -> String

-- | interface to the X11 library function <tt>XAllPlanes()</tt>.
allPlanes_aux :: Pixel

-- | interface to the X11 library function <tt>XBlackPixel()</tt>.
blackPixel :: Display -> ScreenNumber -> Pixel

-- | interface to the X11 library function <tt>XWhitePixel()</tt>.
whitePixel :: Display -> ScreenNumber -> Pixel

-- | interface to the X11 library function <tt>XConnectionNumber()</tt>.
connectionNumber :: Display -> CInt

-- | interface to the X11 library function <tt>XDefaultColormap()</tt>.
defaultColormap :: Display -> ScreenNumber -> Colormap

-- | interface to the X11 library function <tt>XDefaultGC()</tt>.
defaultGC :: Display -> ScreenNumber -> GC

-- | interface to the X11 library function <tt>XDefaultDepth()</tt>.
defaultDepth :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XDefaultScreen()</tt>.
defaultScreen :: Display -> ScreenNumber

-- | interface to the X11 library function
--   <tt>XDefaultScreenOfDisplay()</tt>.
defaultScreenOfDisplay :: Display -> Screen

-- | interface to the X11 library function <tt>XDisplayHeight()</tt>.
displayHeight :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XDisplayHeightMM()</tt>.
displayHeightMM :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XDisplayWidth()</tt>.
displayWidth :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XDisplayWidthMM()</tt>.
displayWidthMM :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XMaxRequestSize()</tt>.
maxRequestSize :: Display -> CInt

-- | interface to the X11 library function
--   <tt>XDisplayMotionBufferSize()</tt>.
displayMotionBufferSize :: Display -> CInt

-- | interface to the X11 library function <tt>XImageByteOrder()</tt>.
imageByteOrder :: Display -> CInt

-- | interface to the X11 library function <tt>XProtocolRevision()</tt>.
protocolRevision :: Display -> CInt

-- | interface to the X11 library function <tt>XProtocolVersion()</tt>.
protocolVersion :: Display -> CInt

-- | interface to the X11 library function <tt>XScreenCount()</tt>.
screenCount :: Display -> CInt

-- | interface to the X11 library function <tt>XDefaultVisual()</tt>.
defaultVisual :: Display -> ScreenNumber -> Visual

-- | interface to the X11 library function <tt>XDisplayCells()</tt>.
displayCells :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XDisplayPlanes()</tt>.
displayPlanes :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XScreenOfDisplay()</tt>.
screenOfDisplay :: Display -> ScreenNumber -> Screen

-- | interface to the X11 library function <tt>XDefaultRootWindow()</tt>.
defaultRootWindow :: Display -> Window

-- | interface to the X11 library function <tt>XRootWindow()</tt>.
rootWindow :: Display -> ScreenNumber -> IO Window

-- | interface to the X11 library function <tt>XQLength()</tt>.
qLength :: Display -> IO CInt

-- | interface to the X11 library function <tt>XNoOp()</tt>.
noOp :: Display -> IO ()

-- | interface to the X11 library function <tt>XCloseDisplay()</tt>.
closeDisplay :: Display -> IO ()
xC_xterm :: Glyph
xC_watch :: Glyph
xC_ur_angle :: Glyph
xC_umbrella :: Glyph
xC_ul_angle :: Glyph
xC_trek :: Glyph
xC_top_tee :: Glyph
xC_top_side :: Glyph
xC_top_right_corner :: Glyph
xC_top_left_corner :: Glyph
xC_top_left_arrow :: Glyph
xC_tcross :: Glyph
xC_target :: Glyph
xC_star :: Glyph
xC_spraycan :: Glyph
xC_spider :: Glyph
xC_sizing :: Glyph
xC_shuttle :: Glyph
xC_sb_v_double_arrow :: Glyph
xC_sb_up_arrow :: Glyph
xC_sb_right_arrow :: Glyph
xC_sb_left_arrow :: Glyph
xC_sb_h_double_arrow :: Glyph
xC_sb_down_arrow :: Glyph
xC_sailboat :: Glyph
xC_rtl_logo :: Glyph
xC_rightbutton :: Glyph
xC_right_tee :: Glyph
xC_right_side :: Glyph
xC_right_ptr :: Glyph
xC_question_arrow :: Glyph
xC_plus :: Glyph
xC_pirate :: Glyph
xC_pencil :: Glyph
xC_mouse :: Glyph
xC_man :: Glyph
xC_lr_angle :: Glyph
xC_ll_angle :: Glyph
xC_leftbutton :: Glyph
xC_left_tee :: Glyph
xC_left_side :: Glyph
xC_left_ptr :: Glyph
xC_iron_cross :: Glyph
xC_icon :: Glyph
xC_heart :: Glyph
xC_hand2 :: Glyph
xC_hand1 :: Glyph
xC_gumby :: Glyph
xC_gobbler :: Glyph
xC_fleur :: Glyph
xC_exchange :: Glyph
xC_draped_box :: Glyph
xC_draft_small :: Glyph
xC_draft_large :: Glyph
xC_double_arrow :: Glyph
xC_dotbox :: Glyph
xC_dot :: Glyph
xC_diamond_cross :: Glyph
xC_crosshair :: Glyph
xC_cross_reverse :: Glyph
xC_cross :: Glyph
xC_coffee_mug :: Glyph
xC_clock :: Glyph
xC_circle :: Glyph
xC_center_ptr :: Glyph
xC_box_spiral :: Glyph
xC_bottom_tee :: Glyph
xC_bottom_side :: Glyph
xC_bottom_right_corner :: Glyph
xC_bottom_left_corner :: Glyph
xC_bogosity :: Glyph
xC_boat :: Glyph
xC_based_arrow_up :: Glyph
xC_based_arrow_down :: Glyph
xC_arrow :: Glyph
xC_X_cursor :: Glyph

-- | interface to the X11 library function <tt>XTextWidth()</tt>.
textWidth :: FontStruct -> String -> Int32

-- | interface to the X11 library function <tt>XTextExtents()</tt>.
textExtents :: FontStruct -> String -> (FontDirection, Int32, Int32, CharStruct)
maxBoundsFromFontStruct :: FontStruct -> CharStruct
minBoundsFromFontStruct :: FontStruct -> CharStruct
descentFromFontStruct :: FontStruct -> Int32
ascentFromFontStruct :: FontStruct -> Int32
fontFromFontStruct :: FontStruct -> Font

-- | interface to the X11 library function <tt>XLoadQueryFont()</tt>.
loadQueryFont :: Display -> String -> IO FontStruct

-- | interface to the X11 library function <tt>XGetGCValues()</tt>.
fontFromGC :: Display -> GC -> IO Font

-- | interface to the X11 library function <tt>XQueryFont()</tt>.
queryFont :: Display -> Font -> IO FontStruct

-- | interface to the X11 library function <tt>XFreeFont()</tt>.
freeFont :: Display -> FontStruct -> IO ()
type Glyph = Word16

-- | pointer to an X11 <tt>XFontStruct</tt> structure
data FontStruct
type CharStruct = (CInt, CInt, CInt, CInt, CInt)

-- | interface to the X11 library function <tt>XGetPixel()</tt>.
getPixel :: Image -> CInt -> CInt -> CULong

-- | interface to the X11 library function <tt>XGetImage()</tt>.
getImage :: Display -> Drawable -> CInt -> CInt -> CUInt -> CUInt -> CULong -> ImageFormat -> IO Image

-- | interface to the X11 library function <tt>XCreateImage()</tt>.
createImage :: Display -> Visual -> CInt -> ImageFormat -> CInt -> Ptr CChar -> Dimension -> Dimension -> CInt -> CInt -> IO Image

-- | interface to the X11 library function <tt>XPutImage()</tt>.
putImage :: Display -> Drawable -> GC -> Image -> Position -> Position -> Position -> Position -> Dimension -> Dimension -> IO ()

-- | interface to the X11 library function <tt>XDestroyImage()</tt>.
destroyImage :: Image -> IO ()
xGetPixel :: Image -> CInt -> CInt -> IO CULong

-- | interface to the X11 library function <tt>XSetRegion()</tt>.
setRegion :: Display -> GC -> Region -> IO CInt

-- | interface to the X11 library function <tt>XShrinkRegion()</tt>.
shrinkRegion :: Region -> Point -> IO CInt

-- | interface to the X11 library function <tt>XOffsetRegion()</tt>.
offsetRegion :: Region -> Point -> IO CInt

-- | interface to the X11 library function <tt>XClipBox()</tt>.
clipBox :: Region -> IO (Rectangle, CInt)

-- | interface to the X11 library function <tt>XRectInRegion()</tt>.
rectInRegion :: Region -> Rectangle -> IO RectInRegionResult

-- | interface to the X11 library function <tt>XPointInRegion()</tt>.
pointInRegion :: Region -> Point -> IO Bool

-- | interface to the X11 library function <tt>XEqualRegion()</tt>.
equalRegion :: Region -> Region -> IO Bool

-- | interface to the X11 library function <tt>XEmptyRegion()</tt>.
emptyRegion :: Region -> IO Bool

-- | interface to the X11 library function <tt>XXorRegion()</tt>.
xorRegion :: Region -> Region -> Region -> IO CInt

-- | interface to the X11 library function <tt>XUnionRegion()</tt>.
unionRegion :: Region -> Region -> Region -> IO CInt

-- | interface to the X11 library function <tt>XUnionRectWithRegion()</tt>.
unionRectWithRegion :: Rectangle -> Region -> Region -> IO CInt

-- | interface to the X11 library function <tt>XSubtractRegion()</tt>.
subtractRegion :: Region -> Region -> Region -> IO CInt

-- | interface to the X11 library function <tt>XIntersectRegion()</tt>.
intersectRegion :: Region -> Region -> Region -> IO CInt

-- | interface to the X11 library function <tt>XPolygonRegion()</tt>.
polygonRegion :: [Point] -> FillRule -> IO Region

-- | interface to the X11 library function <tt>XCreateRegion()</tt>.
createRegion :: IO Region
rectanglePart :: RectInRegionResult
rectangleIn :: RectInRegionResult
rectangleOut :: RectInRegionResult
data Region
type RectInRegionResult = CInt

-- | interface to the X11 library function <tt>XBlackPixelOfScreen()</tt>.
blackPixelOfScreen :: Screen -> Pixel

-- | interface to the X11 library function <tt>XWhitePixelOfScreen()</tt>.
whitePixelOfScreen :: Screen -> Pixel

-- | interface to the X11 library function <tt>XCellsOfScreen()</tt>.
cellsOfScreen :: Screen -> CInt

-- | interface to the X11 library function
--   <tt>XDefaultColormapOfScreen()</tt>.
defaultColormapOfScreen :: Screen -> Colormap

-- | interface to the X11 library function
--   <tt>XDefaultDepthOfScreen()</tt>.
defaultDepthOfScreen :: Screen -> CInt

-- | interface to the X11 library function <tt>XDefaultGCOfScreen()</tt>.
defaultGCOfScreen :: Screen -> GC

-- | interface to the X11 library function
--   <tt>XDefaultVisualOfScreen()</tt>.
defaultVisualOfScreen :: Screen -> Visual

-- | interface to the X11 library function <tt>XDoesBackingStore()</tt>.
doesBackingStore :: Screen -> Bool

-- | interface to the X11 library function <tt>XDoesSaveUnders()</tt>.
doesSaveUnders :: Screen -> Bool

-- | interface to the X11 library function <tt>XDisplayOfScreen()</tt>.
displayOfScreen :: Screen -> Display

-- | interface to the X11 library function <tt>XEventMaskOfScreen()</tt>.
--   Event mask at connection setup time - not current event mask!
eventMaskOfScreen :: Screen -> EventMask

-- | interface to the X11 library function <tt>XMinCmapsOfScreen()</tt>.
minCmapsOfScreen :: Screen -> CInt

-- | interface to the X11 library function <tt>XMaxCmapsOfScreen()</tt>.
maxCmapsOfScreen :: Screen -> CInt

-- | interface to the X11 library function <tt>XRootWindowOfScreen()</tt>.
rootWindowOfScreen :: Screen -> Window

-- | interface to the X11 library function <tt>XWidthOfScreen()</tt>.
widthOfScreen :: Screen -> Dimension

-- | interface to the X11 library function <tt>XWidthMMOfScreen()</tt>.
widthMMOfScreen :: Screen -> Dimension

-- | interface to the X11 library function <tt>XHeightOfScreen()</tt>.
heightOfScreen :: Screen -> Dimension

-- | interface to the X11 library function <tt>XHeightMMOfScreen()</tt>.
heightMMOfScreen :: Screen -> Dimension

-- | interface to the X11 library function <tt>XPlanesOfScreen()</tt>.
planesOfScreen :: Screen -> CInt

-- | interface to the X11 library function
--   <tt>XScreenNumberOfScreen()</tt>.
screenNumberOfScreen :: Screen -> ScreenNumber

-- | pointer to an X11 <tt>Display</tt> structure
newtype Display
Display :: Ptr Display -> Display

-- | pointer to an X11 <tt>Screen</tt> structure
data Screen

-- | pointer to an X11 <tt>Visual</tt> structure
data Visual

-- | pointer to an X11 <tt>GC</tt> structure
data GC

-- | pointer to an X11 <tt>XSetWindowAttributes</tt> structure
data SetWindowAttributes

-- | counterpart of an X11 <tt>XVisualInfo</tt> structure
data VisualInfo
VisualInfo :: Visual -> VisualID -> ScreenNumber -> CInt -> CInt -> CULong -> CULong -> CULong -> CInt -> CInt -> VisualInfo
[visualInfo_visual] :: VisualInfo -> Visual
[visualInfo_visualID] :: VisualInfo -> VisualID
[visualInfo_screen] :: VisualInfo -> ScreenNumber
[visualInfo_depth] :: VisualInfo -> CInt
[visualInfo_class] :: VisualInfo -> CInt
[visualInfo_redMask] :: VisualInfo -> CULong
[visualInfo_greenMask] :: VisualInfo -> CULong
[visualInfo_blueMask] :: VisualInfo -> CULong
[visualInfo_colormapSize] :: VisualInfo -> CInt
[visualInfo_bitsPerRGB] :: VisualInfo -> CInt

-- | pointer to an X11 <tt>XImage</tt> structure
data Image
type Pixel = Word64
type Position = Int32
type Dimension = Word32
type Angle = CInt
type ScreenNumber = Word32
type Buffer = CInt

-- | counterpart of an X11 <tt>XPoint</tt> structure
data Point
Point :: !Position -> !Position -> Point
[pt_x] :: Point -> !Position
[pt_y] :: Point -> !Position

-- | counterpart of an X11 <tt>XRectangle</tt> structure
data Rectangle
Rectangle :: !Position -> !Position -> !Dimension -> !Dimension -> Rectangle
[rect_x] :: Rectangle -> !Position
[rect_y] :: Rectangle -> !Position
[rect_width] :: Rectangle -> !Dimension
[rect_height] :: Rectangle -> !Dimension

-- | counterpart of an X11 <tt>XArc</tt> structure
data Arc
Arc :: Position -> Position -> Dimension -> Dimension -> Angle -> Angle -> Arc
[arc_x] :: Arc -> Position
[arc_y] :: Arc -> Position
[arc_width] :: Arc -> Dimension
[arc_height] :: Arc -> Dimension
[arc_angle1] :: Arc -> Angle
[arc_angle2] :: Arc -> Angle

-- | counterpart of an X11 <tt>XSegment</tt> structure
data Segment
Segment :: Position -> Position -> Position -> Position -> Segment
[seg_x1] :: Segment -> Position
[seg_y1] :: Segment -> Position
[seg_x2] :: Segment -> Position
[seg_y2] :: Segment -> Position

-- | counterpart of an X11 <tt>XColor</tt> structure
data Color
Color :: Pixel -> Word16 -> Word16 -> Word16 -> Word8 -> Color
[color_pixel] :: Color -> Pixel
[color_red] :: Color -> Word16
[color_green] :: Color -> Word16
[color_blue] :: Color -> Word16
[color_flags] :: Color -> Word8
xFree :: Ptr a -> IO CInt
xRR_UnknownConnection :: Connection
xRR_Disconnected :: Connection
xRR_Connected :: Connection
xRR_Reflect_Y :: Reflection
xRR_Reflect_X :: Reflection
xRR_Rotate_270 :: Rotation
xRR_Rotate_180 :: Rotation
xRR_Rotate_90 :: Rotation
xRR_Rotate_0 :: Rotation
zPixmap :: ImageFormat
xyPixmap :: ImageFormat
xyBitmap :: ImageFormat
fontRightToLeft :: FontDirection
fontLeftToRight :: FontDirection
doBlue :: Word8
doGreen :: Word8
doRed :: Word8
always :: BackingStore
whenMapped :: BackingStore
notUseful :: BackingStore
unmapGravity :: WindowGravity
staticGravity :: BitGravity
southEastGravity :: BitGravity
southGravity :: BitGravity
southWestGravity :: BitGravity
eastGravity :: BitGravity
centerGravity :: BitGravity
westGravity :: BitGravity
northEastGravity :: BitGravity
northGravity :: BitGravity
northWestGravity :: BitGravity
forgetGravity :: BitGravity
setModeDelete :: ChangeSaveSetMode
setModeInsert :: ChangeSaveSetMode
mappingPointer :: MappingRequest
mappingKeyboard :: MappingRequest
mappingModifier :: MappingRequest
allocAll :: ColormapAlloc
allocNone :: ColormapAlloc
mSBFirst :: ByteOrder
lSBFirst :: ByteOrder
lowerHighest :: CirculationDirection
raiseLowest :: CirculationDirection
gCLastBit :: GCMask
gCArcMode :: GCMask
gCDashList :: GCMask
gCDashOffset :: GCMask
gCClipMask :: GCMask
gCClipYOrigin :: GCMask
gCClipXOrigin :: GCMask
gCGraphicsExposures :: GCMask
gCSubwindowMode :: GCMask
gCFont :: GCMask
gCTileStipYOrigin :: GCMask
gCTileStipXOrigin :: GCMask
gCStipple :: GCMask
gCTile :: GCMask
gCFillRule :: GCMask
gCFillStyle :: GCMask
gCJoinStyle :: GCMask
gCCapStyle :: GCMask
gCLineStyle :: GCMask
gCLineWidth :: GCMask
gCBackground :: GCMask
gCForeground :: GCMask
gCPlaneMask :: GCMask
gCFunction :: GCMask
arcPieSlice :: ArcMode
arcChord :: ArcMode
convex :: PolygonShape
nonconvex :: PolygonShape
complex :: PolygonShape
coordModePrevious :: CoordinateMode
coordModeOrigin :: CoordinateMode
includeInferiors :: SubWindowMode
clipByChildren :: SubWindowMode
windingRule :: FillRule
evenOddRule :: FillRule
fillOpaqueStippled :: FillStyle
fillStippled :: FillStyle
fillTiled :: FillStyle
fillSolid :: FillStyle
joinBevel :: JoinStyle
joinRound :: JoinStyle
joinMiter :: JoinStyle
capProjecting :: CapStyle
capRound :: CapStyle
capButt :: CapStyle
capNotLast :: CapStyle
lineDoubleDash :: LineStyle
lineOnOffDash :: LineStyle
lineSolid :: LineStyle
gXset :: GXFunction
gXnand :: GXFunction
gXorInverted :: GXFunction
gXcopyInverted :: GXFunction
gXorReverse :: GXFunction
gXinvert :: GXFunction
gXequiv :: GXFunction
gXnor :: GXFunction
gXor :: GXFunction
gXxor :: GXFunction
gXnoop :: GXFunction
gXandInverted :: GXFunction
gXcopy :: GXFunction
gXandReverse :: GXFunction
gXand :: GXFunction
gXclear :: GXFunction
stippleShape :: QueryBestSizeClass
tileShape :: QueryBestSizeClass
cursorShape :: QueryBestSizeClass
retainTemporary :: CloseDownMode
retainPermanent :: CloseDownMode
destroyAll :: CloseDownMode
cWHeight :: AttributeMask
cWWidth :: AttributeMask
cWY :: AttributeMask
cWX :: AttributeMask
cWCursor :: AttributeMask
cWColormap :: AttributeMask
cWDontPropagate :: AttributeMask
cWEventMask :: AttributeMask
cWSaveUnder :: AttributeMask
cWOverrideRedirect :: AttributeMask
cWBackingPixel :: AttributeMask
cWBackingPlanes :: AttributeMask
cWBackingStore :: AttributeMask
cWWinGravity :: AttributeMask
cWBitGravity :: AttributeMask
cWBorderPixel :: AttributeMask
cWBorderPixmap :: AttributeMask
cWBackPixel :: AttributeMask
cWBackPixmap :: AttributeMask
inputOnly :: WindowClass
inputOutput :: WindowClass
copyFromParent :: WindowClass
throwIfZero :: String -> IO Status -> IO ()
lastExtensionError :: ErrorCode
firstExtensionError :: ErrorCode
badImplementation :: ErrorCode
badLength :: ErrorCode
badName :: ErrorCode
badIDChoice :: ErrorCode

-- | Xlib functions with return values of type <tt>Status</tt> return zero
--   on failure and nonzero on success.
badGC :: ErrorCode
badColor :: ErrorCode
badAlloc :: ErrorCode
badAccess :: ErrorCode
badDrawable :: ErrorCode
badMatch :: ErrorCode
badFont :: ErrorCode
badCursor :: ErrorCode
badAtom :: ErrorCode
badPixmap :: ErrorCode
badWindow :: ErrorCode
badValue :: ErrorCode
badRequest :: ErrorCode
success :: ErrorCode
revertToParent :: FocusMode
revertToPointerRoot :: FocusMode
revertToNone :: FocusMode
syncBoth :: AllowEvents
asyncBoth :: AllowEvents
replayKeyboard :: AllowEvents
syncKeyboard :: AllowEvents
asyncKeyboard :: AllowEvents
replayPointer :: AllowEvents
syncPointer :: AllowEvents
asyncPointer :: AllowEvents
grabFrozen :: GrabStatus
grabNotViewable :: GrabStatus
grabInvalidTime :: GrabStatus
alreadyGrabbed :: GrabStatus
grabSuccess :: GrabStatus
grabModeAsync :: GrabMode
grabModeSync :: GrabMode
colormapInstalled :: ColormapNotification
colormapUninstalled :: ColormapNotification
propertyDelete :: PropertyNotification
propertyNewValue :: PropertyNotification
familyChaos :: Protocol
familyDECnet :: Protocol
familyInternet :: Protocol
placeOnBottom :: Place
placeOnTop :: Place
visibilityFullyObscured :: Visibility
visibilityPartiallyObscured :: Visibility
visibilityUnobscured :: Visibility
notifyDetailNone :: NotifyDetail
notifyPointerRoot :: NotifyDetail
notifyPointer :: NotifyDetail
notifyNonlinearVirtual :: NotifyDetail
notifyNonlinear :: NotifyDetail
notifyInferior :: NotifyDetail
notifyVirtual :: NotifyDetail
notifyAncestor :: NotifyDetail
notifyHint :: NotifyMode
notifyWhileGrabbed :: NotifyMode
notifyUngrab :: NotifyMode
notifyGrab :: NotifyMode
notifyNormal :: NotifyMode
button5 :: Button
button4 :: Button
button3 :: Button
button2 :: Button
button1 :: Button
button5Mask :: ButtonMask
button4Mask :: ButtonMask
button3Mask :: ButtonMask
button2Mask :: ButtonMask
button1Mask :: ButtonMask
mod5Mask :: KeyMask
mod4Mask :: KeyMask
mod3Mask :: KeyMask
mod2Mask :: KeyMask
mod1Mask :: KeyMask
controlMask :: KeyMask
lockMask :: KeyMask
shiftMask :: KeyMask
noModMask :: KeyMask
anyModifier :: Modifier
mod5MapIndex :: Modifier
mod4MapIndex :: Modifier
mod3MapIndex :: Modifier
mod2MapIndex :: Modifier
mod1MapIndex :: Modifier
controlMapIndex :: Modifier
lockMapIndex :: Modifier
shiftMapIndex :: Modifier
screenSaverNotify :: EventType
lASTEvent :: EventType
rrNotifyOutputProperty :: EventType
rrNotifyOutputChange :: EventType
rrNotifyCrtcChange :: EventType
rrNotify :: EventType
rrScreenChangeNotify :: EventType
mappingNotify :: EventType
clientMessage :: EventType
colormapNotify :: EventType
selectionNotify :: EventType
selectionRequest :: EventType
selectionClear :: EventType
propertyNotify :: EventType
circulateRequest :: EventType
circulateNotify :: EventType
resizeRequest :: EventType
gravityNotify :: EventType
configureRequest :: EventType
configureNotify :: EventType
reparentNotify :: EventType
mapRequest :: EventType
mapNotify :: EventType
unmapNotify :: EventType
destroyNotify :: EventType
createNotify :: EventType
visibilityNotify :: EventType
noExpose :: EventType
graphicsExpose :: EventType
expose :: EventType
keymapNotify :: EventType
focusOut :: EventType
focusIn :: EventType
leaveNotify :: EventType
enterNotify :: EventType
motionNotify :: EventType
buttonRelease :: EventType
buttonPress :: EventType
keyRelease :: EventType
keyPress :: EventType
screenSaverNotifyMask :: EventMask
screenSaverCycleMask :: EventMask
rrOutputPropertyNotifyMask :: EventMask
rrOutputChangeNotifyMask :: EventMask
rrCrtcChangeNotifyMask :: EventMask
rrScreenChangeNotifyMask :: EventMask
ownerGrabButtonMask :: EventMask
colormapChangeMask :: EventMask
propertyChangeMask :: EventMask
focusChangeMask :: EventMask
substructureRedirectMask :: EventMask
substructureNotifyMask :: EventMask
resizeRedirectMask :: EventMask
structureNotifyMask :: EventMask
visibilityChangeMask :: EventMask
exposureMask :: EventMask
keymapStateMask :: EventMask
buttonMotionMask :: EventMask
button5MotionMask :: EventMask
button4MotionMask :: EventMask
button3MotionMask :: EventMask
button2MotionMask :: EventMask
button1MotionMask :: EventMask
pointerMotionHintMask :: EventMask
pointerMotionMask :: EventMask
leaveWindowMask :: EventMask
enterWindowMask :: EventMask
buttonReleaseMask :: EventMask
buttonPressMask :: EventMask
keyReleaseMask :: EventMask
keyPressMask :: EventMask
noEventMask :: EventMask
xK_ydiaeresis :: KeySym
xK_thorn :: KeySym
xK_yacute :: KeySym
xK_udiaeresis :: KeySym
xK_ucircumflex :: KeySym
xK_uacute :: KeySym
xK_ugrave :: KeySym
xK_oslash :: KeySym
xK_division :: KeySym
xK_odiaeresis :: KeySym
xK_otilde :: KeySym
xK_ocircumflex :: KeySym
xK_oacute :: KeySym
xK_ograve :: KeySym
xK_ntilde :: KeySym
xK_eth :: KeySym
xK_idiaeresis :: KeySym
xK_icircumflex :: KeySym
xK_iacute :: KeySym
xK_igrave :: KeySym
xK_ediaeresis :: KeySym
xK_ecircumflex :: KeySym
xK_eacute :: KeySym
xK_egrave :: KeySym
xK_ccedilla :: KeySym
xK_ae :: KeySym
xK_aring :: KeySym
xK_adiaeresis :: KeySym
xK_atilde :: KeySym
xK_acircumflex :: KeySym
xK_aacute :: KeySym
xK_agrave :: KeySym
xK_ssharp :: KeySym
xK_Thorn :: KeySym
xK_THORN :: KeySym
xK_Yacute :: KeySym
xK_Udiaeresis :: KeySym
xK_Ucircumflex :: KeySym
xK_Uacute :: KeySym
xK_Ugrave :: KeySym
xK_Ooblique :: KeySym
xK_multiply :: KeySym
xK_Odiaeresis :: KeySym
xK_Otilde :: KeySym
xK_Ocircumflex :: KeySym
xK_Oacute :: KeySym
xK_Ograve :: KeySym
xK_Ntilde :: KeySym
xK_Eth :: KeySym
xK_ETH :: KeySym
xK_Idiaeresis :: KeySym
xK_Icircumflex :: KeySym
xK_Iacute :: KeySym
xK_Igrave :: KeySym
xK_Ediaeresis :: KeySym
xK_Ecircumflex :: KeySym
xK_Eacute :: KeySym
xK_Egrave :: KeySym
xK_Ccedilla :: KeySym
xK_AE :: KeySym
xK_Aring :: KeySym
xK_Adiaeresis :: KeySym
xK_Atilde :: KeySym
xK_Acircumflex :: KeySym
xK_Aacute :: KeySym
xK_Agrave :: KeySym
xK_questiondown :: KeySym
xK_threequarters :: KeySym
xK_onehalf :: KeySym
xK_onequarter :: KeySym
xK_guillemotright :: KeySym
xK_masculine :: KeySym
xK_onesuperior :: KeySym
xK_cedilla :: KeySym
xK_periodcentered :: KeySym
xK_paragraph :: KeySym
xK_mu :: KeySym
xK_acute :: KeySym
xK_threesuperior :: KeySym
xK_twosuperior :: KeySym
xK_plusminus :: KeySym
xK_degree :: KeySym
xK_macron :: KeySym
xK_registered :: KeySym
xK_hyphen :: KeySym
xK_notsign :: KeySym
xK_guillemotleft :: KeySym
xK_ordfeminine :: KeySym
xK_copyright :: KeySym
xK_diaeresis :: KeySym
xK_section :: KeySym
xK_brokenbar :: KeySym
xK_yen :: KeySym
xK_currency :: KeySym
xK_sterling :: KeySym
xK_cent :: KeySym
xK_exclamdown :: KeySym
xK_nobreakspace :: KeySym
xK_asciitilde :: KeySym
xK_braceright :: KeySym
xK_bar :: KeySym
xK_braceleft :: KeySym
xK_z :: KeySym
xK_y :: KeySym
xK_x :: KeySym
xK_w :: KeySym
xK_v :: KeySym
xK_u :: KeySym
xK_t :: KeySym
xK_s :: KeySym
xK_r :: KeySym
xK_q :: KeySym
xK_p :: KeySym
xK_o :: KeySym
xK_n :: KeySym
xK_m :: KeySym
xK_l :: KeySym
xK_k :: KeySym
xK_j :: KeySym
xK_i :: KeySym
xK_h :: KeySym
xK_g :: KeySym
xK_f :: KeySym
xK_e :: KeySym
xK_d :: KeySym
xK_c :: KeySym
xK_b :: KeySym
xK_a :: KeySym
xK_quoteleft :: KeySym
xK_grave :: KeySym
xK_underscore :: KeySym
xK_asciicircum :: KeySym
xK_bracketright :: KeySym
xK_backslash :: KeySym
xK_bracketleft :: KeySym
xK_Z :: KeySym
xK_Y :: KeySym
xK_X :: KeySym
xK_W :: KeySym
xK_V :: KeySym
xK_U :: KeySym
xK_T :: KeySym
xK_S :: KeySym
xK_R :: KeySym
xK_Q :: KeySym
xK_P :: KeySym
xK_O :: KeySym
xK_N :: KeySym
xK_M :: KeySym
xK_L :: KeySym
xK_K :: KeySym
xK_J :: KeySym
xK_I :: KeySym
xK_H :: KeySym
xK_G :: KeySym
xK_F :: KeySym
xK_E :: KeySym
xK_D :: KeySym
xK_C :: KeySym
xK_B :: KeySym
xK_A :: KeySym
xK_at :: KeySym
xK_question :: KeySym
xK_greater :: KeySym
xK_equal :: KeySym
xK_less :: KeySym
xK_semicolon :: KeySym
xK_colon :: KeySym
xK_9 :: KeySym
xK_8 :: KeySym
xK_7 :: KeySym
xK_6 :: KeySym
xK_5 :: KeySym
xK_4 :: KeySym
xK_3 :: KeySym
xK_2 :: KeySym
xK_1 :: KeySym
xK_0 :: KeySym
xK_slash :: KeySym
xK_period :: KeySym
xK_minus :: KeySym
xK_comma :: KeySym
xK_plus :: KeySym
xK_asterisk :: KeySym
xK_parenright :: KeySym
xK_parenleft :: KeySym
xK_quoteright :: KeySym
xK_apostrophe :: KeySym
xK_ampersand :: KeySym
xK_percent :: KeySym
xK_dollar :: KeySym
xK_numbersign :: KeySym
xK_quotedbl :: KeySym
xK_exclam :: KeySym
xK_space :: KeySym
xK_Hyper_R :: KeySym
xK_Hyper_L :: KeySym
xK_Super_R :: KeySym
xK_Super_L :: KeySym
xK_Alt_R :: KeySym
xK_Alt_L :: KeySym
xK_Meta_R :: KeySym
xK_Meta_L :: KeySym
xK_Shift_Lock :: KeySym
xK_Caps_Lock :: KeySym
xK_Control_R :: KeySym
xK_Control_L :: KeySym
xK_Shift_R :: KeySym
xK_Shift_L :: KeySym
xK_R15 :: KeySym
xK_F35 :: KeySym
xK_R14 :: KeySym
xK_F34 :: KeySym
xK_R13 :: KeySym
xK_F33 :: KeySym
xK_R12 :: KeySym
xK_F32 :: KeySym
xK_R11 :: KeySym
xK_F31 :: KeySym
xK_R10 :: KeySym
xK_F30 :: KeySym
xK_R9 :: KeySym
xK_F29 :: KeySym
xK_R8 :: KeySym
xK_F28 :: KeySym
xK_R7 :: KeySym
xK_F27 :: KeySym
xK_R6 :: KeySym
xK_F26 :: KeySym
xK_R5 :: KeySym
xK_F25 :: KeySym
xK_R4 :: KeySym
xK_F24 :: KeySym
xK_R3 :: KeySym
xK_F23 :: KeySym
xK_R2 :: KeySym
xK_F22 :: KeySym
xK_R1 :: KeySym
xK_F21 :: KeySym
xK_L10 :: KeySym
xK_F20 :: KeySym
xK_L9 :: KeySym
xK_F19 :: KeySym
xK_L8 :: KeySym
xK_F18 :: KeySym
xK_L7 :: KeySym
xK_F17 :: KeySym
xK_L6 :: KeySym
xK_F16 :: KeySym
xK_L5 :: KeySym
xK_F15 :: KeySym
xK_L4 :: KeySym
xK_F14 :: KeySym
xK_L3 :: KeySym
xK_F13 :: KeySym
xK_L2 :: KeySym
xK_F12 :: KeySym
xK_L1 :: KeySym
xK_F11 :: KeySym
xK_F10 :: KeySym
xK_F9 :: KeySym
xK_F8 :: KeySym
xK_F7 :: KeySym
xK_F6 :: KeySym
xK_F5 :: KeySym
xK_F4 :: KeySym
xK_F3 :: KeySym
xK_F2 :: KeySym
xK_F1 :: KeySym
xK_KP_9 :: KeySym
xK_KP_8 :: KeySym
xK_KP_7 :: KeySym
xK_KP_6 :: KeySym
xK_KP_5 :: KeySym
xK_KP_4 :: KeySym
xK_KP_3 :: KeySym
xK_KP_2 :: KeySym
xK_KP_1 :: KeySym
xK_KP_0 :: KeySym
xK_KP_Divide :: KeySym
xK_KP_Decimal :: KeySym
xK_KP_Subtract :: KeySym
xK_KP_Separator :: KeySym
xK_KP_Add :: KeySym
xK_KP_Multiply :: KeySym
xK_KP_Equal :: KeySym
xK_KP_Delete :: KeySym
xK_KP_Insert :: KeySym
xK_KP_Begin :: KeySym
xK_KP_End :: KeySym
xK_KP_Page_Down :: KeySym
xK_KP_Next :: KeySym
xK_KP_Page_Up :: KeySym
xK_KP_Prior :: KeySym
xK_KP_Down :: KeySym
xK_KP_Right :: KeySym
xK_KP_Up :: KeySym
xK_KP_Left :: KeySym
xK_KP_Home :: KeySym
xK_KP_F4 :: KeySym
xK_KP_F3 :: KeySym
xK_KP_F2 :: KeySym
xK_KP_F1 :: KeySym
xK_KP_Enter :: KeySym
xK_KP_Tab :: KeySym
xK_KP_Space :: KeySym
xK_Num_Lock :: KeySym
xK_script_switch :: KeySym
xK_Mode_switch :: KeySym
xK_Break :: KeySym
xK_Help :: KeySym
xK_Cancel :: KeySym
xK_Find :: KeySym
xK_Menu :: KeySym
xK_Redo :: KeySym
xK_Undo :: KeySym
xK_Insert :: KeySym
xK_Execute :: KeySym
xK_Print :: KeySym
xK_Select :: KeySym
xK_Begin :: KeySym
xK_End :: KeySym
xK_Page_Down :: KeySym
xK_Next :: KeySym
xK_Page_Up :: KeySym
xK_Prior :: KeySym
xK_Down :: KeySym
xK_Right :: KeySym
xK_Up :: KeySym
xK_Left :: KeySym
xK_Home :: KeySym
xK_PreviousCandidate :: KeySym
xK_MultipleCandidate :: KeySym
xK_SingleCandidate :: KeySym
xK_Codeinput :: KeySym
xK_Multi_key :: KeySym
xK_Delete :: KeySym
xK_Escape :: KeySym
xK_Sys_Req :: KeySym
xK_Scroll_Lock :: KeySym
xK_Pause :: KeySym
xK_Return :: KeySym
xK_Clear :: KeySym
xK_Linefeed :: KeySym
xK_Tab :: KeySym
xK_BackSpace :: KeySym
xK_VoidSymbol :: KeySym
type XID = Word64
type Mask = Word64
type Atom = Word64
type VisualID = Word64
type Time = Word64
type Window = XID
type Drawable = XID
type Font = XID
type Pixmap = XID
type Cursor = XID
type Colormap = XID
type GContext = XID
type KeyCode = Word8
type KeySym = XID
type EventMask = Mask
type EventType = Word32
type Modifier = CUInt
type KeyMask = Modifier
type ButtonMask = Modifier
type Button = Word32
type NotifyMode = CInt
type NotifyDetail = CInt
type Visibility = CInt

-- | Place of window relative to siblings (used in Circulation requests or
--   events)
type Place = CInt
type Protocol = CInt
type PropertyNotification = CInt
type ColormapNotification = CInt
type GrabMode = CInt
type GrabStatus = CInt
type AllowEvents = CInt
type FocusMode = CInt
type ErrorCode = CInt
type Status = CInt
type WindowClass = CInt
type AttributeMask = Mask
type CloseDownMode = CInt
type QueryBestSizeClass = CInt
type GXFunction = CInt
type LineStyle = CInt
type CapStyle = CInt
type JoinStyle = CInt
type FillStyle = CInt
type FillRule = CInt
type SubWindowMode = CInt
type CoordinateMode = CInt
type PolygonShape = CInt
type ArcMode = CInt
type GCMask = CInt
type CirculationDirection = CInt
type ByteOrder = CInt
type ColormapAlloc = CInt
type MappingRequest = CInt
type ChangeSaveSetMode = CInt
type BitGravity = CInt
type WindowGravity = CInt
type BackingStore = CInt
type FontDirection = CInt
type ImageFormat = CInt
type Rotation = Word16
type Reflection = Word16
type SizeID = Word16
type SubpixelOrder = Word16
type Connection = Word16
type RROutput = Word64
type RRCrtc = Word64
type RRMode = Word64
type XRRModeFlags = Word64

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a

-- | Bitwise "or"
(.|.) :: Bits a => a -> a -> a
infixl 5 .|.

-- | A class for types with a default value.
class Default a

-- | The default value for this type.
def :: Default a => a

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: Type -> Type) | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r (m :: Type -> Type) | m -> r

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Executes a computation in a modified environment.
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | Retrieves a function of the current environment.
reader :: MonadReader r m => (r -> a) -> m a

-- | Retrieves a function of the current environment.
asks :: MonadReader r m => (r -> a) -> m a

-- | Entry point into xmonad for custom builds.
--   
--   This function isn't meant to be called by the typical xmonad user
--   because it:
--   
--   <ul>
--   <li>Does not process any command line arguments.</li>
--   <li>Therefore doesn't know how to restart a running xmonad.</li>
--   <li>Does not compile your configuration file since it assumes it's
--   actually running from within your compiled configuration.</li>
--   </ul>
--   
--   Unless you know what you are doing, you should probably be using the
--   <a>xmonad</a> function instead.
--   
--   However, if you are using a custom build environment (such as stack,
--   cabal, make, etc.) you will likely want to call this function instead
--   of <a>xmonad</a>. You probably also want to have a key binding to the
--   <a>restart</a> function that restarts your custom binary with the
--   resume flag set to <tt>True</tt>.
launch :: forall (l :: TYPE LiftedRep -> Type). (LayoutClass l Window, Read (l Window)) => XConfig l -> Directories -> IO ()

-- | Build the xmonad configuration file with ghc, then execute it. If
--   there are no errors, this function does not return. An exception is
--   raised in any of these cases:
--   
--   <ul>
--   <li>ghc missing</li>
--   <li>both the configuration file and executable are missing</li>
--   <li>xmonad.hs fails to compile</li>
--   <li>* wrong ghc in path (fails to compile)</li>
--   <li>* type error, syntax error, ..</li>
--   <li>Missing XMonad/XMonadContrib modules due to ghc upgrade</li>
--   </ul>
buildLaunch :: Directories -> IO ()

-- | The default set of configuration values itself
defaultConfig :: XConfig (Choose Tall (Choose (Mirror Tall) Full))

-- | Move the window to a given workspace
doShift :: WorkspaceId -> ManageHook

-- | Map the window and remove it from the <a>WindowSet</a>.
doIgnore :: ManageHook

-- | Move the window to the floating layer.
doFloat :: ManageHook

-- | Modify the <a>WindowSet</a> with a pure function.
doF :: (s -> s) -> Query (Endo s)

-- | Return whether the window will be a floating window or not
willFloat :: Query Bool
getStringProperty :: Display -> Window -> String -> X (Maybe String)

-- | A query that can return an arbitrary X property of type <a>String</a>,
--   identified by name. Works for ASCII strings only. For the properties
--   <tt>_NET_WM_NAME</tt>/<tt>WM_NAME</tt> and <tt>WM_CLASS</tt> the
--   specialised variants <a>title</a> and <a>appName</a>/<a>className</a>
--   are preferred.
stringProperty :: String -> Query String

-- | Return the resource class; i.e., the <i>second</i> string returned by
--   <tt>WM_CLASS</tt>.
className :: Query String

-- | Backwards compatible alias for <a>appName</a>.
resource :: Query String

-- | Return the application name; i.e., the <i>first</i> string returned by
--   <tt>WM_CLASS</tt>.
appName :: Query String

-- | Return the window title; i.e., the string returned by
--   <tt>_NET_WM_NAME</tt>, or failing that, the string returned by
--   <tt>WM_NAME</tt>.
title :: Query String

-- | <a>||</a> lifted to a <a>Monad</a>.
(<||>) :: Monad m => m Bool -> m Bool -> m Bool
infixr 3 <||>

-- | <a>&amp;&amp;</a> lifted to a <a>Monad</a>.
(<&&>) :: Monad m => m Bool -> m Bool -> m Bool
infixr 3 <&&>

-- | <tt>q =? x</tt>. if the result of <tt>q</tt> equals <tt>x</tt>, return
--   <a>True</a>.
(=?) :: Eq a => Query a -> a -> Query Bool

-- | <tt>p --&gt; x</tt>. If <tt>p</tt> returns <a>True</a>, execute the
--   <a>ManageHook</a>.
--   
--   <pre>
--   (--&gt;) :: Monoid m =&gt; Query Bool -&gt; Query m -&gt; Query m -- a simpler type
--   </pre>
(-->) :: (Monad m, Monoid a) => m Bool -> m a -> m a
infix 0 -->

-- | Compose the list of <a>ManageHook</a>s.
composeAll :: Monoid m => [m] -> m

-- | Infix <a>mappend</a>. Compose two <a>ManageHook</a> from right to
--   left.
(<+>) :: Monoid m => m -> m -> m

-- | The identity hook that returns the WindowSet unchanged.
idHook :: Monoid m => m

-- | Lift an <a>X</a> action to a <a>Query</a>.
liftX :: X a -> Query a

-- | Reduce the dimensions if they exceed the given maximum dimensions.
applyMaxSizeHint :: D -> D -> D

-- | Reduce the dimensions so they are a multiple of the size increments.
applyResizeIncHint :: D -> D -> D

-- | Reduce the dimensions so their aspect ratio falls between the two
--   given aspect ratios.
applyAspectHint :: (D, D) -> D -> D

-- | Use X11 size hints to scale a pair of dimensions.
applySizeHints' :: SizeHints -> D -> D

-- | Reduce the dimensions if needed to comply to the given SizeHints.
applySizeHintsContents :: Integral a => SizeHints -> (a, a) -> D

-- | Reduce the dimensions if needed to comply to the given SizeHints,
--   taking window borders into account.
applySizeHints :: Integral a => Dimension -> SizeHints -> (a, a) -> D

-- | Given a window, build an adjuster function that will reduce the given
--   dimensions according to the window's border width and size hints.
mkAdjust :: Window -> X (D -> D)

-- | Resize the window under the cursor with the mouse while it is dragged.
mouseResizeWindow :: Window -> X ()

-- | Drag the window under the cursor with the mouse while it is dragged.
mouseMoveWindow :: Window -> X ()

-- | Accumulate mouse motion events
mouseDrag :: (Position -> Position -> X ()) -> X () -> X ()

-- | Make a tiled window floating, using its suggested rectangle
float :: Window -> X ()

-- | <tt>pointWithin x y r</tt> returns <a>True</a> if the <tt>(x, y)</tt>
--   co-ordinate is within <tt>r</tt>.
pointWithin :: Position -> Position -> Rectangle -> Bool

-- | Given a point, determine the screen (if any) that contains it.
pointScreen :: Position -> Position -> X (Maybe (Screen WorkspaceId (Layout Window) Window ScreenId ScreenDetail))

-- | Given a window, find the screen it is located on, and compute the
--   geometry of that window WRT that screen.
floatLocation :: Window -> X (ScreenId, RationalRect)

-- | <tt>restart name resume</tt> attempts to restart xmonad by executing
--   the program <tt>name</tt>. If <tt>resume</tt> is <a>True</a>, restart
--   with the current window state. When executing another window manager,
--   <tt>resume</tt> should be <a>False</a>.
restart :: String -> Bool -> X ()

-- | Read the state of a previous xmonad instance from a file and return
--   that state. The state file is removed after reading it.
readStateFile :: forall (l :: TYPE LiftedRep -> Type). (LayoutClass l Window, Read (l Window)) => XConfig l -> X (Maybe XState)

-- | Write the current window state (and extensible state) to a file so
--   that xmonad can resume with that state intact.
writeStateToFile :: X ()

-- | Get the <a>Pixel</a> value for a named color.
initColor :: Display -> String -> IO (Maybe Pixel)

-- | Strip numlock/capslock from a mask.
cleanMask :: KeyMask -> X KeyMask

-- | Combinations of extra modifier masks we need to grab keys/buttons for.
--   (numlock and capslock)
extraModifiers :: X [KeyMask]

-- | Is the window is under management by xmonad?
isClient :: Window -> X Bool

-- | Apply an <a>X</a> operation to all unfocused windows on the current
--   workspace, if there are any.
withUnfocused :: (Window -> X ()) -> X ()

-- | Apply an <a>X</a> operation to the currently focused window, if there
--   is one.
withFocused :: (Window -> X ()) -> X ()

-- | Return workspace visible on screen <tt>sc</tt>, or <a>Nothing</a>.
screenWorkspace :: ScreenId -> X (Maybe WorkspaceId)

-- | Signal compliant window managers to exit.
sendReplace :: IO ()

-- | Signal xmonad to restart itself.
sendRestart :: IO ()

-- | Set the layout of the currently viewed workspace.
setLayout :: Layout Window -> X ()

-- | Update the layout field of a workspace.
updateLayout :: WorkspaceId -> Maybe (Layout Window) -> X ()

-- | Send a message to a layout, without refreshing.
sendMessageWithNoRefresh :: Message a => a -> WindowSpace -> X ()

-- | Send a message to all layouts, without refreshing.
broadcastMessage :: Message a => a -> X ()

-- | Throw a message to the current <a>LayoutClass</a> possibly modifying
--   how we layout the windows, in which case changes are handled through a
--   refresh.
sendMessage :: Message a => a -> X ()

-- | Release XMonad's keyboard grab, so other grabbers can do their thing.
--   
--   Start a keyboard action with this if it is going to run something that
--   needs to do a keyboard, pointer, or server grab. For example,
--   
--   <pre>
--   , ((modm .|. controlMask, xK_p), unGrab &gt;&gt; spawn "scrot")
--   </pre>
--   
--   (Other examples are certain screen lockers and "gksu".) This avoids
--   needing to insert a pause/sleep before running the command.
--   
--   XMonad retains the keyboard grab during key actions because if they
--   use a submap, they need the keyboard to be grabbed, and if they had to
--   assert their own grab then the asynchronous nature of X11 allows race
--   conditions between XMonad, other clients, and the X server that would
--   cause keys to sometimes be "leaked" to the focused window.
unGrab :: X ()

-- | Given a list of keybindings, turn the given <a>KeySym</a>s into actual
--   <a>KeyCode</a>s and prepare them for grabbing.
mkGrabs :: [(KeyMask, KeySym)] -> X [(KeyMask, KeyCode)]
cacheNumlockMask :: X ()

-- | Call X to set the keyboard focus details.
setFocusX :: Window -> X ()

-- | Set focus explicitly to window <tt>w</tt> if it is managed by us, or
--   root. This happens if X notices we've moved the mouse (and perhaps
--   moved the mouse to a new screen).
focus :: Window -> X ()

-- | Set the focus to the window on top of the stack, or root
setTopFocus :: X ()

-- | Tell whether or not to intercept clicks on a given window
setButtonGrab :: Bool -> Window -> X ()

-- | The screen configuration may have changed (due to -- xrandr), update
--   the state and refresh the screen, and reset the gap.
rescreen :: X ()

-- | Clean the list of screens according to the rules documented for
--   nubScreens.
getCleanedScreenInfo :: MonadIO m => Display -> m [Rectangle]

-- | Given a list of screens, remove all duplicated screens and screens
--   that are entirely contained within another.
nubScreens :: [Rectangle] -> [Rectangle]

-- | Returns <a>True</a> if the first rectangle is contained within, but
--   not equal to the second.
containedIn :: Rectangle -> Rectangle -> Bool

-- | Move and resize <tt>w</tt> such that it fits inside the given
--   rectangle, including its border.
tileWindow :: Window -> Rectangle -> X ()

-- | Remove all events of a given type from the event queue.
clearEvents :: EventMask -> X ()

-- | Render the currently visible workspaces, as determined by the
--   <tt>StackSet</tt>. Also, set focus to the focused window.
--   
--   This is our <tt>view</tt> operation (MVC), in that it pretty prints
--   our model with X calls.
refresh :: X ()

-- | Set some properties when we initially gain control of a window.
setInitialProperties :: Window -> X ()

-- | Show a window by mapping it and setting Normal. This is harmless if
--   the window was already visible.
reveal :: Window -> X ()

-- | Hide a window by unmapping it and setting Iconified.
hide :: Window -> X ()

-- | Set the border color using the window's color map, if possible;
--   otherwise fall back to the color in <tt>Pixel</tt>.
setWindowBorderWithFallback :: Display -> Window -> String -> Pixel -> X ()

-- | Set a window's WM_STATE property.
setWMState :: Window -> Int -> X ()

-- | Produce the actual rectangle from a screen and a ratio on that screen.
scaleRationalRect :: Rectangle -> RationalRect -> Rectangle

-- | Perform an <tt>X</tt> action. If it returns <tt>Any True</tt>, unwind
--   the changes to the <tt>WindowSet</tt> and replay them using
--   <tt>windows</tt>. This is a version of <tt>windowBracket</tt> that
--   discards the return value and handles an <tt>X</tt> action that
--   reports its need for refresh via <tt>Any</tt>.
windowBracket_ :: X Any -> X ()

-- | Perform an <tt>X</tt> action and check its return value against a
--   predicate p. If p holds, unwind changes to the <tt>WindowSet</tt> and
--   replay them using <tt>windows</tt>.
windowBracket :: (a -> Bool) -> X a -> X a

-- | Modify the <tt>WindowSet</tt> in state with no special handling.
modifyWindowSet :: (WindowSet -> WindowSet) -> X ()

-- | Modify the current window list with a pure function, and refresh
windows :: (WindowSet -> WindowSet) -> X ()

-- | Kill the currently focused client.
kill :: X ()

-- | Kill the specified window. If we do kill it, we'll get a delete notify
--   back from X.
--   
--   There are two ways to delete a window. Either just kill it, or if it
--   supports the delete protocol, send a delete event (e.g. firefox)
killWindow :: Window -> X ()

-- | A window no longer exists; remove it from the window list, on whatever
--   workspace it is.
unmanage :: Window -> X ()

-- | Add a new window to be managed in the current workspace. Bring it into
--   focus.
--   
--   Whether the window is already managed, or not, it is mapped, has its
--   border set, and its event mask set.
manage :: Window -> X ()

-- | Detect whether a window has fixed size or is transient. This check can
--   be used to determine whether the window should be floating or not
isFixedSizeOrTransient :: Display -> Window -> X Bool

-- | A type to help serialize xmonad's state to a file.
data StateFile
StateFile :: StackSet WorkspaceId String Window ScreenId ScreenDetail -> [(String, String)] -> StateFile
[sfWins] :: StateFile -> StackSet WorkspaceId String Window ScreenId ScreenDetail
[sfExt] :: StateFile -> [(String, String)]

-- | An alias for a (width, height) pair
type D = (Dimension, Dimension)

-- | The layout choice combinator
(|||) :: l a -> r a -> Choose l r a
infixr 5 |||

-- | Mirror a rectangle.
mirrorRect :: Rectangle -> Rectangle
splitVerticallyBy :: RealFrac r => r -> Rectangle -> (Rectangle, Rectangle)
splitHorizontallyBy :: RealFrac r => r -> Rectangle -> (Rectangle, Rectangle)
splitHorizontally :: Int -> Rectangle -> [Rectangle]
splitVertically :: Int -> Rectangle -> [Rectangle]

-- | Compute the positions for windows using the default two-pane tiling
--   algorithm.
--   
--   The screen is divided into two panes. All clients are then partitioned
--   between these two panes. One pane, the master, by convention has the
--   least number of windows in it.
tile :: Rational -> Rectangle -> Int -> Int -> [Rectangle]

-- | Change the size of the master pane.
data Resize
Shrink :: Resize
Expand :: Resize

-- | Increase the number of clients in the master pane.
newtype IncMasterN
IncMasterN :: Int -> IncMasterN

-- | Simple fullscreen mode. Renders the focused window fullscreen.
data Full a
Full :: Full a

-- | The builtin tiling mode of xmonad. Supports <a>Shrink</a>,
--   <a>Expand</a> and <a>IncMasterN</a>.
data Tall a
Tall :: !Int -> !Rational -> !Rational -> Tall a

-- | The default number of windows in the master pane (default: 1)
[tallNMaster] :: Tall a -> !Int

-- | Percent of screen to increment by when resizing panes (default: 3/100)
[tallRatioIncrement] :: Tall a -> !Rational

-- | Default proportion of screen occupied by master pane (default: 1/2)
[tallRatio] :: Tall a -> !Rational

-- | Mirror a layout, compute its 90 degree rotated form.
newtype Mirror (l :: Type -> Type) a
Mirror :: l a -> Mirror (l :: Type -> Type) a

-- | Messages to change the current layout. Also see <a>JumpToLayout</a>.
data ChangeLayout
FirstLayout :: ChangeLayout
NextLayout :: ChangeLayout

-- | A message to jump to a particular layout, specified by its description
--   string.
--   
--   The argument given to a <a>JumpToLayout</a> message should be the
--   <tt>description</tt> of the layout to be selected. If you use
--   <a>XMonad.Hooks.DynamicLog</a> from <tt>xmonad-contrib</tt>, this is
--   the name of the layout displayed in your status bar. Alternatively,
--   you can use GHCi to determine the proper name to use. For example:
--   
--   <pre>
--   $ ghci
--   GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
--   Loading package base ... linking ... done.
--   :set prompt "&gt; "    -- don't show loaded module names
--   &gt; :m +XMonad.Core   -- load the xmonad core
--   &gt; :m +XMonad.Layout.Grid  -- load whatever module you want to use
--   &gt; description Grid  -- find out what it's called
--   "Grid"
--   </pre>
--   
--   As yet another (possibly easier) alternative, you can use the
--   <a>XMonad.Layout.Renamed</a> module (also in <tt>xmonad-contrib</tt>)
--   to give custom names to your layouts, and use those.
--   
--   For example, if you want to jump directly to the <a>Full</a> layout
--   you can do
--   
--   <pre>
--   , ((modm .|. controlMask, xK_f), sendMessage $ JumpToLayout "Full")
--   </pre>
newtype JumpToLayout
JumpToLayout :: String -> JumpToLayout

-- | A layout that allows users to switch between various layout options.
data Choose (l :: Type -> Type) (r :: Type -> Type) a
Choose :: CLR -> l a -> r a -> Choose (l :: Type -> Type) (r :: Type -> Type) a

-- | Choose the current sub-layout (left or right) in <a>Choose</a>.
data CLR
CL :: CLR
CR :: CLR
uninstallSignalHandlers :: MonadIO m => m ()

-- | Ignore SIGPIPE to avoid termination when a pipe is full, and SIGCHLD
--   to avoid zombie processes, and clean up any extant zombie processes.
installSignalHandlers :: MonadIO m => m ()

-- | A <a>trace</a> for the <a>X</a> monad. Logs a string to stderr. The
--   result may be found in your .xsession-errors file
trace :: MonadIO m => String -> m ()

-- | Conditionally run an action, using a <a>X</a> event to decide
whenX :: X Bool -> X () -> X ()

-- | Conditionally run an action, using a <tt>Maybe a</tt> to decide.
whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()

-- | Recompile the xmonad configuration file when any of the following
--   apply:
--   
--   <ul>
--   <li>force is <a>True</a></li>
--   <li>the xmonad executable does not exist</li>
--   <li>the xmonad executable is older than <tt>xmonad.hs</tt> or any file
--   in the <tt>lib</tt> directory (under the configuration directory)</li>
--   <li>custom <tt>build</tt> script is being used</li>
--   </ul>
--   
--   The -i flag is used to restrict recompilation to the xmonad.hs file
--   only, and any files in the aforementioned <tt>lib</tt> directory.
--   
--   Compilation errors (if any) are logged to the <tt>xmonad.errors</tt>
--   file in the xmonad data directory. If GHC indicates failure with a
--   non-zero exit code, an xmessage displaying that file is spawned.
--   
--   <a>False</a> is returned if there are compilation errors.
recompile :: MonadIO m => Directories -> Bool -> m Bool
stateFileName :: Directories -> FilePath
binFileName :: Directories -> FilePath

-- | Return the path to the xmonad data directory.
getXMonadDataDir :: X String

-- | Return the path to the xmonad cache directory.
getXMonadCacheDir :: X String

-- | Return the path to the xmonad configuration directory.
getXMonadDir :: X String

-- | Build up the <tt>Dirs</tt> that xmonad will use. They are chosen as
--   follows:
--   
--   <ol>
--   <li>If all three of xmonad's environment variables
--   (<tt>XMONAD_DATA_DIR</tt>, <tt>XMONAD_CONFIG_DIR</tt>, and
--   <tt>XMONAD_CACHE_DIR</tt>) are set, use them.</li>
--   <li>If there is a build script called <tt>build</tt> or configuration
--   <tt>xmonad.hs</tt> in <tt>~/.xmonad</tt>, set all three directories to
--   <tt>~/.xmonad</tt>.</li>
--   <li>Otherwise, use the <tt>xmonad</tt> directory in
--   <tt>XDG_DATA_HOME</tt>, <tt>XDG_CONFIG_HOME</tt>, and
--   <tt>XDG_CACHE_HOME</tt> (or their respective fallbacks). These
--   directories are created if necessary.</li>
--   </ol>
--   
--   The xmonad configuration file (or the build script, if present) is
--   always assumed to be in <tt>cfgDir</tt>.
getDirectories :: IO Directories

-- | This is basically a map function, running a function in the <a>X</a>
--   monad on each workspace with the output of that function being the
--   modified workspace.
runOnWorkspaces :: (WindowSpace -> X WindowSpace) -> X ()

-- | Use <tt>xmessage</tt> to show information to the user.
xmessage :: MonadIO m => String -> m ()

-- | A replacement for <a>forkProcess</a> which resets default signal
--   handlers.
xfork :: MonadIO m => IO () -> m ProcessID

-- | Like <a>spawn</a>, but returns the <a>ProcessID</a> of the launched
--   application
spawnPID :: MonadIO m => String -> m ProcessID

-- | spawn. Launch an external application. Specifically, it double-forks
--   and runs the <a>String</a> you pass as a command to /bin/sh.
--   
--   Note this function assumes your locale uses utf8.
spawn :: MonadIO m => String -> m ()

-- | Lift an <a>IO</a> action into the <a>X</a> monad. If the action
--   results in an <a>IO</a> exception, log the exception to stderr and
--   continue normal execution.
catchIO :: MonadIO m => IO () -> m ()

-- | Lift an <a>IO</a> action into the <a>X</a> monad
io :: MonadIO m => IO a -> m a

-- | If-then-else lifted to a <a>Monad</a>.
ifM :: Monad m => m Bool -> m a -> m a -> m a

-- | And now, unwrap a given, unknown <a>Message</a> type, performing a
--   (dynamic) type check on the result.
fromMessage :: Message m => SomeMessage -> Maybe m

-- | Using the <a>Layout</a> as a witness, parse existentially wrapped
--   windows from a <a>String</a>.
readsLayout :: Layout a -> String -> [(Layout a, String)]

-- | Common non-predefined atoms
atom_WM_TAKE_FOCUS :: X Atom

-- | Common non-predefined atoms
atom_WM_STATE :: X Atom

-- | Common non-predefined atoms
atom_WM_DELETE_WINDOW :: X Atom

-- | Common non-predefined atoms
atom_WM_PROTOCOLS :: X Atom

-- | Wrapper for the common case of atom internment
getAtom :: String -> X Atom

-- | True if the given window is the root window
isRoot :: Window -> X Bool

-- | Safely access window attributes.
withWindowAttributes :: Display -> Window -> (WindowAttributes -> X ()) -> X ()

-- | Run a monadic action with the current stack set
withWindowSet :: (WindowSet -> X a) -> X a

-- | Run a monad action with the current display settings
withDisplay :: (Display -> X a) -> X a

-- | Same as userCode but with a default argument to return instead of
--   using Maybe, provided for convenience.
userCodeDef :: a -> X a -> X a

-- | Execute the argument, catching all exceptions. Either this function or
--   <a>catchX</a> should be used at all callsites of user customized code.
userCode :: X a -> X (Maybe a)

-- | Run in the <a>X</a> monad, and in case of exception, and catch it and
--   log it to stderr, and run the error case.
catchX :: X a -> X a -> X a

-- | Run the <a>X</a> monad, given a chunk of <a>X</a> monad code, and an
--   initial state Return the result, and final state
runX :: XConf -> XState -> X a -> IO (a, XState)
runQuery :: Query a -> Window -> X a

-- | XState, the (mutable) window manager state.
data XState
XState :: !WindowSet -> !Set Window -> !Map Window Int -> !Maybe (Position -> Position -> X (), X ()) -> !KeyMask -> !Map String (Either String StateExtension) -> XState

-- | workspace list
[windowset] :: XState -> !WindowSet

-- | the Set of mapped windows
[mapped] :: XState -> !Set Window

-- | the number of expected UnmapEvents
[waitingUnmap] :: XState -> !Map Window Int
[dragging] :: XState -> !Maybe (Position -> Position -> X (), X ())

-- | The numlock modifier
[numberlockMask] :: XState -> !KeyMask

-- | stores custom state information.
--   
--   The module <a>XMonad.Util.ExtensibleState</a> in xmonad-contrib
--   provides additional information and a simple interface for using this.
[extensibleState] :: XState -> !Map String (Either String StateExtension)

-- | XConf, the (read-only) window manager configuration.
data XConf
XConf :: Display -> !XConfig Layout -> !Window -> !Pixel -> !Pixel -> !Map (KeyMask, KeySym) (X ()) -> !Map (KeyMask, Button) (Window -> X ()) -> !Bool -> !Maybe (Position, Position) -> !Maybe Event -> !Directories -> XConf

-- | the X11 display
[display] :: XConf -> Display

-- | initial user configuration
[config] :: XConf -> !XConfig Layout

-- | the root window
[theRoot] :: XConf -> !Window

-- | border color of unfocused windows
[normalBorder] :: XConf -> !Pixel

-- | border color of the focused window
[focusedBorder] :: XConf -> !Pixel

-- | a mapping of key presses to actions
[keyActions] :: XConf -> !Map (KeyMask, KeySym) (X ())

-- | a mapping of button presses to actions
[buttonActions] :: XConf -> !Map (KeyMask, Button) (Window -> X ())

-- | was refocus caused by mouse action?
[mouseFocused] :: XConf -> !Bool

-- | position of the mouse according to the event currently being processed
[mousePosition] :: XConf -> !Maybe (Position, Position)

-- | event currently being processed
[currentEvent] :: XConf -> !Maybe Event

-- | directories to use
[directories] :: XConf -> !Directories
data XConfig (l :: TYPE LiftedRep -> Type)
XConfig :: !String -> !String -> !String -> !l Window -> !ManageHook -> !Event -> X All -> ![String] -> !KeyMask -> !XConfig Layout -> Map (ButtonMask, KeySym) (X ()) -> !XConfig Layout -> Map (ButtonMask, Button) (Window -> X ()) -> !Dimension -> !X () -> !X () -> !Bool -> !Bool -> !EventMask -> !EventMask -> ![String] -> XConfig Layout -> IO (XConfig Layout) -> !Map TypeRep ConfExtension -> XConfig (l :: TYPE LiftedRep -> Type)
type WindowSet = StackSet WorkspaceId Layout Window Window ScreenId ScreenDetail
type WindowSpace = Workspace WorkspaceId Layout Window Window

-- | Virtual workspace indices
type WorkspaceId = String

-- | Physical screen indices
newtype ScreenId
S :: Int -> ScreenId

-- | The <a>Rectangle</a> with screen dimensions
newtype ScreenDetail
SD :: Rectangle -> ScreenDetail
[screenRect] :: ScreenDetail -> Rectangle

-- | The X monad, <a>ReaderT</a> and <a>StateT</a> transformers over
--   <a>IO</a> encapsulating the window manager configuration and state,
--   respectively.
--   
--   Dynamic components may be retrieved with <a>get</a>, static components
--   with <a>ask</a>. With newtype deriving we get readers and state monads
--   instantiated on <a>XConf</a> and <a>XState</a> automatically.
data X a
type ManageHook = Query Endo WindowSet
newtype Query a
Query :: ReaderT Window X a -> Query a

-- | An existential type that can hold any object that is in <a>Read</a>
--   and <a>LayoutClass</a>.
data Layout a
Layout :: l a -> Layout a

-- | Every layout must be an instance of <a>LayoutClass</a>, which defines
--   the basic layout operations along with a sensible default for each.
--   
--   All of the methods have default implementations, so there is no
--   minimal complete definition. They do, however, have a dependency
--   structure by default; this is something to be aware of should you
--   choose to implement one of these methods. Here is how a minimal
--   complete definition would look like if we did not provide any default
--   implementations:
--   
--   <ul>
--   <li><a>runLayout</a> || ((<a>doLayout</a> || <a>pureLayout</a>)
--   &amp;&amp; <a>emptyLayout</a>)</li>
--   <li><a>handleMessage</a> || <a>pureMessage</a></li>
--   <li><a>description</a></li>
--   </ul>
--   
--   Note that any code which <i>uses</i> <a>LayoutClass</a> methods should
--   only ever call <a>runLayout</a>, <a>handleMessage</a>, and
--   <a>description</a>! In other words, the only calls to <a>doLayout</a>,
--   <a>pureMessage</a>, and other such methods should be from the default
--   implementations of <a>runLayout</a>, <a>handleMessage</a>, and so on.
--   This ensures that the proper methods will be used, regardless of the
--   particular methods that any <a>LayoutClass</a> instance chooses to
--   define.
class (Show layout a, Typeable layout) => LayoutClass (layout :: TYPE LiftedRep -> Type) a

-- | By default, <a>runLayout</a> calls <a>doLayout</a> if there are any
--   windows to be laid out, and <a>emptyLayout</a> otherwise. Most
--   instances of <a>LayoutClass</a> probably do not need to implement
--   <a>runLayout</a>; it is only useful for layouts which wish to make use
--   of more of the <a>Workspace</a> information (for example,
--   <a>XMonad.Layout.PerWorkspace</a>).
runLayout :: LayoutClass layout a => Workspace WorkspaceId (layout a) a -> Rectangle -> X ([(a, Rectangle)], Maybe (layout a))

-- | Given a <a>Rectangle</a> in which to place the windows, and a
--   <a>Stack</a> of windows, return a list of windows and their
--   corresponding Rectangles. If an element is not given a Rectangle by
--   <a>doLayout</a>, then it is not shown on screen. The order of windows
--   in this list should be the desired stacking order.
--   
--   Also possibly return a modified layout (by returning <tt>Just
--   newLayout</tt>), if this layout needs to be modified (e.g. if it keeps
--   track of some sort of state). Return <tt>Nothing</tt> if the layout
--   does not need to be modified.
--   
--   Layouts which do not need access to the <a>X</a> monad (<a>IO</a>,
--   window manager state, or configuration) and do not keep track of their
--   own state should implement <a>pureLayout</a> instead of
--   <a>doLayout</a>.
doLayout :: LayoutClass layout a => layout a -> Rectangle -> Stack a -> X ([(a, Rectangle)], Maybe (layout a))

-- | This is a pure version of <a>doLayout</a>, for cases where we don't
--   need access to the <a>X</a> monad to determine how to lay out the
--   windows, and we don't need to modify the layout itself.
pureLayout :: LayoutClass layout a => layout a -> Rectangle -> Stack a -> [(a, Rectangle)]

-- | <a>emptyLayout</a> is called when there are no windows.
emptyLayout :: LayoutClass layout a => layout a -> Rectangle -> X ([(a, Rectangle)], Maybe (layout a))

-- | <a>handleMessage</a> performs message handling. If
--   <a>handleMessage</a> returns <tt>Nothing</tt>, then the layout did not
--   respond to the message and the screen is not refreshed. Otherwise,
--   <a>handleMessage</a> returns an updated layout and the screen is
--   refreshed.
--   
--   Layouts which do not need access to the <a>X</a> monad to decide how
--   to handle messages should implement <a>pureMessage</a> instead of
--   <a>handleMessage</a> (this restricts the risk of error, and makes
--   testing much easier).
handleMessage :: LayoutClass layout a => layout a -> SomeMessage -> X (Maybe (layout a))

-- | Respond to a message by (possibly) changing our layout, but taking no
--   other action. If the layout changes, the screen will be refreshed.
pureMessage :: LayoutClass layout a => layout a -> SomeMessage -> Maybe (layout a)

-- | This should be a human-readable string that is used when selecting
--   layouts by name. The default implementation is <a>show</a>, which is
--   in some cases a poor default.
description :: LayoutClass layout a => layout a -> String

-- | Based on ideas in /An Extensible Dynamically-Typed Hierarchy of
--   Exceptions/, Simon Marlow, 2006. Use extensible messages to the
--   <a>handleMessage</a> handler.
--   
--   User-extensible messages must be a member of this class.
class Typeable a => Message a

-- | A wrapped value of some type in the <a>Message</a> class.
data SomeMessage
SomeMessage :: a -> SomeMessage

-- | <a>LayoutMessages</a> are core messages that all layouts (especially
--   stateful layouts) should consider handling.
data LayoutMessages

-- | sent when a layout becomes non-visible
Hide :: LayoutMessages

-- | sent when xmonad is exiting or restarting
ReleaseResources :: LayoutMessages

-- | Every module must make the data it wants to store an instance of this
--   class.
--   
--   Minimal complete definition: initialValue
class Typeable a => ExtensionClass a

-- | Defines an initial value for the state extension
initialValue :: ExtensionClass a => a

-- | Specifies whether the state extension should be persistent. Setting
--   this method to <a>PersistentExtension</a> will make the stored data
--   survive restarts, but requires a to be an instance of Read and Show.
--   
--   It defaults to <a>StateExtension</a>, i.e. no persistence.
extensionType :: ExtensionClass a => a -> StateExtension

-- | Existential type to store a state extension.
data StateExtension

-- | Non-persistent state extension
StateExtension :: a -> StateExtension

-- | Persistent extension
PersistentExtension :: a -> StateExtension

-- | Existential type to store a config extension.
data ConfExtension
ConfExtension :: a -> ConfExtension

-- | All the directories that xmonad will use. They will be used for the
--   following purposes:
--   
--   <ul>
--   <li><tt>dataDir</tt>: This directory is used by XMonad to store data
--   files such as the run-time state file.</li>
--   <li><tt>cfgDir</tt>: This directory is where user configuration files
--   are stored (e.g, the xmonad.hs file). You may also create a
--   <tt>lib</tt> subdirectory in the configuration directory and the
--   default recompile command will add it to the GHC include path.</li>
--   <li><tt>cacheDir</tt>: This directory is used to store temporary files
--   that can easily be recreated such as the configuration binary and any
--   intermediate object files generated by GHC. Also, the XPrompt history
--   file goes here.</li>
--   </ul>
--   
--   For how these directories are chosen, see <a>getDirectories</a>.
data Directories' a
Directories :: !a -> !a -> !a -> Directories' a
[dataDir] :: Directories' a -> !a
[cfgDir] :: Directories' a -> !a
[cacheDir] :: Directories' a -> !a

-- | Convenient type alias for the most common case in which one might want
--   to use the <a>Directories'</a> type.
type Directories = Directories' FilePath

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b
infixr 0 `seq`

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a', 'b']
--   [(1,'a'),(2,'b')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, instances
--   are encouraged to follow these properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Extensionality</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `rem`
infixl 7 `quot`
infixl 7 `div`

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 7 *
infixl 6 +
infixl 6 -

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   <a>Ord</a>, as defined by the Haskell report, implements a total order
--   and has the following properties:
--   
--   <ul>
--   <li><i><b>Comparability</b></i> <tt>x &lt;= y || y &lt;= x</tt> =
--   <a>True</a></li>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   The following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 <
infix 4 <=
infix 4 >
infix 4 >=

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*
infixl 4 *>
infixl 4 <*>

-- | The Foldable class represents data structures that can be reduced to a
--   summary value one element at a time. Strict left-associative folds are
--   a good fit for space-efficient reduction, while lazy right-associative
--   folds are a good fit for corecursive iteration, or for folds that
--   short-circuit after processing an initial subsequence of the
--   structure's elements.
--   
--   Instances can be derived automatically by enabling the
--   <tt>DeriveFoldable</tt> extension. For example, a derived instance for
--   a binary tree might be:
--   
--   <pre>
--   {-# LANGUAGE DeriveFoldable #-}
--   data Tree a = Empty
--               | Leaf a
--               | Node (Tree a) a (Tree a)
--       deriving Foldable
--   </pre>
--   
--   A more detailed description can be found in the <b>Overview</b>
--   section of <a>Data.Foldable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Foldable#laws</a>.
class Foldable (t :: TYPE LiftedRep -> Type)

-- | Map each element of the structure into a monoid, and combine the
--   results with <tt>(<a>&lt;&gt;</a>)</tt>. This fold is
--   right-associative and lazy in the accumulator. For strict
--   left-associative folds consider <a>foldMap'</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Sum [1, 3, 5]
--   Sum {getSum = 9}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Product [1, 3, 5]
--   Product {getProduct = 15}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap (replicate 3) [1, 2, 3]
--   [1,1,1,2,2,2,3,3,3]
--   </pre>
--   
--   When a Monoid's <tt>(<a>&lt;&gt;</a>)</tt> is lazy in its second
--   argument, <a>foldMap</a> can return a result even from an unbounded
--   structure. For example, lazy accumulation enables
--   <a>Data.ByteString.Builder</a> to efficiently serialise large data
--   structures and produce the output incrementally:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy as L
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Builder as B
--   
--   &gt;&gt;&gt; let bld :: Int -&gt; B.Builder; bld i = B.intDec i &lt;&gt; B.word8 0x20
--   
--   &gt;&gt;&gt; let lbs = B.toLazyByteString $ foldMap bld [0..]
--   
--   &gt;&gt;&gt; L.take 64 lbs
--   "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"
--   </pre>
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain &lt;math&gt;
--   elements long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be transformed to
--   structures of the <i>same shape</i> by performing an
--   <a>Applicative</a> (or, therefore, <a>Monad</a>) action on each
--   element from left to right.
--   
--   A more detailed description of what <i>same shape</i> means, the
--   various methods, how traversals are constructed, and example advanced
--   use-cases can be found in the <b>Overview</b> section of
--   <a>Data.Traversable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Traversable#laws</a>.
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   In the first two examples we show each evaluated action mapping to the
--   output structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse Just [1,2,3,4]
--   Just [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   In the next examples, we show that <a>Nothing</a> and <a>Left</a>
--   values short circuit the created structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
--   Left 0
--   </pre>
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   For the first two examples we show sequenceA fully evaluating a a
--   structure and collecting the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3]
--   Right [1,2,3]
--   </pre>
--   
--   The next two example show <a>Nothing</a> and <a>Just</a> will short
--   circuit the resulting structure if present in the input. For more
--   context, check the <a>Traversable</a> instances for <a>Either</a> and
--   <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3, Nothing]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3, Left 4]
--   Left 4
--   </pre>
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
--   
--   See <a>Data.List</a> for operations on lists.
type String = [Char]

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data Char

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (fit into an <a>Int</a>), <a>IS</a> constructor
--   is used. Otherwise <a>Integer</a> and <a>IN</a> constructors are used
--   to store a <a>BigNat</a> representing respectively the positive or the
--   negative value magnitude.
--   
--   Invariant: <a>Integer</a> and <a>IN</a> are used iff value doesn't fit
--   in <a>IS</a>
data Integer

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data IO a

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOException</a> instead of returning a
--   result. For a more general type of exception, including also those
--   that arise in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Construct an <a>IOException</a> value with a string describing the
--   error. The <tt>fail</tt> method of the <a>IO</a> instance of the
--   <a>Monad</a> class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]
odd :: Integral a => a -> Bool

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a
even :: Integral a => a -> Bool

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of the function
--   applied to corresponding elements, analogous to <a>zipWith</a>. It is
--   capable of list fusion, but it is restricted to its first list
--   argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   For example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; take 3 []
--   []
--   
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   
--   &gt;&gt;&gt; tail [1]
--   []
--   
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>
tail :: [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanl1 (+) [1..]
--   * Hangs forever *
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   
--   &gt;&gt;&gt; scanl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <pre>
--   &gt;&gt;&gt; take 20 $ repeat 17
--   [17,17,17,17,17,17,17,17,17...
--   </pre>
repeat :: a -> [a]

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
last :: [a] -> a

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False...
--   
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63...
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
init :: [a] -> [a]

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   
--   &gt;&gt;&gt; head [1..]
--   1
--   
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>
head :: [a] -> a

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   
--   &gt;&gt;&gt; drop 3 []
--   []
--   
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   
--   &gt;&gt;&gt; take 20 $ cycle [42]
--   [42,42,42,42,42,42,42,42,42,42...
--   
--   &gt;&gt;&gt; take 20 $ cycle [2, 5, 7]
--   [2,5,7,2,5,7,2,5,7,2,5,7...
--   </pre>
cycle :: [a] -> [a]

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: forall (r :: RuntimeRep) (a :: TYPE r). [Char] -> a

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => [Char] -> a

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "not"
not :: Bool -> Bool

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | A Prime is a function that transforms an XConfig. It's not a monad,
--   but we turn on RebindableSyntax so we can abuse the pretty do
--   notation.
type Prime l l' = Arr (XConfig l) (XConfig l')

-- | An Arr is a generalization of Prime. Don't reference the type, if you
--   can avoid it. It might go away in the future.
type Arr x y = x -> IO y

-- | Composes two Arrs using <a>&gt;&gt;=</a> from <a>Prelude</a>.
(>>) :: Arr x y -> Arr y z -> Arr x z

-- | Because of RebindableSyntax, this is necessary to enable you to use
--   if-then-else expressions. No need to call it directly.
ifThenElse :: Bool -> a -> a -> a
instance Data.Default.Class.Default XMonad.Config.Prime.ScreenConfig
instance Data.Default.Class.Default XMonad.Config.Prime.WorkspaceConfig
instance XMonad.Config.Prime.SummableClass XMonad.Config.Prime.MouseBindings [((Graphics.X11.Types.ButtonMask, Graphics.X11.Types.Button), Graphics.X11.Types.Window -> XMonad.Core.X ())]
instance XMonad.Config.Prime.RemovableClass XMonad.Config.Prime.MouseBindings [(Graphics.X11.Types.ButtonMask, Graphics.X11.Types.Button)]
instance XMonad.Config.Prime.SummableClass XMonad.Config.Prime.Keys [(GHC.Base.String, XMonad.Core.X ())]
instance XMonad.Config.Prime.RemovableClass XMonad.Config.Prime.Keys [GHC.Base.String]
instance XMonad.Config.Prime.UpdateableClass (XMonad.Config.Prime.Summable x y) x x
instance XMonad.Config.Prime.SummableClass (XMonad.Config.Prime.Summable x y) y
instance XMonad.Config.Prime.UpdateableClass (XMonad.Config.Prime.Settable x) x x
instance XMonad.Config.Prime.UpdateableClass s x y => XMonad.Config.Prime.SettableClass s x y


-- | Navigation2D is an xmonad extension that allows easy directional
--   navigation of windows and screens (in a multi-monitor setup).
module XMonad.Actions.Navigation2D

-- | Convenience function for enabling Navigation2D with typical
--   keybindings. Takes a Navigation2DConfig, an (up, left, down, right)
--   tuple, a mapping from modifier key to action, and a bool to indicate
--   if wrapping should occur, and returns a function from XConfig to
--   XConfig. Example:
--   
--   <pre>
--   navigation2D def (xK_w, xK_a, xK_s, xK_d) [(mod4Mask, windowGo), (mod4Mask .|. shiftMask, windowSwap)] False myConfig
--   </pre>
navigation2D :: Navigation2DConfig -> (KeySym, KeySym, KeySym, KeySym) -> [(ButtonMask, Direction2D -> Bool -> X ())] -> Bool -> XConfig l -> XConfig l

-- | Convenience function for enabling Navigation2D with typical
--   keybindings, using the syntax defined in <a>mkKeymap</a>. Takes a
--   Navigation2DConfig, an (up, left, down, right) tuple, a mapping from
--   key prefix to action, and a bool to indicate if wrapping should occur,
--   and returns a function from XConfig to XConfig. Example:
--   
--   <pre>
--   navigation2DP def ("w", "a", "s", "d") [("M-", windowGo), ("M-S-", windowSwap)] False myConfig
--   </pre>
navigation2DP :: Navigation2DConfig -> (String, String, String, String) -> [(String, Direction2D -> Bool -> X ())] -> Bool -> XConfig l -> XConfig l

-- | Convenience function for adding keybindings. Takes an (up, left, down,
--   right) tuple, a mapping from key prefix to action, and a bool to
--   indicate if wrapping should occur, and returns a function from XConfig
--   to XConfig. Example:
--   
--   <pre>
--   additionalNav2DKeys (xK_w, xK_a, xK_s, xK_d) [(mod4Mask, windowGo), (mod4Mask .|. shiftMask, windowSwap)] False myConfig
--   </pre>
additionalNav2DKeys :: (KeySym, KeySym, KeySym, KeySym) -> [(ButtonMask, Direction2D -> Bool -> X ())] -> Bool -> XConfig l -> XConfig l

-- | Convenience function for adding keybindings, using the syntax defined
--   in <a>mkKeymap</a>. Takes an (up, left, down, right) tuple, a mapping
--   from key prefix to action, and a bool to indicate if wrapping should
--   occur, and returns a function from XConfig to XConfig. Example:
--   
--   <pre>
--   additionalNav2DKeysP ("w", "a", "s", "d") [("M-", windowGo), ("M-S-", windowSwap)] False myConfig
--   </pre>
additionalNav2DKeysP :: (String, String, String, String) -> [(String, Direction2D -> Bool -> X ())] -> Bool -> XConfig l -> XConfig l

-- | Modifies the xmonad configuration to store the Navigation2D
--   configuration
withNavigation2DConfig :: Navigation2DConfig -> XConfig a -> XConfig a

-- | Stores the configuration of directional navigation. The <a>Default</a>
--   instance uses line navigation for the tiled layer and for navigation
--   between screens, and center navigation for the float layer. No custom
--   navigation strategies or rectangles for unmapped windows are defined
--   for individual layouts.
data Navigation2DConfig
Navigation2DConfig :: Navigation2D -> Navigation2D -> Navigation2D -> [(String, Navigation2D)] -> [(String, Screen -> Window -> X (Maybe Rectangle))] -> Navigation2DConfig

-- | default navigation strategy for the tiled layer
[defaultTiledNavigation] :: Navigation2DConfig -> Navigation2D

-- | navigation strategy for the float layer
[floatNavigation] :: Navigation2DConfig -> Navigation2D

-- | strategy for navigation between screens
[screenNavigation] :: Navigation2DConfig -> Navigation2D

-- | association list of customized navigation strategies for different
--   layouts in the tiled layer. Each pair is of the form ("layout
--   description", navigation strategy). If there is no pair in this list
--   whose first component is the name of the current layout, the
--   <a>defaultTiledNavigation</a> strategy is used.
[layoutNavigation] :: Navigation2DConfig -> [(String, Navigation2D)]

-- | list associating functions to calculate rectangles for unmapped
--   windows with layouts to which they are to be applied. Each pair in
--   this list is of the form ("layout description", function), where the
--   function calculates a rectangle for a given unmapped window from the
--   screen it is on and its window ID. See <a>#Finer_Points</a> for how to
--   use this.
[unmappedWindowRect] :: Navigation2DConfig -> [(String, Screen -> Window -> X (Maybe Rectangle))]

-- | The default value for this type.
def :: Default a => a

-- | Encapsulates the navigation strategy
data Navigation2D

-- | Line navigation. To illustrate this navigation strategy, consider
--   navigating to the left from the current window. In this case, we draw
--   a horizontal line through the center of the current window and
--   consider all windows that intersect this horizontal line and whose
--   right boundaries are to the left of the left boundary of the current
--   window. From among these windows, we choose the one with the rightmost
--   right boundary.
lineNavigation :: Navigation2D

-- | Center navigation. Again, consider navigating to the left. Then we
--   consider the cone bounded by the two rays shot at 45-degree angles in
--   north-west and south-west direction from the center of the current
--   window. A window is a candidate to receive the focus if its center
--   lies in this cone. We choose the window whose center has minimum
--   L1-distance from the current window center. The tie breaking strategy
--   for windows with the same distance is a bit complicated (see
--   <a>#Technical_Discussion</a>) but ensures that all windows can be
--   reached and that windows with the same center are traversed in their
--   order in the window stack, that is, in the order <a>focusUp</a> and
--   <a>focusDown</a> would traverse them.
centerNavigation :: Navigation2D

-- | Side navigation. Consider navigating to the right this time. The
--   strategy is to take the line segment forming the right boundary of the
--   current window, and push it to the right until it intersects with at
--   least one other window. Of those windows, one with a point that is the
--   closest to the centre of the line (+1) is selected. This is probably
--   the most intuitive strategy for the tiled layer when using
--   <a>XMonad.Layout.Spacing</a>.
sideNavigation :: Navigation2D

-- | Side navigation with bias. Consider a case where the screen is divided
--   up into three vertical panes; the side panes occupied by one window
--   each and the central pane split across the middle by two windows. By
--   the criteria of side navigation, the two central windows are equally
--   good choices when navigating inwards from one of the side panes. Hence
--   in order to be equitable, symmetric and pleasant to use, different
--   windows are chosen when navigating from different sides. In
--   particular, the lower is chosen when going left and the higher when
--   going right, causing L, L, R, R, L, L, etc to cycle through the four
--   windows clockwise. This is implemented by using a bias of 1.
--   <i>Bias</i> is how many pixels off centre the vertical split can be
--   before this behaviour is lost and the same window chosen every time. A
--   negative bias swaps the preferred window for each direction. A bias of
--   zero disables the behaviour.
sideNavigationWithBias :: Int -> Navigation2D

-- | Hybrid of two modes of navigation, preferring the motions of the
--   first. Use this if you want to fall back on a second strategy whenever
--   the first does not find a candidate window. E.g. <tt>hybridOf
--   lineNavigation centerNavigation</tt> is a good strategy for the
--   floating layer, and <tt>hybridOf sideNavigation centerNavigation</tt>
--   will enable you to take advantage of some of the latter strategy's
--   more interesting motions in the tiled layer.
hybridOf :: Navigation2D -> Navigation2D -> Navigation2D

-- | Maps each window to a fullscreen rect. This may not be the same
--   rectangle the window maps to under the Full layout or a similar layout
--   if the layout respects statusbar struts. In such cases, it may be
--   better to use <a>singleWindowRect</a>.
fullScreenRect :: Screen -> Window -> X (Maybe Rectangle)

-- | Maps each window to the rectangle it would receive if it was the only
--   window in the layout. Useful, for example, for determining the default
--   rectangle for unmapped windows in a Full layout that respects
--   statusbar struts.
singleWindowRect :: Screen -> Window -> X (Maybe Rectangle)

-- | Switches focus to the closest window in the other layer (floating if
--   the current window is tiled, tiled if the current window is floating).
--   Closest means that the L1-distance between the centers of the windows
--   is minimized.
switchLayer :: X ()

-- | Moves the focus to the next window in the given direction and in the
--   same layer as the current window. The second argument indicates
--   whether navigation should wrap around (e.g., from the left edge of the
--   leftmost screen to the right edge of the rightmost screen).
windowGo :: Direction2D -> Bool -> X ()

-- | Swaps the current window with the next window in the given direction
--   and in the same layer as the current window. (In the floating layer,
--   all that changes for the two windows is their stacking order if
--   they're on the same screen. If they're on different screens, each
--   window is moved to the other window's screen but retains its position
--   and size relative to the screen.) The second argument indicates
--   wrapping (see <a>windowGo</a>).
windowSwap :: Direction2D -> Bool -> X ()

-- | Moves the current window to the next screen in the given direction.
--   The second argument indicates wrapping (see <a>windowGo</a>).
windowToScreen :: Direction2D -> Bool -> X ()

-- | Moves the focus to the next screen in the given direction. The second
--   argument indicates wrapping (see <a>windowGo</a>).
screenGo :: Direction2D -> Bool -> X ()

-- | Swaps the workspace on the current screen with the workspace on the
--   screen in the given direction. The second argument indicates wrapping
--   (see <a>windowGo</a>).
screenSwap :: Direction2D -> Bool -> X ()

-- | Two-dimensional directions:
data Direction2D

-- | Up
U :: Direction2D

-- | Down
D :: Direction2D

-- | Right
R :: Direction2D

-- | Left
L :: Direction2D
instance GHC.Show.Show XMonad.Actions.Navigation2D.SideRect
instance XMonad.Core.ExtensionClass XMonad.Actions.Navigation2D.Navigation2DConfig
instance Data.Default.Class.Default XMonad.Actions.Navigation2D.Navigation2DConfig
instance GHC.Classes.Eq XMonad.Actions.Navigation2D.Navigation2D
instance GHC.Classes.Ord XMonad.Actions.Navigation2D.Navigation2D


-- | A module that allows the user to use a prefix argument (raw or
--   numeric).
module XMonad.Actions.Prefix
data PrefixArgument
Raw :: Int -> PrefixArgument
Numeric :: Int -> PrefixArgument
None :: PrefixArgument

-- | Set up Prefix. Defaults to C-u when given an invalid key.
--   
--   See usage section.
usePrefixArgument :: LayoutClass l Window => String -> XConfig l -> XConfig l

-- | Set Prefix up with default prefix key (C-u).
useDefaultPrefixArgument :: LayoutClass l Window => XConfig l -> XConfig l

-- | Turn a prefix-aware X action into an X-action.
--   
--   First, fetch the current prefix, then pass it as argument to the
--   original function. You should use this to "run" your commands.
withPrefixArgument :: (PrefixArgument -> X a) -> X a

-- | Test if <a>PrefixArgument</a> is <a>Raw</a> or not.
isPrefixRaw :: PrefixArgument -> Bool

-- | Test if <a>PrefixArgument</a> is <a>Numeric</a> or not.
isPrefixNumeric :: PrefixArgument -> Bool

-- | Execute the first action, unless any prefix argument is given, in
--   which case the second action is chosen instead.
--   
--   <pre>
--   action1 `orIfPrefixed` action2
--   </pre>
orIfPrefixed :: X a -> X a -> X a

-- | Format the prefix using the Emacs convetion for use in a statusbar,
--   like xmobar.
--   
--   To add this formatted prefix to printer output, you can set it up like
--   so
--   
--   <pre>
--   myPrinter :: PP
--   myPrinter = def { ppExtras = [ppFormatPrefix] }
--   </pre>
--   
--   And then add to your status bar using <a>XMonad.Hooks.StatusBar</a>:
--   
--   <pre>
--   mySB = statusBarProp "xmobar" myPrinter
--   main = xmonad $ withEasySB mySB defToggleStrutsKey def
--   </pre>
--   
--   Or, directly in your <a>logHook</a> configuration
--   
--   <pre>
--   logHook = dynamicLogWithPP myPrinter
--   </pre>
ppFormatPrefix :: X (Maybe String)
instance GHC.Show.Show XMonad.Actions.Prefix.PrefixArgument
instance GHC.Read.Read XMonad.Actions.Prefix.PrefixArgument
instance XMonad.Core.ExtensionClass XMonad.Actions.Prefix.PrefixArgument


-- | ShowText displays text for sometime on the screen similar to
--   <a>XMonad.Util.Dzen</a> which offers more features (currently)
module XMonad.Actions.ShowText

-- | The default value for this type.
def :: Default a => a

-- | Handles timer events that notify when a window should be removed
handleTimerEvent :: Event -> X All

-- | Shows a window in the center of the screen with the given text
flashText :: ShowTextConfig -> Rational -> String -> X ()
data ShowTextConfig
STC :: String -> String -> String -> ShowTextConfig

-- | Font name
[st_font] :: ShowTextConfig -> String

-- | Background color
[st_bg] :: ShowTextConfig -> String

-- | Foreground color
[st_fg] :: ShowTextConfig -> String
instance GHC.Show.Show XMonad.Actions.ShowText.ShowText
instance GHC.Read.Read XMonad.Actions.ShowText.ShowText
instance Data.Default.Class.Default XMonad.Actions.ShowText.ShowTextConfig
instance XMonad.Core.ExtensionClass XMonad.Actions.ShowText.ShowText


-- | A layout modifier to resize windows with the mouse by grabbing the
--   window's lower right corner.
--   
--   This module must be used together with
--   <a>XMonad.Layout.WindowArranger</a>.
module XMonad.Actions.MouseResize
mouseResize :: l a -> ModifiedLayout MouseResize l a
newtype MouseResize a
MR :: [((a, Rectangle), Maybe a)] -> MouseResize a
instance GHC.Show.Show (XMonad.Actions.MouseResize.MouseResize a)
instance GHC.Read.Read (XMonad.Actions.MouseResize.MouseResize a)
instance XMonad.Layout.LayoutModifier.LayoutModifier XMonad.Actions.MouseResize.MouseResize Graphics.X11.Types.Window


-- | A basic floating layout.
module XMonad.Layout.SimpleFloat

-- | A simple floating layout where every window is placed according to the
--   window's initial attributes.
--   
--   This version is decorated with the <a>SimpleDecoration</a> style.
simpleFloat :: Eq a => ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | Same as <a>simpleFloat</a>, but with the possibility of setting a
--   custom shrinker and a custom theme.
simpleFloat' :: (Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a
newtype SimpleDecoration a
Simple :: Bool -> SimpleDecoration a
newtype SimpleFloat a
SF :: Dimension -> SimpleFloat a
shrinkText :: DefaultShrinker
data CustomShrink
CustomShrink :: CustomShrink
class (Read s, Show s) => Shrinker s
shrinkIt :: Shrinker s => s -> String -> [String]
instance GHC.Read.Read (XMonad.Layout.SimpleFloat.SimpleFloat a)
instance GHC.Show.Show (XMonad.Layout.SimpleFloat.SimpleFloat a)
instance XMonad.Core.LayoutClass XMonad.Layout.SimpleFloat.SimpleFloat Graphics.X11.Types.Window


-- | This module specifies my xmonad defaults.

-- | <i>Deprecated: This module contains a personal configuration, to be
--   removed from xmonad-contrib. If you use this module, please copy the
--   relevant parts to your configuration or obtain a copy of it on
--   <a>https://xmonad.org/configurations.html</a> and include it as a
--   local module.</i>
module XMonad.Config.Arossato
arossatoConfig :: MonadIO m => m (XConfig (ModifiedLayout AvoidStruts (Choose (ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat))) (Choose (ModifiedLayout WithBorder (ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest)) (ModifiedLayout WindowArranger (Choose (ModifiedLayout Magnifier Tall) (Choose (ModifiedLayout WithBorder Full) (Choose (Mirror Tall) Accordion))))))))


-- | A collection of decorated layouts: some of them may be nice, some
--   usable, others just funny.
module XMonad.Layout.DecorationMadness

-- | A <a>CircleEx</a> layout with the xmonad default decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/circleSimpleDefault.png</a>
circleSimpleDefault :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) CircleEx Window

-- | Similar to <a>circleSimpleDefault</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
circleDefault :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) CircleEx Window

-- | A <a>CircleEx</a> layout with the xmonad default decoration, default
--   theme and default shrinker, but with the possibility of moving windows
--   with the mouse, and resize/move them with the keyboard.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/circleSimpleDefaultResizable.png</a>
circleSimpleDefaultResizable :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger CircleEx)) Window

-- | Similar to <a>circleSimpleDefaultResizable</a> but with the
--   possibility of setting a custom shrinker and a custom theme.
circleDefaultResizable :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger CircleEx)) Window

-- | A <a>CircleEx</a> layout with the xmonad simple decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/circleSimpleDeco.png</a>
circleSimpleDeco :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) CircleEx Window

-- | A <a>CircleEx</a> layout with the xmonad simple decoration, default
--   theme and default shrinker, but with the possibility of moving windows
--   with the mouse, and resize/move them with the keyboard.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/circleSimpleDecoResizable.png</a>
circleSimpleDecoResizable :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger CircleEx)) Window

-- | Similar to <tt>circleSimpleDece</tt> but with the possibility of
--   setting a custom shrinker and a custom theme.
circleDeco :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) CircleEx Window

-- | Similar to <a>circleSimpleDecoResizable</a> but with the possibility
--   of setting a custom shrinker and a custom theme.
circleDecoResizable :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger CircleEx)) Window

-- | A <a>CircleEx</a> layout with the xmonad DwmStyle decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/circleSimpleDwmStyle.png</a>
circleSimpleDwmStyle :: ModifiedLayout (Decoration DwmStyle DefaultShrinker) CircleEx Window

-- | Similar to <a>circleSimpleDwmStyle</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
circleDwmStyle :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration DwmStyle s) CircleEx Window

-- | A <a>CircleEx</a> layout with the xmonad tabbed decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/circleSimpleTabbed.png</a>
circleSimpleTabbed :: ModifiedLayout (Decoration TabBarDecoration DefaultShrinker) (ModifiedLayout ResizeScreen CircleEx) Window

-- | Similar to <a>circleSimpleTabbed</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
circleTabbed :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration TabBarDecoration s) (ModifiedLayout ResizeScreen CircleEx) Window

-- | An <a>Accordion</a> layout with the xmonad default decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/accordionSimpleDefault.png</a>
accordionSimpleDefault :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) Accordion Window

-- | Similar to <a>accordionSimpleDefault</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
accordionDefault :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) Accordion Window

-- | An <a>Accordion</a> layout with the xmonad default decoration, default
--   theme and default shrinker, but with the possibility of moving windows
--   with the mouse, and resize/move them with the keyboard.
accordionSimpleDefaultResizable :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Accordion)) Window

-- | Similar to <a>accordionSimpleDefaultResizable</a> but with the
--   possibility of setting a custom shrinker and a custom theme.
accordionDefaultResizable :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Accordion)) Window

-- | An <a>Accordion</a> layout with the xmonad simple decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/accordionSimpleDeco.png</a>
accordionSimpleDeco :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) Accordion Window

-- | An <a>Accordion</a> layout with the xmonad simple decoration, default
--   theme and default shrinker, but with the possibility of moving windows
--   with the mouse, and resize/move them with the keyboard.
accordionSimpleDecoResizable :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Accordion)) Window

-- | Similar to <tt>accordionSimpleDece</tt> but with the possibility of
--   setting a custom shrinker and a custom theme.
accordionDeco :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) Accordion Window

-- | Similar to <a>accordionSimpleDecoResizable</a> but with the
--   possibility of setting a custom shrinker and a custom theme.
accordionDecoResizable :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Accordion)) Window

-- | An <a>Accordion</a> layout with the xmonad DwmStyle decoration,
--   default theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/accordionSimpleDwmStyle.png</a>
accordionSimpleDwmStyle :: ModifiedLayout (Decoration DwmStyle DefaultShrinker) Accordion Window

-- | Similar to <a>accordionSimpleDwmStyle</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
accordionDwmStyle :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration DwmStyle s) Accordion Window

-- | An <a>Accordion</a> layout with the xmonad tabbed decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/accordionSimpleTabbed.png</a>
accordionSimpleTabbed :: ModifiedLayout (Decoration TabBarDecoration DefaultShrinker) (ModifiedLayout ResizeScreen Accordion) Window

-- | Similar to <a>accordionSimpleTabbed</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
accordionTabbed :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration TabBarDecoration s) (ModifiedLayout ResizeScreen Accordion) Window

-- | A <a>Tall</a> layout with the xmonad default decoration, default theme
--   and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/tallSimpleDefault.png</a>
tallSimpleDefault :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) Tall Window

-- | Similar to <a>tallSimpleDefault</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
tallDefault :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) Tall Window

-- | A <a>Tall</a> layout with the xmonad default decoration, default theme
--   and default shrinker, but with the possibility of moving windows with
--   the mouse, and resize/move them with the keyboard.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/tallSimpleDefaultResizable.png</a>
tallSimpleDefaultResizable :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Tall)) Window

-- | Similar to <a>tallSimpleDefaultResizable</a> but with the possibility
--   of setting a custom shrinker and a custom theme.
tallDefaultResizable :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Tall)) Window

-- | A <a>Tall</a> layout with the xmonad simple decoration, default theme
--   and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/tallSimpleDeco.png</a>
tallSimpleDeco :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) Tall Window

-- | Similar to <tt>tallSimpleDece</tt> but with the possibility of setting
--   a custom shrinker and a custom theme.
tallDeco :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) Tall Window

-- | A <a>Tall</a> layout with the xmonad simple decoration, default theme
--   and default shrinker, but with the possibility of moving windows with
--   the mouse, and resize/move them with the keyboard.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/tallSimpleDecoResizable.png</a>
tallSimpleDecoResizable :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Tall)) Window

-- | Similar to <a>tallSimpleDecoResizable</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
tallDecoResizable :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger Tall)) Window

-- | A <a>Tall</a> layout with the xmonad DwmStyle decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/tallSimpleDwmStyle.png</a>
tallSimpleDwmStyle :: ModifiedLayout (Decoration DwmStyle DefaultShrinker) Tall Window

-- | Similar to <a>tallSimpleDwmStyle</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
tallDwmStyle :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration DwmStyle s) Tall Window

-- | A <a>Tall</a> layout with the xmonad tabbed decoration, default theme
--   and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/tallSimpleTabbed.png</a>
tallSimpleTabbed :: ModifiedLayout (Decoration TabBarDecoration DefaultShrinker) (ModifiedLayout ResizeScreen Tall) Window

-- | Similar to <a>tallSimpleTabbed</a> but with the possibility of setting
--   a custom shrinker and a custom theme.
tallTabbed :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration TabBarDecoration s) (ModifiedLayout ResizeScreen Tall) Window

-- | A 'Mirror Tall' layout with the xmonad default decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/mirrorTallSimpleDefault.png</a>
mirrorTallSimpleDefault :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) (Mirror Tall) Window

-- | Similar to <a>mirrorTallSimpleDefault</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
mirrorTallDefault :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) (Mirror Tall) Window

-- | A 'Mirror Tall' layout with the xmonad default decoration, default
--   theme and default shrinker, but with the possibility of moving windows
--   with the mouse, and resize/move them with the keyboard.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/mirrorTallSimpleDefaultResizable.png</a>
mirrorTallSimpleDefaultResizable :: ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger (Mirror Tall))) Window

-- | Similar to <a>mirrorTallSimpleDefaultResizable</a> but with the
--   possibility of setting a custom shrinker and a custom theme.
mirrorTallDefaultResizable :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger (Mirror Tall))) Window

-- | A 'Mirror Tall' layout with the xmonad simple decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/mirrorTallSimpleDeco.png</a>
mirrorTallSimpleDeco :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (Mirror Tall) Window

-- | Similar to <tt>mirrorTallSimpleDece</tt> but with the possibility of
--   setting a custom shrinker and a custom theme.
mirrorTallDeco :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (Mirror Tall) Window

-- | A 'Mirror Tall' layout with the xmonad simple decoration, default
--   theme and default shrinker, but with the possibility of moving windows
--   with the mouse, and resize/move them with the keyboard.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/mirrorTallSimpleDecoResizable.png</a>
mirrorTallSimpleDecoResizable :: ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger (Mirror Tall))) Window

-- | Similar to <a>mirrorTallSimpleDecoResizable</a> but with the
--   possibility of setting a custom shrinker and a custom theme.
mirrorTallDecoResizable :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger (Mirror Tall))) Window

-- | A 'Mirror Tall' layout with the xmonad DwmStyle decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/mirrorTallSimpleDwmStyle.png</a>
mirrorTallSimpleDwmStyle :: ModifiedLayout (Decoration DwmStyle DefaultShrinker) (Mirror Tall) Window

-- | Similar to <a>mirrorTallSimpleDwmStyle</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
mirrorTallDwmStyle :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration DwmStyle s) (Mirror Tall) Window

-- | A 'Mirror Tall' layout with the xmonad tabbed decoration, default
--   theme and default shrinker.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/mirrorTallSimpleTabbed.png</a>
mirrorTallSimpleTabbed :: ModifiedLayout (Decoration TabBarDecoration DefaultShrinker) (ModifiedLayout ResizeScreen (Mirror Tall)) Window

-- | Similar to <a>mirrorTallSimpleTabbed</a> but with the possibility of
--   setting a custom shrinker and a custom theme.
mirrorTallTabbed :: Shrinker s => s -> Theme -> ModifiedLayout (Decoration TabBarDecoration s) (ModifiedLayout ResizeScreen (Mirror Tall)) Window

-- | A simple floating layout where every window is placed according to the
--   window's initial attributes.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/floatSimpleSimple.png</a>
floatSimpleSimple :: (Show a, Eq a) => ModifiedLayout (Decoration SimpleDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a
floatSimple :: (Show a, Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration SimpleDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | This version is decorated with the <a>DefaultDecoration</a> style.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/floatSimpleDefault.png</a>
floatSimpleDefault :: (Show a, Eq a) => ModifiedLayout (Decoration DefaultDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | Same as <a>floatSimpleDefault</a>, but with the possibility of setting
--   a custom shrinker and a custom theme.
floatDefault :: (Show a, Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DefaultDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | This version is decorated with the <a>DwmStyle</a>. Note that this is
--   a keyboard only floating layout.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/floatSimpleDwmStyle.png</a>
floatSimpleDwmStyle :: (Show a, Eq a) => ModifiedLayout (Decoration DwmStyle DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | Same as <a>floatSimpleDwmStyle</a>, but with the possibility of
--   setting a custom shrinker and a custom theme.
floatDwmStyle :: (Show a, Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration DwmStyle s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | This version is decorated with the <tt>TabbedDecoration</tt> style. |
--   Mouse dragging is somehow weird.
--   
--   Here you can find a screen shot:
--   
--   
--   <a>http://code.haskell.org/~arossato/xmonadShots/floatSimpleTabbed.png</a>
floatSimpleTabbed :: (Show a, Eq a) => ModifiedLayout (Decoration TabBarDecoration DefaultShrinker) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | Same as <a>floatSimpleTabbed</a>, but with the possibility of setting
--   a custom shrinker and a custom theme.
floatTabbed :: (Show a, Eq a, Shrinker s) => s -> Theme -> ModifiedLayout (Decoration TabBarDecoration s) (ModifiedLayout MouseResize (ModifiedLayout WindowArranger SimpleFloat)) a

-- | The default value for this type.
def :: Default a => a
shrinkText :: DefaultShrinker


-- | Provides functionality to use key chords to focus a visible window.
--   Overlays a unique key chord (a string) above each visible window and
--   allows the user to select a window by typing that chord. Inspired by
--   <a>vim-easymotion</a>. Thanks to <a>Tom Hinton</a> for some feature
--   inspiration and window sorting code.
module XMonad.Actions.EasyMotion

-- | Display overlay windows and chords for window selection
selectWindow :: EasyMotionConfig -> X (Maybe Window)

-- | Configuration options for EasyMotion.
--   
--   All colors are hex strings, e.g. "#000000"
--   
--   If the number of windows for which chords are required exceeds
--   <a>maxChordLen</a>, chords will simply not be generated for these
--   windows. In this way, single-key selection may be preferred over the
--   ability to select any window.
--   
--   <a>cancelKey</a>, <tt>xK_BackSpace</tt> and any duplicates will be
--   removed from <a>sKeys</a> if included. See <tt>Usage</tt> for examples
--   of <a>sKeys</a>.
data EasyMotionConfig
EMConf :: !String -> !String -> !Position -> Rectangle -> Rectangle -> !String -> !ChordKeys -> !KeySym -> !String -> !Int -> !Int -> EasyMotionConfig

-- | Color of the text displayed
[txtCol] :: EasyMotionConfig -> !String

-- | Color of the window overlaid
[bgCol] :: EasyMotionConfig -> !String

-- | Function to generate overlay rectangle
[overlayF] :: EasyMotionConfig -> !Position -> Rectangle -> Rectangle

-- | Color of the overlay window borders
[borderCol] :: EasyMotionConfig -> !String

-- | Keys to use for window selection
[sKeys] :: EasyMotionConfig -> !ChordKeys

-- | Key to use to cancel selection
[cancelKey] :: EasyMotionConfig -> !KeySym

-- | Font for selection characters (passed to <a>initXMF</a>)
[emFont] :: EasyMotionConfig -> !String

-- | Width of border in pixels
[borderPx] :: EasyMotionConfig -> !Int

-- | Maximum chord length. Use 0 for no maximum.
[maxChordLen] :: EasyMotionConfig -> !Int

-- | Maps keys to windows. <a>AnyKeys</a> maps keys to windows regardless
--   which screen they're on. <a>PerScreenKeys</a> maps keys to screens to
--   windows. See <tt>Usage</tt> for more examples.
data ChordKeys
AnyKeys :: ![KeySym] -> ChordKeys
PerScreenKeys :: !Map ScreenId [KeySym] -> ChordKeys

-- | The default value for this type.
def :: Default a => a

-- | Create overlay windows of the same size as the window they select
fullSize :: Position -> Rectangle -> Rectangle

-- | Create fixed-size overlay windows
fixedSize :: (Integral a, Integral b) => a -> b -> Position -> Rectangle -> Rectangle

-- | Create overlay windows the minimum size to contain their key chord
textSize :: Position -> Rectangle -> Rectangle

-- | Create overlay windows a proportion of the size of the window they
--   select
proportional :: RealFrac f => f -> Position -> Rectangle -> Rectangle

-- | Create overlay windows the full width of the window they select, the
--   minimum height to contain their chord, and a proportion of the
--   distance from the top of the window they select
bar :: RealFrac f => f -> Position -> Rectangle -> Rectangle
instance Data.Default.Class.Default XMonad.Actions.EasyMotion.EasyMotionConfig
