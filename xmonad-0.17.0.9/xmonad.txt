-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A tiling window manager
--   
--   xmonad is a tiling window manager for X. Windows are arranged
--   automatically to tile the screen without gaps or overlap, maximising
--   screen use. All features of the window manager are accessible from the
--   keyboard: a mouse is strictly optional. xmonad is written and
--   extensible in Haskell. Custom layout algorithms, and other extensions,
--   may be written by the user in config files. Layouts are applied
--   dynamically, and different layouts may be used on each workspace.
--   Xinerama is fully supported, allowing windows to be tiled on several
--   screens.
@package xmonad
@version 0.17.0.9


module XMonad.StackSet

-- | A cursor into a non-empty list of workspaces.
--   
--   We puncture the workspace list, producing a hole in the structure used
--   to track the currently focused workspace. The two other lists that are
--   produced are used to track those workspaces visible as Xinerama
--   screens, and those workspaces not visible anywhere.
data StackSet i l a sid sd
StackSet :: !Screen i l a sid sd -> [Screen i l a sid sd] -> [Workspace i l a] -> Map a RationalRect -> StackSet i l a sid sd

-- | currently focused workspace
[current] :: StackSet i l a sid sd -> !Screen i l a sid sd

-- | non-focused workspaces, visible in xinerama
[visible] :: StackSet i l a sid sd -> [Screen i l a sid sd]

-- | workspaces not visible anywhere
[hidden] :: StackSet i l a sid sd -> [Workspace i l a]

-- | floating windows
[floating] :: StackSet i l a sid sd -> Map a RationalRect

-- | A workspace is just a tag, a layout, and a stack.
data Workspace i l a
Workspace :: !i -> l -> Maybe (Stack a) -> Workspace i l a
[tag] :: Workspace i l a -> !i
[layout] :: Workspace i l a -> l
[stack] :: Workspace i l a -> Maybe (Stack a)

-- | Visible workspaces, and their Xinerama screens.
data Screen i l a sid sd
Screen :: !Workspace i l a -> !sid -> !sd -> Screen i l a sid sd
[workspace] :: Screen i l a sid sd -> !Workspace i l a
[screen] :: Screen i l a sid sd -> !sid
[screenDetail] :: Screen i l a sid sd -> !sd

-- | A stack is a cursor onto a window list. The data structure tracks
--   focus by construction, and the master window is by convention the
--   top-most item. Focus operations will not reorder the list that results
--   from flattening the cursor. The structure can be envisaged as:
--   
--   <pre>
--      +-- master:  &lt; '7' &gt;
--   up |            [ '2' ]
--      +---------   [ '3' ]
--   focus:          &lt; '4' &gt;
--   dn +----------- [ '8' ]
--   </pre>
--   
--   A <a>Stack</a> can be viewed as a list with a hole punched in it to
--   make the focused position. Under the zipper/calculus view of such
--   structures, it is the differentiation of a [a], and integrating it
--   back has a natural implementation used in <a>index</a>.
data Stack a
Stack :: !a -> [a] -> [a] -> Stack a
[focus] :: Stack a -> !a
[up] :: Stack a -> [a]
[down] :: Stack a -> [a]

-- | A structure for window geometries
data RationalRect
RationalRect :: !Rational -> !Rational -> !Rational -> !Rational -> RationalRect

-- | <i>O(n)</i>. Create a new stackset, of empty stacks, with given tags,
--   with physical screens whose descriptions are given by <tt>m</tt>. The
--   number of physical screens (<tt>length <tt>m</tt></tt>) should be less
--   than or equal to the number of workspace tags. The first workspace in
--   the list will be current.
--   
--   Xinerama: Virtual workspaces are assigned to physical screens,
--   starting at 0.
new :: Integral s => l -> [i] -> [sd] -> StackSet i l a s sd

-- | <i>O(w)</i>. Set focus to the workspace with index 'i'. If the index
--   is out of range, return the original <a>StackSet</a>.
--   
--   Xinerama: If the workspace is not visible on any Xinerama screen, it
--   becomes the current screen. If it is in the visible list, it becomes
--   current.
view :: (Eq s, Eq i) => i -> StackSet i l a s sd -> StackSet i l a s sd

-- | Set focus to the given workspace. If that workspace does not exist in
--   the stackset, the original workspace is returned. If that workspace is
--   <a>hidden</a>, then display that workspace on the current screen, and
--   move the current workspace to <a>hidden</a>. If that workspace is
--   <a>visible</a> on another screen, the workspaces of the current screen
--   and the other screen are swapped.
greedyView :: (Eq s, Eq i) => i -> StackSet i l a s sd -> StackSet i l a s sd

-- | Find the tag of the workspace visible on Xinerama screen <tt>sc</tt>.
--   <a>Nothing</a> if screen is out of bounds.
lookupWorkspace :: Eq s => s -> StackSet i l a s sd -> Maybe i

-- | Get a list of all screens in the <a>StackSet</a>.
screens :: StackSet i l a s sd -> [Screen i l a s sd]

-- | Get a list of all workspaces in the <a>StackSet</a>.
workspaces :: StackSet i l a s sd -> [Workspace i l a]

-- | Get a list of all windows in the <a>StackSet</a> in no particular
--   order
allWindows :: Eq a => StackSet i l a s sd -> [a]

-- | Get the tag of the currently focused workspace.
currentTag :: StackSet i l a s sd -> i

-- | <i>O(1)</i>. Extract the focused element of the current stack. Return
--   <a>Just</a> that element, or <a>Nothing</a> for an empty stack.
peek :: StackSet i l a s sd -> Maybe a

-- | <i>O(s)</i>. Extract the stack on the current workspace, as a list.
--   The order of the stack is determined by the master window -- it will
--   be the head of the list. The implementation is given by the natural
--   integration of a one-hole list cursor, back to a list.
index :: StackSet i l a s sd -> [a]

-- | <i>O(n)</i>. Flatten a <a>Stack</a> into a list.
integrate :: Stack a -> [a]

-- | <i>O(n)</i>. Flatten a possibly empty stack into a list.
integrate' :: Maybe (Stack a) -> [a]

-- | <i>O(n)</i>. Turn a list into a possibly empty stack (i.e., a zipper):
--   the first element of the list is current, and the rest of the list is
--   down.
differentiate :: [a] -> Maybe (Stack a)

-- | <i>O(1), O(w) on the wrapping case</i>. Move the window focus up the
--   stack, wrapping if we reach the end. The wrapping should model a
--   <tt>cycle</tt> on the current stack. The <tt>master</tt> window and
--   window order are unaffected by movement of focus.
focusUp :: StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(1), O(w) on the wrapping case</i>. Like <a>focusUp</a>, but move
--   the window focus down the stack.
focusDown :: StackSet i l a s sd -> StackSet i l a s sd

-- | A variant of <a>focusUp</a> with the same asymptotics that works on a
--   <a>Stack</a> rather than an entire <a>StackSet</a>.
focusUp' :: Stack a -> Stack a

-- | A variant of <a>focusDown</a> with the same asymptotics that works on
--   a <a>Stack</a> rather than an entire <a>StackSet</a>.
focusDown' :: Stack a -> Stack a

-- | <i>O(s)</i>. Set focus to the master window.
focusMaster :: StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(1) on current window, O(n) in general</i>. Focus the window
--   <tt>w</tt>, and set its workspace as current.
focusWindow :: (Eq s, Eq a, Eq i) => a -> StackSet i l a s sd -> StackSet i l a s sd

-- | Is the given tag present in the <a>StackSet</a>?
tagMember :: Eq i => i -> StackSet i l a s sd -> Bool

-- | Rename a given tag if present in the <a>StackSet</a>.
renameTag :: Eq i => i -> i -> StackSet i l a s sd -> StackSet i l a s sd

-- | Ensure that a given set of workspace tags is present by renaming
--   existing workspaces and/or creating new hidden workspaces as
--   necessary.
ensureTags :: Eq i => l -> [i] -> StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(n)</i>. Is a window in the <a>StackSet</a>?
member :: Eq a => a -> StackSet i l a s sd -> Bool

-- | <i>O(1) on current window, O(n) in general</i>. Return <a>Just</a> the
--   workspace tag of the given window, or <a>Nothing</a> if the window is
--   not in the <a>StackSet</a>.
findTag :: Eq a => a -> StackSet i l a s sd -> Maybe i

-- | Map a function on all the workspaces in the <a>StackSet</a>.
mapWorkspace :: (Workspace i l a -> Workspace i l a) -> StackSet i l a s sd -> StackSet i l a s sd

-- | Map a function on all the layouts in the <a>StackSet</a>.
mapLayout :: (l -> l') -> StackSet i l a s sd -> StackSet i l' a s sd

-- | <i>O(n)</i>. (Complexity due to duplicate check). Insert a new element
--   into the stack, above the currently focused element. The new element
--   is given focus; the previously focused element is moved down.
--   
--   If the element is already in the stackset, the original stackset is
--   returned unmodified.
--   
--   Semantics in Huet's paper is that insert doesn't move the cursor.
--   However, we choose to insert above, and move the focus.
insertUp :: Eq a => a -> StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(1) on current window, O(n) in general</i>. Delete window
--   <tt>w</tt> if it exists. There are 4 cases to consider:
--   
--   <ul>
--   <li>delete on an <a>Nothing</a> workspace leaves it Nothing</li>
--   <li>otherwise, try to move focus to the down</li>
--   <li>otherwise, try to move focus to the up</li>
--   <li>otherwise, you've got an empty workspace, becomes
--   <a>Nothing</a></li>
--   </ul>
--   
--   Behaviour with respect to the master:
--   
--   <ul>
--   <li>deleting the master window resets it to the newly focused
--   window</li>
--   <li>otherwise, delete doesn't affect the master.</li>
--   </ul>
delete :: Ord a => a -> StackSet i l a s sd -> StackSet i l a s sd

-- | Only temporarily remove the window from the stack, thereby not
--   destroying special information saved in the <tt>Stackset</tt>
delete' :: Eq a => a -> StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(n)</i>. 'filter p s' returns the elements of <tt>s</tt> such that
--   <tt>p</tt> evaluates to <a>True</a>. Order is preserved, and focus
--   moves as described for <a>delete</a>.
filter :: (a -> Bool) -> Stack a -> Maybe (Stack a)

-- | <i>O(1), O(w) on the wrapping case</i>. Swap the upwards (left)
--   neighbour in the stack ordering, wrapping if we reach the end. Much
--   like for <a>focusUp</a> and <a>focusDown</a>, the wrapping model
--   should <a>cycle</a> on the current stack.
swapUp :: StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(1), O(w) on the wrapping case</i>. Like <a>swapUp</a>, but for
--   swapping the downwards (right) neighbour.
swapDown :: StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(s)</i>. Set the master window to the focused window. The old
--   master window is swapped in the tiling order with the focused window.
--   Focus stays with the item moved.
swapMaster :: StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(s)</i>. Set the master window to the focused window. The other
--   windows are kept in order and shifted down on the stack, as if you
--   just hit mod-shift-k a bunch of times. Focus stays with the item
--   moved.
shiftMaster :: StackSet i l a s sd -> StackSet i l a s sd

-- | Apply a function, and a default value for <a>Nothing</a>, to modify
--   the current stack.
modify :: Maybe (Stack a) -> (Stack a -> Maybe (Stack a)) -> StackSet i l a s sd -> StackSet i l a s sd

-- | Apply a function to modify the current stack if it isn't empty, and we
--   don't want to empty it.
modify' :: (Stack a -> Stack a) -> StackSet i l a s sd -> StackSet i l a s sd

-- | Given a window, and its preferred rectangle, set it as floating A
--   floating window should already be managed by the <a>StackSet</a>.
float :: Ord a => a -> RationalRect -> StackSet i l a s sd -> StackSet i l a s sd

-- | Clear the floating status of a window
sink :: Ord a => a -> StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(w)</i>. shift. Move the focused element of the current stack to
--   stack <tt>n</tt>, leaving it as the focused element on that stack. The
--   item is inserted above the currently focused element on that
--   workspace. The actual focused workspace doesn't change. If there is no
--   element on the current stack, the original stackSet is returned.
shift :: (Ord a, Eq s, Eq i) => i -> StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(n)</i>. shiftWin. Searches for the specified window <tt>w</tt> on
--   all workspaces of the stackSet and moves it to stack <tt>n</tt>,
--   leaving it as the focused element on that stack. The item is inserted
--   above the currently focused element on that workspace. The actual
--   focused workspace doesn't change. If the window is not found in the
--   stackSet, the original stackSet is returned.
shiftWin :: (Ord a, Eq s, Eq i) => i -> a -> StackSet i l a s sd -> StackSet i l a s sd

-- | this function indicates to catch that an error is expected
abort :: String -> a
instance GHC.Classes.Eq XMonad.StackSet.RationalRect
instance GHC.Read.Read XMonad.StackSet.RationalRect
instance GHC.Show.Show XMonad.StackSet.RationalRect
instance GHC.Base.Functor XMonad.StackSet.Stack
instance GHC.Classes.Eq a => GHC.Classes.Eq (XMonad.StackSet.Stack a)
instance GHC.Read.Read a => GHC.Read.Read (XMonad.StackSet.Stack a)
instance GHC.Show.Show a => GHC.Show.Show (XMonad.StackSet.Stack a)
instance (GHC.Classes.Eq i, GHC.Classes.Eq l, GHC.Classes.Eq a) => GHC.Classes.Eq (XMonad.StackSet.Workspace i l a)
instance (GHC.Read.Read i, GHC.Read.Read l, GHC.Read.Read a) => GHC.Read.Read (XMonad.StackSet.Workspace i l a)
instance (GHC.Show.Show i, GHC.Show.Show l, GHC.Show.Show a) => GHC.Show.Show (XMonad.StackSet.Workspace i l a)
instance (GHC.Classes.Eq i, GHC.Classes.Eq l, GHC.Classes.Eq a, GHC.Classes.Eq sid, GHC.Classes.Eq sd) => GHC.Classes.Eq (XMonad.StackSet.Screen i l a sid sd)
instance (GHC.Read.Read i, GHC.Read.Read l, GHC.Read.Read a, GHC.Read.Read sid, GHC.Read.Read sd) => GHC.Read.Read (XMonad.StackSet.Screen i l a sid sd)
instance (GHC.Show.Show i, GHC.Show.Show l, GHC.Show.Show a, GHC.Show.Show sid, GHC.Show.Show sd) => GHC.Show.Show (XMonad.StackSet.Screen i l a sid sd)
instance (GHC.Classes.Eq i, GHC.Classes.Eq l, GHC.Classes.Eq sid, GHC.Classes.Eq sd, GHC.Classes.Eq a) => GHC.Classes.Eq (XMonad.StackSet.StackSet i l a sid sd)
instance (GHC.Read.Read i, GHC.Read.Read l, GHC.Read.Read sid, GHC.Read.Read sd, GHC.Read.Read a, GHC.Classes.Ord a) => GHC.Read.Read (XMonad.StackSet.StackSet i l a sid sd)
instance (GHC.Show.Show i, GHC.Show.Show l, GHC.Show.Show sid, GHC.Show.Show sd, GHC.Show.Show a) => GHC.Show.Show (XMonad.StackSet.StackSet i l a sid sd)
instance Data.Foldable.Foldable XMonad.StackSet.Stack
instance Data.Traversable.Traversable XMonad.StackSet.Stack


-- | The <a>X</a> monad, a state monad transformer over <a>IO</a>, for the
--   window manager state, and support routines.
module XMonad.Core

-- | The X monad, <a>ReaderT</a> and <a>StateT</a> transformers over
--   <a>IO</a> encapsulating the window manager configuration and state,
--   respectively.
--   
--   Dynamic components may be retrieved with <a>get</a>, static components
--   with <a>ask</a>. With newtype deriving we get readers and state monads
--   instantiated on <a>XConf</a> and <a>XState</a> automatically.
data X a
type WindowSet = StackSet WorkspaceId (Layout Window) Window ScreenId ScreenDetail
type WindowSpace = Workspace WorkspaceId (Layout Window) Window

-- | Virtual workspace indices
type WorkspaceId = String

-- | Physical screen indices
newtype ScreenId
S :: Int -> ScreenId

-- | The <a>Rectangle</a> with screen dimensions
newtype ScreenDetail
SD :: Rectangle -> ScreenDetail
[screenRect] :: ScreenDetail -> Rectangle

-- | XState, the (mutable) window manager state.
data XState
XState :: !WindowSet -> !Set Window -> !Map Window Int -> !Maybe (Position -> Position -> X (), X ()) -> !KeyMask -> !Map String (Either String StateExtension) -> XState

-- | workspace list
[windowset] :: XState -> !WindowSet

-- | the Set of mapped windows
[mapped] :: XState -> !Set Window

-- | the number of expected UnmapEvents
[waitingUnmap] :: XState -> !Map Window Int
[dragging] :: XState -> !Maybe (Position -> Position -> X (), X ())

-- | The numlock modifier
[numberlockMask] :: XState -> !KeyMask

-- | stores custom state information.
--   
--   The module <a>XMonad.Util.ExtensibleState</a> in xmonad-contrib
--   provides additional information and a simple interface for using this.
[extensibleState] :: XState -> !Map String (Either String StateExtension)

-- | XConf, the (read-only) window manager configuration.
data XConf
XConf :: Display -> !XConfig Layout -> !Window -> !Pixel -> !Pixel -> !Map (KeyMask, KeySym) (X ()) -> !Map (KeyMask, Button) (Window -> X ()) -> !Bool -> !Maybe (Position, Position) -> !Maybe Event -> !Directories -> XConf

-- | the X11 display
[display] :: XConf -> Display

-- | initial user configuration
[config] :: XConf -> !XConfig Layout

-- | the root window
[theRoot] :: XConf -> !Window

-- | border color of unfocused windows
[normalBorder] :: XConf -> !Pixel

-- | border color of the focused window
[focusedBorder] :: XConf -> !Pixel

-- | a mapping of key presses to actions
[keyActions] :: XConf -> !Map (KeyMask, KeySym) (X ())

-- | a mapping of button presses to actions
[buttonActions] :: XConf -> !Map (KeyMask, Button) (Window -> X ())

-- | was refocus caused by mouse action?
[mouseFocused] :: XConf -> !Bool

-- | position of the mouse according to the event currently being processed
[mousePosition] :: XConf -> !Maybe (Position, Position)

-- | event currently being processed
[currentEvent] :: XConf -> !Maybe Event

-- | directories to use
[directories] :: XConf -> !Directories
data XConfig l
XConfig :: !String -> !String -> !String -> !l Window -> !ManageHook -> !Event -> X All -> ![String] -> !KeyMask -> !XConfig Layout -> Map (ButtonMask, KeySym) (X ()) -> !XConfig Layout -> Map (ButtonMask, Button) (Window -> X ()) -> !Dimension -> !X () -> !X () -> !Bool -> !Bool -> !EventMask -> !EventMask -> ![String] -> XConfig Layout -> IO (XConfig Layout) -> !Map TypeRep ConfExtension -> XConfig l

-- | Non focused windows border color. Default: "#dddddd"
[normalBorderColor] :: XConfig l -> !String

-- | Focused windows border color. Default: "#ff0000"
[focusedBorderColor] :: XConfig l -> !String

-- | The preferred terminal application. Default: "xterm"
[terminal] :: XConfig l -> !String

-- | The available layouts
[layoutHook] :: XConfig l -> !l Window

-- | The action to run when a new window is opened
[manageHook] :: XConfig l -> !ManageHook

-- | Handle an X event, returns (All True) if the default handler should
--   also be run afterwards. mappend should be used for combining event
--   hooks in most cases.
[handleEventHook] :: XConfig l -> !Event -> X All

-- | The list of workspaces' names
[workspaces] :: XConfig l -> ![String]

-- | the mod modifier
[modMask] :: XConfig l -> !KeyMask

-- | The key binding: a map from key presses and actions
[keys] :: XConfig l -> !XConfig Layout -> Map (ButtonMask, KeySym) (X ())

-- | The mouse bindings
[mouseBindings] :: XConfig l -> !XConfig Layout -> Map (ButtonMask, Button) (Window -> X ())

-- | The border width
[borderWidth] :: XConfig l -> !Dimension

-- | The action to perform when the windows set is changed
[logHook] :: XConfig l -> !X ()

-- | The action to perform on startup
[startupHook] :: XConfig l -> !X ()

-- | Whether window entry events can change focus
[focusFollowsMouse] :: XConfig l -> !Bool

-- | False to make a click which changes focus to be additionally passed to
--   the window
[clickJustFocuses] :: XConfig l -> !Bool

-- | The client events that xmonad is interested in
[clientMask] :: XConfig l -> !EventMask

-- | The root events that xmonad is interested in
[rootMask] :: XConfig l -> !EventMask

-- | Modify the configuration, complain about extra arguments etc. with
--   arguments that are not handled by default
[handleExtraArgs] :: XConfig l -> ![String] -> XConfig Layout -> IO (XConfig Layout)

-- | Stores custom config information.
--   
--   The module <a>XMonad.Util.ExtensibleConf</a> in xmonad-contrib
--   provides additional information and a simple interface for using this.
[extensibleConf] :: XConfig l -> !Map TypeRep ConfExtension

-- | Every layout must be an instance of <a>LayoutClass</a>, which defines
--   the basic layout operations along with a sensible default for each.
--   
--   All of the methods have default implementations, so there is no
--   minimal complete definition. They do, however, have a dependency
--   structure by default; this is something to be aware of should you
--   choose to implement one of these methods. Here is how a minimal
--   complete definition would look like if we did not provide any default
--   implementations:
--   
--   <ul>
--   <li><a>runLayout</a> || ((<a>doLayout</a> || <a>pureLayout</a>)
--   &amp;&amp; <a>emptyLayout</a>)</li>
--   <li><a>handleMessage</a> || <a>pureMessage</a></li>
--   <li><a>description</a></li>
--   </ul>
--   
--   Note that any code which <i>uses</i> <a>LayoutClass</a> methods should
--   only ever call <a>runLayout</a>, <a>handleMessage</a>, and
--   <a>description</a>! In other words, the only calls to <a>doLayout</a>,
--   <a>pureMessage</a>, and other such methods should be from the default
--   implementations of <a>runLayout</a>, <a>handleMessage</a>, and so on.
--   This ensures that the proper methods will be used, regardless of the
--   particular methods that any <a>LayoutClass</a> instance chooses to
--   define.
class (Show (layout a), Typeable layout) => LayoutClass layout a

-- | By default, <a>runLayout</a> calls <a>doLayout</a> if there are any
--   windows to be laid out, and <a>emptyLayout</a> otherwise. Most
--   instances of <a>LayoutClass</a> probably do not need to implement
--   <a>runLayout</a>; it is only useful for layouts which wish to make use
--   of more of the <a>Workspace</a> information (for example,
--   <a>XMonad.Layout.PerWorkspace</a>).
runLayout :: LayoutClass layout a => Workspace WorkspaceId (layout a) a -> Rectangle -> X ([(a, Rectangle)], Maybe (layout a))

-- | Given a <a>Rectangle</a> in which to place the windows, and a
--   <a>Stack</a> of windows, return a list of windows and their
--   corresponding Rectangles. If an element is not given a Rectangle by
--   <a>doLayout</a>, then it is not shown on screen. The order of windows
--   in this list should be the desired stacking order.
--   
--   Also possibly return a modified layout (by returning <tt>Just
--   newLayout</tt>), if this layout needs to be modified (e.g. if it keeps
--   track of some sort of state). Return <tt>Nothing</tt> if the layout
--   does not need to be modified.
--   
--   Layouts which do not need access to the <a>X</a> monad (<a>IO</a>,
--   window manager state, or configuration) and do not keep track of their
--   own state should implement <a>pureLayout</a> instead of
--   <a>doLayout</a>.
doLayout :: LayoutClass layout a => layout a -> Rectangle -> Stack a -> X ([(a, Rectangle)], Maybe (layout a))

-- | This is a pure version of <a>doLayout</a>, for cases where we don't
--   need access to the <a>X</a> monad to determine how to lay out the
--   windows, and we don't need to modify the layout itself.
pureLayout :: LayoutClass layout a => layout a -> Rectangle -> Stack a -> [(a, Rectangle)]

-- | <a>emptyLayout</a> is called when there are no windows.
emptyLayout :: LayoutClass layout a => layout a -> Rectangle -> X ([(a, Rectangle)], Maybe (layout a))

-- | <a>handleMessage</a> performs message handling. If
--   <a>handleMessage</a> returns <tt>Nothing</tt>, then the layout did not
--   respond to the message and the screen is not refreshed. Otherwise,
--   <a>handleMessage</a> returns an updated layout and the screen is
--   refreshed.
--   
--   Layouts which do not need access to the <a>X</a> monad to decide how
--   to handle messages should implement <a>pureMessage</a> instead of
--   <a>handleMessage</a> (this restricts the risk of error, and makes
--   testing much easier).
handleMessage :: LayoutClass layout a => layout a -> SomeMessage -> X (Maybe (layout a))

-- | Respond to a message by (possibly) changing our layout, but taking no
--   other action. If the layout changes, the screen will be refreshed.
pureMessage :: LayoutClass layout a => layout a -> SomeMessage -> Maybe (layout a)

-- | This should be a human-readable string that is used when selecting
--   layouts by name. The default implementation is <a>show</a>, which is
--   in some cases a poor default.
description :: LayoutClass layout a => layout a -> String

-- | An existential type that can hold any object that is in <a>Read</a>
--   and <a>LayoutClass</a>.
data Layout a
Layout :: l a -> Layout a

-- | Using the <a>Layout</a> as a witness, parse existentially wrapped
--   windows from a <a>String</a>.
readsLayout :: Layout a -> String -> [(Layout a, String)]

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)

-- | Based on ideas in /An Extensible Dynamically-Typed Hierarchy of
--   Exceptions/, Simon Marlow, 2006. Use extensible messages to the
--   <a>handleMessage</a> handler.
--   
--   User-extensible messages must be a member of this class.
class Typeable a => Message a

-- | A wrapped value of some type in the <a>Message</a> class.
data SomeMessage
SomeMessage :: a -> SomeMessage

-- | And now, unwrap a given, unknown <a>Message</a> type, performing a
--   (dynamic) type check on the result.
fromMessage :: Message m => SomeMessage -> Maybe m

-- | <a>LayoutMessages</a> are core messages that all layouts (especially
--   stateful layouts) should consider handling.
data LayoutMessages

-- | sent when a layout becomes non-visible
Hide :: LayoutMessages

-- | sent when xmonad is exiting or restarting
ReleaseResources :: LayoutMessages

-- | Existential type to store a state extension.
data StateExtension

-- | Non-persistent state extension
StateExtension :: a -> StateExtension

-- | Persistent extension
PersistentExtension :: a -> StateExtension

-- | Every module must make the data it wants to store an instance of this
--   class.
--   
--   Minimal complete definition: initialValue
class Typeable a => ExtensionClass a

-- | Defines an initial value for the state extension
initialValue :: ExtensionClass a => a

-- | Specifies whether the state extension should be persistent. Setting
--   this method to <a>PersistentExtension</a> will make the stored data
--   survive restarts, but requires a to be an instance of Read and Show.
--   
--   It defaults to <a>StateExtension</a>, i.e. no persistence.
extensionType :: ExtensionClass a => a -> StateExtension

-- | Existential type to store a config extension.
data ConfExtension
ConfExtension :: a -> ConfExtension

-- | Run the <a>X</a> monad, given a chunk of <a>X</a> monad code, and an
--   initial state Return the result, and final state
runX :: XConf -> XState -> X a -> IO (a, XState)

-- | Run in the <a>X</a> monad, and in case of exception, and catch it and
--   log it to stderr, and run the error case.
catchX :: X a -> X a -> X a

-- | Execute the argument, catching all exceptions. Either this function or
--   <a>catchX</a> should be used at all callsites of user customized code.
userCode :: X a -> X (Maybe a)

-- | Same as userCode but with a default argument to return instead of
--   using Maybe, provided for convenience.
userCodeDef :: a -> X a -> X a

-- | General utilities
--   
--   Lift an <a>IO</a> action into the <a>X</a> monad
io :: MonadIO m => IO a -> m a

-- | Lift an <a>IO</a> action into the <a>X</a> monad. If the action
--   results in an <a>IO</a> exception, log the exception to stderr and
--   continue normal execution.
catchIO :: MonadIO m => IO () -> m ()

-- | Ignore SIGPIPE to avoid termination when a pipe is full, and SIGCHLD
--   to avoid zombie processes, and clean up any extant zombie processes.
installSignalHandlers :: MonadIO m => m ()
uninstallSignalHandlers :: MonadIO m => m ()

-- | Run a monad action with the current display settings
withDisplay :: (Display -> X a) -> X a

-- | Run a monadic action with the current stack set
withWindowSet :: (WindowSet -> X a) -> X a

-- | True if the given window is the root window
isRoot :: Window -> X Bool

-- | This is basically a map function, running a function in the <a>X</a>
--   monad on each workspace with the output of that function being the
--   modified workspace.
runOnWorkspaces :: (WindowSpace -> X WindowSpace) -> X ()

-- | Wrapper for the common case of atom internment
getAtom :: String -> X Atom

-- | spawn. Launch an external application. Specifically, it double-forks
--   and runs the <a>String</a> you pass as a command to /bin/sh.
--   
--   Note this function assumes your locale uses utf8.
spawn :: MonadIO m => String -> m ()

-- | Like <a>spawn</a>, but returns the <a>ProcessID</a> of the launched
--   application
spawnPID :: MonadIO m => String -> m ProcessID

-- | A replacement for <a>forkProcess</a> which resets default signal
--   handlers.
xfork :: MonadIO m => IO () -> m ProcessID

-- | Use <tt>xmessage</tt> to show information to the user.
xmessage :: MonadIO m => String -> m ()

-- | Recompile the xmonad configuration file when any of the following
--   apply:
--   
--   <ul>
--   <li>force is <a>True</a></li>
--   <li>the xmonad executable does not exist</li>
--   <li>the xmonad executable is older than <tt>xmonad.hs</tt> or any file
--   in the <tt>lib</tt> directory (under the configuration directory)</li>
--   <li>custom <tt>build</tt> script is being used</li>
--   </ul>
--   
--   The -i flag is used to restrict recompilation to the xmonad.hs file
--   only, and any files in the aforementioned <tt>lib</tt> directory.
--   
--   Compilation errors (if any) are logged to the <tt>xmonad.errors</tt>
--   file in the xmonad data directory. If GHC indicates failure with a
--   non-zero exit code, an xmessage displaying that file is spawned.
--   
--   <a>False</a> is returned if there are compilation errors.
recompile :: MonadIO m => Directories -> Bool -> m Bool

-- | A <a>trace</a> for the <a>X</a> monad. Logs a string to stderr. The
--   result may be found in your .xsession-errors file
trace :: MonadIO m => String -> m ()

-- | Conditionally run an action, using a <tt>Maybe a</tt> to decide.
whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()

-- | Conditionally run an action, using a <a>X</a> event to decide
whenX :: X Bool -> X () -> X ()

-- | Return the path to the xmonad configuration directory.

-- | <i>Deprecated: Use `asks (cfgDir . directories)' instead.</i>
getXMonadDir :: X String

-- | Return the path to the xmonad cache directory.

-- | <i>Deprecated: Use `asks (cacheDir . directories)' instead.</i>
getXMonadCacheDir :: X String

-- | Return the path to the xmonad data directory.

-- | <i>Deprecated: Use `asks (dataDir . directories)' instead.</i>
getXMonadDataDir :: X String
stateFileName :: Directories -> FilePath
binFileName :: Directories -> FilePath

-- | Common non-predefined atoms
atom_WM_STATE :: X Atom

-- | Common non-predefined atoms
atom_WM_PROTOCOLS :: X Atom

-- | Common non-predefined atoms
atom_WM_DELETE_WINDOW :: X Atom

-- | Common non-predefined atoms
atom_WM_TAKE_FOCUS :: X Atom

-- | Safely access window attributes.
withWindowAttributes :: Display -> Window -> (WindowAttributes -> X ()) -> X ()
type ManageHook = Query (Endo WindowSet)
newtype Query a
Query :: ReaderT Window X a -> Query a
runQuery :: Query a -> Window -> X a

-- | All the directories that xmonad will use. They will be used for the
--   following purposes:
--   
--   <ul>
--   <li><tt>dataDir</tt>: This directory is used by XMonad to store data
--   files such as the run-time state file.</li>
--   <li><tt>cfgDir</tt>: This directory is where user configuration files
--   are stored (e.g, the xmonad.hs file). You may also create a
--   <tt>lib</tt> subdirectory in the configuration directory and the
--   default recompile command will add it to the GHC include path.</li>
--   <li><tt>cacheDir</tt>: This directory is used to store temporary files
--   that can easily be recreated such as the configuration binary and any
--   intermediate object files generated by GHC. Also, the XPrompt history
--   file goes here.</li>
--   </ul>
--   
--   For how these directories are chosen, see <a>getDirectories</a>.
data Directories' a
Directories :: !a -> !a -> !a -> Directories' a
[dataDir] :: Directories' a -> !a
[cfgDir] :: Directories' a -> !a
[cacheDir] :: Directories' a -> !a

-- | Convenient type alias for the most common case in which one might want
--   to use the <a>Directories</a> type.
type Directories = Directories' FilePath

-- | Build up the <tt>Dirs</tt> that xmonad will use. They are chosen as
--   follows:
--   
--   <ol>
--   <li>If all three of xmonad's environment variables
--   (<tt>XMONAD_DATA_DIR</tt>, <tt>XMONAD_CONFIG_DIR</tt>, and
--   <tt>XMONAD_CACHE_DIR</tt>) are set, use them.</li>
--   <li>If there is a build script called <tt>build</tt> or configuration
--   <tt>xmonad.hs</tt> in <tt>~/.xmonad</tt>, set all three directories to
--   <tt>~/.xmonad</tt>.</li>
--   <li>Otherwise, use the <tt>xmonad</tt> directory in
--   <tt>XDG_DATA_HOME</tt>, <tt>XDG_CONFIG_HOME</tt>, and
--   <tt>XDG_CACHE_HOME</tt> (or their respective fallbacks). These
--   directories are created if necessary.</li>
--   </ol>
--   
--   The xmonad configuration file (or the build script, if present) is
--   always assumed to be in <tt>cfgDir</tt>.
getDirectories :: IO Directories
instance GHC.Real.Real XMonad.Core.ScreenId
instance GHC.Real.Integral XMonad.Core.ScreenId
instance GHC.Num.Num XMonad.Core.ScreenId
instance GHC.Enum.Enum XMonad.Core.ScreenId
instance GHC.Read.Read XMonad.Core.ScreenId
instance GHC.Show.Show XMonad.Core.ScreenId
instance GHC.Classes.Ord XMonad.Core.ScreenId
instance GHC.Classes.Eq XMonad.Core.ScreenId
instance GHC.Read.Read XMonad.Core.ScreenDetail
instance GHC.Show.Show XMonad.Core.ScreenDetail
instance GHC.Classes.Eq XMonad.Core.ScreenDetail
instance GHC.Classes.Eq XMonad.Core.LayoutMessages
instance Data.Traversable.Traversable XMonad.Core.Directories'
instance Data.Foldable.Foldable XMonad.Core.Directories'
instance GHC.Base.Functor XMonad.Core.Directories'
instance GHC.Show.Show a => GHC.Show.Show (XMonad.Core.Directories' a)
instance Control.Monad.IO.Class.MonadIO XMonad.Core.Query
instance Control.Monad.Reader.Class.MonadReader Graphics.X11.Types.Window XMonad.Core.Query
instance GHC.Base.Monad XMonad.Core.Query
instance GHC.Base.Applicative XMonad.Core.Query
instance GHC.Base.Functor XMonad.Core.Query
instance Control.Monad.Reader.Class.MonadReader XMonad.Core.XConf XMonad.Core.X
instance Control.Monad.State.Class.MonadState XMonad.Core.XState XMonad.Core.X
instance Control.Monad.IO.Class.MonadIO XMonad.Core.X
instance Control.Monad.Fail.MonadFail XMonad.Core.X
instance GHC.Base.Monad XMonad.Core.X
instance GHC.Base.Applicative XMonad.Core.X
instance GHC.Base.Functor XMonad.Core.X
instance GHC.Show.Show XMonad.Core.Compile
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (XMonad.Core.X a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (XMonad.Core.X a)
instance Data.Default.Class.Default a => Data.Default.Class.Default (XMonad.Core.X a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (XMonad.Core.Query a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (XMonad.Core.Query a)
instance Data.Default.Class.Default a => Data.Default.Class.Default (XMonad.Core.Query a)
instance XMonad.Core.LayoutClass XMonad.Core.Layout Graphics.X11.Types.Window
instance GHC.Show.Show (XMonad.Core.Layout a)
instance XMonad.Core.Message XMonad.Core.LayoutMessages
instance XMonad.Core.Message Graphics.X11.Xlib.Extras.Event


-- | The collection of core layouts.
module XMonad.Layout

-- | Simple fullscreen mode. Renders the focused window fullscreen.
data Full a
Full :: Full a

-- | The builtin tiling mode of xmonad. Supports <a>Shrink</a>,
--   <a>Expand</a> and <a>IncMasterN</a>.
data Tall a
Tall :: !Int -> !Rational -> !Rational -> Tall a

-- | The default number of windows in the master pane (default: 1)
[tallNMaster] :: Tall a -> !Int

-- | Percent of screen to increment by when resizing panes (default: 3/100)
[tallRatioIncrement] :: Tall a -> !Rational

-- | Default proportion of screen occupied by master pane (default: 1/2)
[tallRatio] :: Tall a -> !Rational

-- | Mirror a layout, compute its 90 degree rotated form.
newtype Mirror l a
Mirror :: l a -> Mirror l a

-- | Change the size of the master pane.
data Resize
Shrink :: Resize
Expand :: Resize

-- | Increase the number of clients in the master pane.
newtype IncMasterN
IncMasterN :: Int -> IncMasterN

-- | A layout that allows users to switch between various layout options.
data Choose l r a
Choose :: CLR -> l a -> r a -> Choose l r a

-- | The layout choice combinator
(|||) :: l a -> r a -> Choose l r a
infixr 5 |||

-- | Choose the current sub-layout (left or right) in <a>Choose</a>.
data CLR
CL :: CLR
CR :: CLR

-- | Messages to change the current layout. Also see <a>JumpToLayout</a>.
data ChangeLayout
FirstLayout :: ChangeLayout
NextLayout :: ChangeLayout

-- | A message to jump to a particular layout, specified by its description
--   string.
--   
--   The argument given to a <a>JumpToLayout</a> message should be the
--   <tt>description</tt> of the layout to be selected. If you use
--   <a>XMonad.Hooks.DynamicLog</a> from <tt>xmonad-contrib</tt>, this is
--   the name of the layout displayed in your status bar. Alternatively,
--   you can use GHCi to determine the proper name to use. For example:
--   
--   <pre>
--   $ ghci
--   GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
--   Loading package base ... linking ... done.
--   :set prompt "&gt; "    -- don't show loaded module names
--   &gt; :m +XMonad.Core   -- load the xmonad core
--   &gt; :m +XMonad.Layout.Grid  -- load whatever module you want to use
--   &gt; description Grid  -- find out what it's called
--   "Grid"
--   </pre>
--   
--   As yet another (possibly easier) alternative, you can use the
--   <a>XMonad.Layout.Renamed</a> module (also in <tt>xmonad-contrib</tt>)
--   to give custom names to your layouts, and use those.
--   
--   For example, if you want to jump directly to the <a>Full</a> layout
--   you can do
--   
--   <pre>
--   , ((modm .|. controlMask, xK_f), sendMessage $ JumpToLayout "Full")
--   </pre>
newtype JumpToLayout
JumpToLayout :: String -> JumpToLayout

-- | Mirror a rectangle.
mirrorRect :: Rectangle -> Rectangle
splitVertically :: Int -> Rectangle -> [Rectangle]
splitHorizontally :: Int -> Rectangle -> [Rectangle]
splitHorizontallyBy :: RealFrac r => r -> Rectangle -> (Rectangle, Rectangle)
splitVerticallyBy :: RealFrac r => r -> Rectangle -> (Rectangle, Rectangle)

-- | Compute the positions for windows using the default two-pane tiling
--   algorithm.
--   
--   The screen is divided into two panes. All clients are then partitioned
--   between these two panes. One pane, the master, by convention has the
--   least number of windows in it.
tile :: Rational -> Rectangle -> Int -> Int -> [Rectangle]
instance GHC.Read.Read (XMonad.Layout.Full a)
instance GHC.Show.Show (XMonad.Layout.Full a)
instance GHC.Read.Read (XMonad.Layout.Tall a)
instance GHC.Show.Show (XMonad.Layout.Tall a)
instance GHC.Read.Read (l a) => GHC.Read.Read (XMonad.Layout.Mirror l a)
instance GHC.Show.Show (l a) => GHC.Show.Show (XMonad.Layout.Mirror l a)
instance GHC.Show.Show XMonad.Layout.ChangeLayout
instance GHC.Classes.Eq XMonad.Layout.ChangeLayout
instance GHC.Classes.Eq XMonad.Layout.CLR
instance GHC.Show.Show XMonad.Layout.CLR
instance GHC.Read.Read XMonad.Layout.CLR
instance (GHC.Show.Show (l a), GHC.Show.Show (r a)) => GHC.Show.Show (XMonad.Layout.Choose l r a)
instance (GHC.Read.Read (l a), GHC.Read.Read (r a)) => GHC.Read.Read (XMonad.Layout.Choose l r a)
instance GHC.Show.Show XMonad.Layout.NextNoWrap
instance GHC.Classes.Eq XMonad.Layout.NextNoWrap
instance XMonad.Core.Message XMonad.Layout.NextNoWrap
instance (XMonad.Core.LayoutClass l a, XMonad.Core.LayoutClass r a) => XMonad.Core.LayoutClass (XMonad.Layout.Choose l r) a
instance XMonad.Core.Message XMonad.Layout.JumpToLayout
instance XMonad.Core.Message XMonad.Layout.ChangeLayout
instance XMonad.Core.LayoutClass l a => XMonad.Core.LayoutClass (XMonad.Layout.Mirror l) a
instance XMonad.Core.LayoutClass XMonad.Layout.Tall a
instance XMonad.Core.LayoutClass XMonad.Layout.Full a
instance XMonad.Core.Message XMonad.Layout.IncMasterN
instance XMonad.Core.Message XMonad.Layout.Resize


-- | Operations. A module for functions that don't cleanly fit anywhere
--   else.
module XMonad.Operations

-- | Add a new window to be managed in the current workspace. Bring it into
--   focus.
--   
--   Whether the window is already managed, or not, it is mapped, has its
--   border set, and its event mask set.
manage :: Window -> X ()

-- | A window no longer exists; remove it from the window list, on whatever
--   workspace it is.
unmanage :: Window -> X ()

-- | Kill the specified window. If we do kill it, we'll get a delete notify
--   back from X.
--   
--   There are two ways to delete a window. Either just kill it, or if it
--   supports the delete protocol, send a delete event (e.g. firefox)
killWindow :: Window -> X ()

-- | Kill the currently focused client.
kill :: X ()

-- | Is the window is under management by xmonad?
isClient :: Window -> X Bool

-- | Set some properties when we initially gain control of a window.
setInitialProperties :: Window -> X ()

-- | Set a window's WM_STATE property.
setWMState :: Window -> Int -> X ()

-- | Set the border color using the window's color map, if possible;
--   otherwise fall back to the color in <tt>Pixel</tt>.
setWindowBorderWithFallback :: Display -> Window -> String -> Pixel -> X ()

-- | Hide a window by unmapping it and setting Iconified.
hide :: Window -> X ()

-- | Show a window by mapping it and setting Normal. This is harmless if
--   the window was already visible.
reveal :: Window -> X ()

-- | Move and resize <tt>w</tt> such that it fits inside the given
--   rectangle, including its border.
tileWindow :: Window -> Rectangle -> X ()

-- | Set the focus to the window on top of the stack, or root
setTopFocus :: X ()

-- | Set focus explicitly to window <tt>w</tt> if it is managed by us, or
--   root. This happens if X notices we've moved the mouse (and perhaps
--   moved the mouse to a new screen).
focus :: Window -> X ()

-- | Detect whether a window has fixed size or is transient. This check can
--   be used to determine whether the window should be floating or not
isFixedSizeOrTransient :: Display -> Window -> X Bool

-- | Modify the current window list with a pure function, and refresh
windows :: (WindowSet -> WindowSet) -> X ()

-- | Render the currently visible workspaces, as determined by the
--   <tt>StackSet</tt>. Also, set focus to the focused window.
--   
--   This is our <tt>view</tt> operation (MVC), in that it pretty prints
--   our model with X calls.
refresh :: X ()

-- | The screen configuration may have changed (due to -- xrandr), update
--   the state and refresh the screen, and reset the gap.
rescreen :: X ()

-- | Modify the <tt>WindowSet</tt> in state with no special handling.
modifyWindowSet :: (WindowSet -> WindowSet) -> X ()

-- | Perform an <tt>X</tt> action and check its return value against a
--   predicate p. If p holds, unwind changes to the <tt>WindowSet</tt> and
--   replay them using <tt>windows</tt>.
windowBracket :: (a -> Bool) -> X a -> X a

-- | Perform an <tt>X</tt> action. If it returns <tt>Any True</tt>, unwind
--   the changes to the <tt>WindowSet</tt> and replay them using
--   <tt>windows</tt>. This is a version of <tt>windowBracket</tt> that
--   discards the return value and handles an <tt>X</tt> action that
--   reports its need for refresh via <tt>Any</tt>.
windowBracket_ :: X Any -> X ()

-- | Remove all events of a given type from the event queue.
clearEvents :: EventMask -> X ()

-- | Clean the list of screens according to the rules documented for
--   nubScreens.
getCleanedScreenInfo :: MonadIO m => Display -> m [Rectangle]

-- | Apply an <a>X</a> operation to the currently focused window, if there
--   is one.
withFocused :: (Window -> X ()) -> X ()

-- | Apply an <a>X</a> operation to all unfocused windows on the current
--   workspace, if there are any.
withUnfocused :: (Window -> X ()) -> X ()

-- | Strip numlock/capslock from a mask.
cleanMask :: KeyMask -> X KeyMask

-- | Combinations of extra modifier masks we need to grab keys/buttons for.
--   (numlock and capslock)
extraModifiers :: X [KeyMask]

-- | Accumulate mouse motion events
mouseDrag :: (Position -> Position -> X ()) -> X () -> X ()

-- | Drag the window under the cursor with the mouse while it is dragged.
mouseMoveWindow :: Window -> X ()

-- | Resize the window under the cursor with the mouse while it is dragged.
mouseResizeWindow :: Window -> X ()

-- | Tell whether or not to intercept clicks on a given window
setButtonGrab :: Bool -> Window -> X ()

-- | Call X to set the keyboard focus details.
setFocusX :: Window -> X ()
cacheNumlockMask :: X ()

-- | Given a list of keybindings, turn the given <a>KeySym</a>s into actual
--   <a>KeyCode</a>s and prepare them for grabbing.
mkGrabs :: [(KeyMask, KeySym)] -> X [(KeyMask, KeyCode)]

-- | Throw a message to the current <a>LayoutClass</a> possibly modifying
--   how we layout the windows, in which case changes are handled through a
--   refresh.
sendMessage :: Message a => a -> X ()

-- | Send a message to all layouts, without refreshing.
broadcastMessage :: Message a => a -> X ()

-- | Send a message to a layout, without refreshing.
sendMessageWithNoRefresh :: Message a => a -> WindowSpace -> X ()

-- | A type to help serialize xmonad's state to a file.
data StateFile
StateFile :: StackSet WorkspaceId String Window ScreenId ScreenDetail -> [(String, String)] -> StateFile
[sfWins] :: StateFile -> StackSet WorkspaceId String Window ScreenId ScreenDetail
[sfExt] :: StateFile -> [(String, String)]

-- | Write the current window state (and extensible state) to a file so
--   that xmonad can resume with that state intact.
writeStateToFile :: X ()

-- | Read the state of a previous xmonad instance from a file and return
--   that state. The state file is removed after reading it.
readStateFile :: (LayoutClass l Window, Read (l Window)) => XConfig l -> X (Maybe XState)

-- | <tt>restart name resume</tt> attempts to restart xmonad by executing
--   the program <tt>name</tt>. If <tt>resume</tt> is <a>True</a>, restart
--   with the current window state. When executing another window manager,
--   <tt>resume</tt> should be <a>False</a>.
restart :: String -> Bool -> X ()

-- | Make a tiled window floating, using its suggested rectangle
float :: Window -> X ()

-- | Given a window, find the screen it is located on, and compute the
--   geometry of that window WRT that screen.
floatLocation :: Window -> X (ScreenId, RationalRect)

-- | An alias for a (width, height) pair
type D = (Dimension, Dimension)

-- | Given a window, build an adjuster function that will reduce the given
--   dimensions according to the window's border width and size hints.
mkAdjust :: Window -> X (D -> D)

-- | Reduce the dimensions if needed to comply to the given SizeHints,
--   taking window borders into account.
applySizeHints :: Integral a => Dimension -> SizeHints -> (a, a) -> D

-- | Use X11 size hints to scale a pair of dimensions.
applySizeHints' :: SizeHints -> D -> D

-- | Reduce the dimensions if needed to comply to the given SizeHints.
applySizeHintsContents :: Integral a => SizeHints -> (a, a) -> D

-- | Reduce the dimensions so their aspect ratio falls between the two
--   given aspect ratios.
applyAspectHint :: (D, D) -> D -> D

-- | Reduce the dimensions so they are a multiple of the size increments.
applyResizeIncHint :: D -> D -> D

-- | Reduce the dimensions if they exceed the given maximum dimensions.
applyMaxSizeHint :: D -> D -> D

-- | Returns <a>True</a> if the first rectangle is contained within, but
--   not equal to the second.
containedIn :: Rectangle -> Rectangle -> Bool

-- | Given a list of screens, remove all duplicated screens and screens
--   that are entirely contained within another.
nubScreens :: [Rectangle] -> [Rectangle]

-- | <tt>pointWithin x y r</tt> returns <a>True</a> if the <tt>(x, y)</tt>
--   co-ordinate is within <tt>r</tt>.
pointWithin :: Position -> Position -> Rectangle -> Bool

-- | Produce the actual rectangle from a screen and a ratio on that screen.
scaleRationalRect :: Rectangle -> RationalRect -> Rectangle

-- | Get the <a>Pixel</a> value for a named color.
initColor :: Display -> String -> IO (Maybe Pixel)

-- | Given a point, determine the screen (if any) that contains it.
pointScreen :: Position -> Position -> X (Maybe (Screen WorkspaceId (Layout Window) Window ScreenId ScreenDetail))

-- | Return workspace visible on screen <tt>sc</tt>, or <a>Nothing</a>.
screenWorkspace :: ScreenId -> X (Maybe WorkspaceId)

-- | Set the layout of the currently viewed workspace.
setLayout :: Layout Window -> X ()

-- | Update the layout field of a workspace.
updateLayout :: WorkspaceId -> Maybe (Layout Window) -> X ()
instance GHC.Read.Read XMonad.Operations.StateFile
instance GHC.Show.Show XMonad.Operations.StateFile


-- | An EDSL for ManageHooks
module XMonad.ManageHook

-- | Lift an <a>X</a> action to a <a>Query</a>.
liftX :: X a -> Query a

-- | The identity hook that returns the WindowSet unchanged.
idHook :: Monoid m => m

-- | Infix <a>mappend</a>. Compose two <a>ManageHook</a> from right to
--   left.
(<+>) :: Monoid m => m -> m -> m

-- | Compose the list of <a>ManageHook</a>s.
composeAll :: Monoid m => [m] -> m

-- | <tt>p --&gt; x</tt>. If <tt>p</tt> returns <a>True</a>, execute the
--   <a>ManageHook</a>.
--   
--   <pre>
--   (--&gt;) :: Monoid m =&gt; Query Bool -&gt; Query m -&gt; Query m -- a simpler type
--   </pre>
(-->) :: (Monad m, Monoid a) => m Bool -> m a -> m a
infix 0 -->

-- | <tt>q =? x</tt>. if the result of <tt>q</tt> equals <tt>x</tt>, return
--   <a>True</a>.
(=?) :: Eq a => Query a -> a -> Query Bool

-- | <a>&amp;&amp;</a> lifted to a <a>Monad</a>.
(<&&>) :: Monad m => m Bool -> m Bool -> m Bool
infixr 3 <&&>

-- | <a>||</a> lifted to a <a>Monad</a>.
(<||>) :: Monad m => m Bool -> m Bool -> m Bool
infixr 3 <||>

-- | If-then-else lifted to a <a>Monad</a>.
ifM :: Monad m => m Bool -> m a -> m a -> m a

-- | Return the window title.
title :: Query String

-- | Return the application name; i.e., the <i>first</i> string returned by
--   <tt>WM_CLASS</tt>.
appName :: Query String

-- | Backwards compatible alias for <a>appName</a>.
resource :: Query String

-- | Return the resource class; i.e., the <i>second</i> string returned by
--   <tt>WM_CLASS</tt>.
className :: Query String

-- | A query that can return an arbitrary X property of type <a>String</a>,
--   identified by name.
stringProperty :: String -> Query String
getStringProperty :: Display -> Window -> String -> X (Maybe String)

-- | Return whether the window will be a floating window or not
willFloat :: Query Bool

-- | Modify the <a>WindowSet</a> with a pure function.
doF :: (s -> s) -> Query (Endo s)

-- | Move the window to the floating layer.
doFloat :: ManageHook

-- | Map the window and remove it from the <a>WindowSet</a>.
doIgnore :: ManageHook

-- | Move the window to a given workspace
doShift :: WorkspaceId -> ManageHook


-- | This module specifies the default configuration values for xmonad.
--   
--   DO NOT MODIFY THIS FILE! It won't work. You may configure xmonad by
--   providing your own <tt>~/.xmonad/xmonad.hs</tt> that overrides
--   specific fields in the default config, <a>def</a>. For a starting
--   point, you can copy the <tt>xmonad.hs</tt> found in the <tt>man</tt>
--   directory, or look at examples on the xmonad wiki.
module XMonad.Config

-- | The default set of configuration values itself

-- | <i>Deprecated: Use def (from Data.Default, and re-exported by XMonad
--   and XMonad.Config) instead.</i>
defaultConfig :: XConfig (Choose Tall (Choose (Mirror Tall) Full))

-- | A class for types with a default value.
class Default a

-- | The default value for this type.
def :: Default a => a
instance (a GHC.Types.~ XMonad.Layout.Choose XMonad.Layout.Tall (XMonad.Layout.Choose (XMonad.Layout.Mirror XMonad.Layout.Tall) XMonad.Layout.Full)) => Data.Default.Class.Default (XMonad.Core.XConfig a)


-- | xmonad, a minimalist, tiling window manager for X11
module XMonad.Main

-- | | The entry point into xmonad. Attempts to compile any custom main for
--   xmonad, and if it doesn't find one, just launches the default.
xmonad :: (LayoutClass l Window, Read (l Window)) => XConfig l -> IO ()

-- | Entry point into xmonad for custom builds.
--   
--   This function isn't meant to be called by the typical xmonad user
--   because it:
--   
--   <ul>
--   <li>Does not process any command line arguments.</li>
--   <li>Therefore doesn't know how to restart a running xmonad.</li>
--   <li>Does not compile your configuration file since it assumes it's
--   actually running from within your compiled configuration.</li>
--   </ul>
--   
--   Unless you know what you are doing, you should probably be using the
--   <a>xmonad</a> function instead.
--   
--   However, if you are using a custom build environment (such as stack,
--   cabal, make, etc.) you will likely want to call this function instead
--   of <a>xmonad</a>. You probably also want to have a key binding to the
--   <a>restart</a> function that restarts your custom binary with the
--   resume flag set to <tt>True</tt>.
launch :: (LayoutClass l Window, Read (l Window)) => XConfig l -> Directories -> IO ()


module XMonad

-- | interface to the X11 library function <tt>XRestackWindows()</tt>.
restackWindows :: Display -> [Window] -> IO ()

-- | interface to the X11 library function <tt>XWithdrawWindow()</tt>.
withdrawWindow :: Display -> Window -> ScreenNumber -> IO ()

-- | interface to the X11 library function <tt>XIconifyWindow()</tt>.
iconifyWindow :: Display -> Window -> ScreenNumber -> IO ()

-- | interface to the X11 library function
--   <tt>XTranslateCoordinates()</tt>.
translateCoordinates :: Display -> Window -> Window -> Position -> Position -> IO (Bool, Position, Position, Window)

-- | interface to the X11 library function <tt>XStoreName()</tt>.
storeName :: Display -> Window -> String -> IO ()

-- | interface to the X11 library function <tt>XCreateSimpleWindow()</tt>.
createSimpleWindow :: Display -> Window -> Position -> Position -> Dimension -> Dimension -> CInt -> Pixel -> Pixel -> IO Window

-- | interface to the X11 library function <tt>XCreateWindow()</tt>.
createWindow :: Display -> Window -> Position -> Position -> Dimension -> Dimension -> CInt -> CInt -> WindowClass -> Visual -> AttributeMask -> Ptr SetWindowAttributes -> IO Window

-- | interface to the X11 library function <tt>XMoveResizeWindow()</tt>.
moveResizeWindow :: Display -> Window -> Position -> Position -> Dimension -> Dimension -> IO ()

-- | interface to the X11 library function <tt>XResizeWindow()</tt>.
resizeWindow :: Display -> Window -> Dimension -> Dimension -> IO ()

-- | interface to the X11 library function <tt>XMoveWindow()</tt>.
moveWindow :: Display -> Window -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XReparentWindow()</tt>.
reparentWindow :: Display -> Window -> Window -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XMapSubwindows()</tt>.
mapSubwindows :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XUnmapSubwindows()</tt>.
unmapSubwindows :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XMapWindow()</tt>.
mapWindow :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XLowerWindow()</tt>.
lowerWindow :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XRaiseWindow()</tt>.
raiseWindow :: Display -> Window -> IO ()

-- | interface to the X11 library function
--   <tt>XCirculateSubwindowsDown()</tt>.
circulateSubwindowsDown :: Display -> Window -> IO ()

-- | interface to the X11 library function
--   <tt>XCirculateSubwindowsUp()</tt>.
circulateSubwindowsUp :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XCirculateSubwindows()</tt>.
circulateSubwindows :: Display -> Window -> CirculationDirection -> IO ()

-- | interface to the X11 library function <tt>XDestroyWindow()</tt>.
destroyWindow :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XDestroySubwindows()</tt>.
destroySubwindows :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XSetWindowBorder()</tt>.
setWindowBorder :: Display -> Window -> Pixel -> IO ()

-- | interface to the X11 library function
--   <tt>XSetWindowBorderPixmap()</tt>.
setWindowBorderPixmap :: Display -> Window -> Pixmap -> IO ()

-- | interface to the X11 library function
--   <tt>XSetWindowBorderWidth()</tt>.
setWindowBorderWidth :: Display -> Window -> Dimension -> IO ()

-- | interface to the X11 library function <tt>XSetWindowBackground()</tt>.
setWindowBackground :: Display -> Window -> Pixel -> IO ()

-- | interface to the X11 library function
--   <tt>XSetWindowBackgroundPixmap()</tt>.
setWindowBackgroundPixmap :: Display -> Window -> Pixmap -> IO ()

-- | interface to the X11 library function <tt>XSetWindowColormap()</tt>.
setWindowColormap :: Display -> Window -> Colormap -> IO ()

-- | interface to the X11 library function <tt>XAddToSaveSet()</tt>.
addToSaveSet :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XRemoveFromSaveSet()</tt>.
removeFromSaveSet :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XChangeSaveSet()</tt>.
changeSaveSet :: Display -> Window -> ChangeSaveSetMode -> IO ()

-- | interface to the X11 library function <tt>XClearWindow()</tt>.
clearWindow :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XClearArea()</tt>.
clearArea :: Display -> Window -> Position -> Position -> Dimension -> Dimension -> Bool -> IO ()

-- | interface to the X11 library function <tt>XSetTextProperty()</tt>.
setTextProperty :: Display -> Window -> String -> Atom -> IO ()

-- | interface to the X11 library function <tt>XRotateBuffers()</tt>.
rotateBuffers :: Display -> CInt -> IO ()

-- | interface to the X11 library function <tt>XFetchBytes()</tt>.
fetchBytes :: Display -> IO String

-- | interface to the X11 library function <tt>XFetchBuffer()</tt>.
fetchBuffer :: Display -> CInt -> IO String

-- | interface to the X11 library function <tt>XStoreBytes()</tt>.
storeBytes :: Display -> String -> IO ()

-- | interface to the X11 library function <tt>XStoreBuffer()</tt>.
storeBuffer :: Display -> String -> CInt -> IO ()

-- | interface to the X11 library function <tt>XDrawImageString()</tt>.
drawImageString :: Display -> Drawable -> GC -> Position -> Position -> String -> IO ()

-- | interface to the X11 library function <tt>XDrawString()</tt>.
drawString :: Display -> Drawable -> GC -> Position -> Position -> String -> IO ()

-- | interface to the X11 library function <tt>XFillArcs()</tt>.
fillArcs :: Display -> Drawable -> GC -> [Arc] -> IO ()

-- | interface to the X11 library function <tt>XFillPolygon()</tt>.
fillPolygon :: Display -> Drawable -> GC -> [Point] -> PolygonShape -> CoordinateMode -> IO ()

-- | interface to the X11 library function <tt>XFillRectangles()</tt>.
fillRectangles :: Display -> Drawable -> GC -> [Rectangle] -> IO ()

-- | interface to the X11 library function <tt>XDrawArcs()</tt>.
drawArcs :: Display -> Drawable -> GC -> [Arc] -> IO ()

-- | interface to the X11 library function <tt>XDrawRectangles()</tt>.
drawRectangles :: Display -> Drawable -> GC -> [Rectangle] -> IO ()

-- | interface to the X11 library function <tt>XDrawSegments()</tt>.
drawSegments :: Display -> Drawable -> GC -> [Segment] -> IO ()

-- | interface to the X11 library function <tt>XDrawLines()</tt>.
drawLines :: Display -> Drawable -> GC -> [Point] -> CoordinateMode -> IO ()

-- | interface to the X11 library function <tt>XDrawPoints()</tt>.
drawPoints :: Display -> Drawable -> GC -> [Point] -> CoordinateMode -> IO ()
set_cursor :: Ptr SetWindowAttributes -> Cursor -> IO ()
set_colormap :: Ptr SetWindowAttributes -> Colormap -> IO ()
set_override_redirect :: Ptr SetWindowAttributes -> Bool -> IO ()
set_do_not_propagate_mask :: Ptr SetWindowAttributes -> EventMask -> IO ()
set_event_mask :: Ptr SetWindowAttributes -> EventMask -> IO ()
set_save_under :: Ptr SetWindowAttributes -> Bool -> IO ()
set_backing_pixel :: Ptr SetWindowAttributes -> Pixel -> IO ()
set_backing_planes :: Ptr SetWindowAttributes -> Pixel -> IO ()
set_backing_store :: Ptr SetWindowAttributes -> BackingStore -> IO ()
set_win_gravity :: Ptr SetWindowAttributes -> WindowGravity -> IO ()
set_bit_gravity :: Ptr SetWindowAttributes -> BitGravity -> IO ()
set_border_pixel :: Ptr SetWindowAttributes -> Pixel -> IO ()
set_border_pixmap :: Ptr SetWindowAttributes -> Pixmap -> IO ()
set_background_pixel :: Ptr SetWindowAttributes -> Pixel -> IO ()
set_background_pixmap :: Ptr SetWindowAttributes -> Pixmap -> IO ()
allocaSetWindowAttributes :: (Ptr SetWindowAttributes -> IO a) -> IO a

-- | interface to the X11 library function <tt>XSetWMProtocols()</tt>.
setWMProtocols :: Display -> Window -> [Atom] -> IO ()

-- | interface to the X11 library function <tt>XRecolorCursor()</tt>.
recolorCursor :: Display -> Cursor -> Color -> Color -> IO ()

-- | interface to the X11 library function <tt>XCreateGlyphCursor()</tt>.
createGlyphCursor :: Display -> Font -> Font -> Glyph -> Glyph -> Color -> Color -> IO Cursor

-- | interface to the X11 library function <tt>XCreatePixmapCursor()</tt>.
createPixmapCursor :: Display -> Pixmap -> Pixmap -> Color -> Color -> Dimension -> Dimension -> IO Cursor

-- | interface to the X11 library function <tt>XSetIconName()</tt>.
setIconName :: Display -> Window -> String -> IO ()

-- | interface to the X11 library function <tt>XGetIconName()</tt>.
getIconName :: Display -> Window -> IO String

-- | interface to the X11 library function <tt>XLookupString()</tt>.
lookupString :: XKeyEventPtr -> IO (Maybe KeySym, String)
noSymbol :: KeySym

-- | interface to the X11 library function <tt>XStringToKeysym()</tt>.
stringToKeysym :: String -> KeySym

-- | interface to the X11 library function <tt>XKeysymToString()</tt>.
keysymToString :: KeySym -> String

-- | interface to the X11 library function <tt>XDisplayKeycodes()</tt>.
displayKeycodes :: Display -> (CInt, CInt)

-- | interface to the X11 library function <tt>XReadBitmapFile</tt>.
readBitmapFile :: Display -> Drawable -> String -> IO (Either String (Dimension, Dimension, Pixmap, Maybe CInt, Maybe CInt))

-- | interface to the X11 library function <tt>XMatchVisualInfo()</tt>
matchVisualInfo :: Display -> ScreenNumber -> CInt -> CInt -> IO (Maybe VisualInfo)
getVisualInfo :: Display -> VisualInfoMask -> VisualInfo -> IO [VisualInfo]
visualAllMask :: VisualInfoMask
visualBitsPerRGBMask :: VisualInfoMask
visualColormapSizeMask :: VisualInfoMask

-- | interface to the X11 library function <tt>XGetVisualInfo()</tt>
visualBlueMaskMask :: VisualInfoMask
visualGreenMaskMask :: VisualInfoMask
visualRedMaskMask :: VisualInfoMask
visualClassMask :: VisualInfoMask
visualDepthMask :: VisualInfoMask
visualScreenMask :: VisualInfoMask
visualIDMask :: VisualInfoMask
visualNoMask :: VisualInfoMask

-- | interface to the X11 library function <tt>XGetPointerControl()</tt>.
getPointerControl :: Display -> IO (CInt, CInt, CInt)
getScreenSaver :: Display -> IO (CInt, CInt, PreferBlankingMode, AllowExposuresMode)
screenSaverReset :: ScreenSaverMode
screenSaverActive :: ScreenSaverMode
defaultBlanking :: PreferBlankingMode
preferBlanking :: PreferBlankingMode
dontPreferBlanking :: PreferBlankingMode
defaultExposures :: AllowExposuresMode
allowExposures :: AllowExposuresMode
dontAllowExposures :: AllowExposuresMode

-- | interface to the X11 library function <tt>XSetLocaleModifiers()</tt>.
setLocaleModifiers :: String -> IO String

-- | interface to the X11 library function <tt>XGetGeometry()</tt>.
getGeometry :: Display -> Drawable -> IO (Window, Position, Position, Dimension, Dimension, Dimension, CInt)

-- | interface to the X11 library function <tt>XGeometry()</tt>.
geometry :: Display -> CInt -> String -> String -> Dimension -> Dimension -> Dimension -> CInt -> CInt -> IO (CInt, Position, Position, Dimension, Dimension)

-- | The Xlib library reports most errors by invoking a user-provided error
--   handler. This function installs an error handler that prints a textual
--   representation of the error.
setDefaultErrorHandler :: IO ()

-- | interface to the X11 library function <tt>XDisplayName()</tt>.
displayName :: String -> String

-- | interface to the X11 library function <tt>XQueryPointer()</tt>.
queryPointer :: Display -> Window -> IO (Bool, Window, Window, CInt, CInt, CInt, CInt, Modifier)

-- | interface to the X11 library function <tt>XQueryBestSize()</tt>.
queryBestSize :: Display -> QueryBestSizeClass -> Drawable -> Dimension -> Dimension -> IO (Dimension, Dimension)

-- | interface to the X11 library function <tt>XQueryBestCursor()</tt>.
queryBestCursor :: Display -> Drawable -> Dimension -> Dimension -> IO (Dimension, Dimension)

-- | interface to the X11 library function <tt>XQueryBestStipple()</tt>.
queryBestStipple :: Display -> Drawable -> Dimension -> Dimension -> IO (Dimension, Dimension)

-- | interface to the X11 library function <tt>XQueryBestTile()</tt>.
queryBestTile :: Display -> Drawable -> Dimension -> Dimension -> IO (Dimension, Dimension)

-- | interface to the X11 library function <tt>XGetInputFocus()</tt>.
getInputFocus :: Display -> IO (Window, FocusMode)

-- | interface to the X11 library function <tt>XrmInitialize()</tt>.
rmInitialize :: IO ()

-- | interface to the X11 library function <tt>XAutoRepeatOff()</tt>.
autoRepeatOff :: Display -> IO ()

-- | interface to the X11 library function <tt>XAutoRepeatOn()</tt>.
autoRepeatOn :: Display -> IO ()

-- | interface to the X11 library function <tt>XBell()</tt>.
bell :: Display -> CInt -> IO ()

-- | interface to the X11 library function <tt>XSetCloseDownMode()</tt>.
setCloseDownMode :: Display -> CloseDownMode -> IO ()

-- | interface to the X11 library function
--   <tt>XLastKnownRequestProcessed()</tt>.
lastKnownRequestProcessed :: Display -> IO CInt

-- | interface to the X11 library function <tt>XSetInputFocus()</tt>.
setInputFocus :: Display -> Window -> FocusMode -> Time -> IO ()

-- | interface to the X11 library function <tt>XGrabButton()</tt>.
grabButton :: Display -> Button -> ButtonMask -> Window -> Bool -> EventMask -> GrabMode -> GrabMode -> Window -> Cursor -> IO ()

-- | interface to the X11 library function <tt>XUngrabButton()</tt>.
ungrabButton :: Display -> Button -> ButtonMask -> Window -> IO ()

-- | interface to the X11 library function <tt>XGrabPointer()</tt>.
grabPointer :: Display -> Window -> Bool -> EventMask -> GrabMode -> GrabMode -> Window -> Cursor -> Time -> IO GrabStatus

-- | interface to the X11 library function <tt>XUngrabPointer()</tt>.
ungrabPointer :: Display -> Time -> IO ()

-- | interface to the X11 library function <tt>XGrabKey()</tt>.
grabKey :: Display -> KeyCode -> KeyMask -> Window -> Bool -> GrabMode -> GrabMode -> IO ()

-- | interface to the X11 library function <tt>XUngrabKey()</tt>.
ungrabKey :: Display -> KeyCode -> KeyMask -> Window -> IO ()

-- | interface to the X11 library function <tt>XGrabKeyboard()</tt>.
grabKeyboard :: Display -> Window -> Bool -> GrabMode -> GrabMode -> Time -> IO GrabStatus

-- | interface to the X11 library function <tt>XUngrabKeyboard()</tt>.
ungrabKeyboard :: Display -> Time -> IO ()

-- | interface to the X11 library function <tt>XGrabServer()</tt>.
grabServer :: Display -> IO ()

-- | interface to the X11 library function <tt>XUngrabServer()</tt>.
ungrabServer :: Display -> IO ()

-- | interface to the X11 library function <tt>XSupportsLocale()</tt>.
supportsLocale :: IO Bool

-- | interface to the X11 library function <tt>XSetScreenSaver()</tt>.
setScreenSaver :: Display -> CInt -> CInt -> PreferBlankingMode -> AllowExposuresMode -> IO ()

-- | interface to the X11 library function <tt>XActivateScreenSaver()</tt>.
activateScreenSaver :: Display -> IO ()

-- | interface to the X11 library function <tt>XResetScreenSaver()</tt>.
resetScreenSaver :: Display -> IO ()

-- | interface to the X11 library function <tt>XForceScreenSaver()</tt>.
forceScreenSaver :: Display -> ScreenSaverMode -> IO ()

-- | interface to the X11 library function <tt>XWarpPointer()</tt>.
warpPointer :: Display -> Window -> Window -> Position -> Position -> Dimension -> Dimension -> Position -> Position -> IO ()

-- | see <tt>XVisualIDFromVisual()</tt>
visualIDFromVisual :: Visual -> IO VisualID
initThreads :: IO Status
lockDisplay :: Display -> IO ()
unlockDisplay :: Display -> IO ()

-- | interface to the X11 library function <tt>XCreatePixmap()</tt>.
createPixmap :: Display -> Drawable -> Dimension -> Dimension -> CInt -> IO Pixmap

-- | interface to the X11 library function <tt>XFreePixmap()</tt>.
freePixmap :: Display -> Pixmap -> IO ()

-- | interface to the X11 library function <tt>XBitmapBitOrder()</tt>.
bitmapBitOrder :: Display -> ByteOrder

-- | interface to the X11 library function <tt>XBitmapUnit()</tt>.
bitmapUnit :: Display -> CInt

-- | interface to the X11 library function <tt>XBitmapPad()</tt>.
bitmapPad :: Display -> CInt

-- | interface to the X11 library function <tt>XLookupKeysym()</tt>.
lookupKeysym :: XKeyEventPtr -> CInt -> IO KeySym

-- | interface to the X11 library function <tt>XKeycodeToKeysym()</tt>.
keycodeToKeysym :: Display -> KeyCode -> CInt -> IO KeySym

-- | interface to the X11 library function <tt>XKeysymToKeycode()</tt>.
keysymToKeycode :: Display -> KeySym -> IO KeyCode

-- | interface to the X11 library function <tt>XDefineCursor()</tt>.
defineCursor :: Display -> Window -> Cursor -> IO ()

-- | interface to the X11 library function <tt>XUndefineCursor()</tt>.
undefineCursor :: Display -> Window -> IO ()

-- | interface to the X11 library function <tt>XCreateFontCursor()</tt>.
createFontCursor :: Display -> Glyph -> IO Cursor

-- | interface to the X11 library function <tt>XFreeCursor()</tt>.
freeCursor :: Display -> Font -> IO ()

-- | interface to the X11 library function <tt>XDrawPoint()</tt>.
drawPoint :: Display -> Drawable -> GC -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XDrawLine()</tt>.
drawLine :: Display -> Drawable -> GC -> Position -> Position -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XDrawRectangle()</tt>.
drawRectangle :: Display -> Drawable -> GC -> Position -> Position -> Dimension -> Dimension -> IO ()

-- | interface to the X11 library function <tt>XDrawArc()</tt>.
drawArc :: Display -> Drawable -> GC -> Position -> Position -> Dimension -> Dimension -> Angle -> Angle -> IO ()

-- | interface to the X11 library function <tt>XFillRectangle()</tt>.
fillRectangle :: Display -> Drawable -> GC -> Position -> Position -> Dimension -> Dimension -> IO ()

-- | interface to the X11 library function <tt>XFillArc()</tt>.
fillArc :: Display -> Drawable -> GC -> Position -> Position -> Dimension -> Dimension -> Angle -> Angle -> IO ()

-- | interface to the X11 library function <tt>XCopyArea()</tt>.
copyArea :: Display -> Drawable -> Drawable -> GC -> Position -> Position -> Dimension -> Dimension -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XCopyPlane()</tt>.
copyPlane :: Display -> Drawable -> Drawable -> GC -> Position -> Position -> Dimension -> Dimension -> Position -> Position -> Pixel -> IO ()
type AllowExposuresMode = CInt
type PreferBlankingMode = CInt
type ScreenSaverMode = CInt
type VisualInfoMask = CLong
lAST_PREDEFINED :: Atom
wM_TRANSIENT_FOR :: Atom
wM_CLASS :: Atom
cAP_HEIGHT :: Atom
fULL_NAME :: Atom
fAMILY_NAME :: Atom
fONT_NAME :: Atom
nOTICE :: Atom
cOPYRIGHT :: Atom
rESOLUTION :: Atom
pOINT_SIZE :: Atom
wEIGHT :: Atom
qUAD_WIDTH :: Atom
x_HEIGHT :: Atom
iTALIC_ANGLE :: Atom
sTRIKEOUT_DESCENT :: Atom
sTRIKEOUT_ASCENT :: Atom
uNDERLINE_THICKNESS :: Atom
uNDERLINE_POSITION :: Atom
sUBSCRIPT_Y :: Atom
sUBSCRIPT_X :: Atom
sUPERSCRIPT_Y :: Atom
sUPERSCRIPT_X :: Atom
eND_SPACE :: Atom
mAX_SPACE :: Atom
nORM_SPACE :: Atom
mIN_SPACE :: Atom
wM_ZOOM_HINTS :: Atom
wM_SIZE_HINTS :: Atom
wM_NORMAL_HINTS :: Atom
wM_NAME :: Atom
wM_ICON_SIZE :: Atom
wM_ICON_NAME :: Atom
wM_CLIENT_MACHINE :: Atom
wM_HINTS :: Atom
wM_COMMAND :: Atom
wINDOW :: Atom
vISUALID :: Atom
sTRING :: Atom
rGB_RED_MAP :: Atom
rGB_GREEN_MAP :: Atom
rGB_GRAY_MAP :: Atom
rGB_DEFAULT_MAP :: Atom
rGB_BLUE_MAP :: Atom
rGB_BEST_MAP :: Atom
rGB_COLOR_MAP :: Atom
rESOURCE_MANAGER :: Atom
rECTANGLE :: Atom
pOINT :: Atom
pIXMAP :: Atom
iNTEGER :: Atom
fONT :: Atom
dRAWABLE :: Atom
cUT_BUFFER7 :: Atom
cUT_BUFFER6 :: Atom
cUT_BUFFER5 :: Atom
cUT_BUFFER4 :: Atom
cUT_BUFFER3 :: Atom
cUT_BUFFER2 :: Atom
cUT_BUFFER1 :: Atom
cUT_BUFFER0 :: Atom
cURSOR :: Atom
cOLORMAP :: Atom
cARDINAL :: Atom
bITMAP :: Atom
aTOM :: Atom
aRC :: Atom
sECONDARY :: Atom
pRIMARY :: Atom
getAtomNames :: Display -> [Atom] -> IO [String]
getAtomName :: Display -> Atom -> IO (Maybe String)

-- | interface to the X11 library function <tt>XInternAtom()</tt>.
internAtom :: Display -> String -> Bool -> IO Atom

-- | interface to the X11 library function <tt>XQueryColors()</tt>.
queryColors :: Display -> Colormap -> [Color] -> IO [Color]

-- | interface to the X11 library function <tt>XQueryColor()</tt>.
queryColor :: Display -> Colormap -> Color -> IO Color

-- | interface to the X11 library function <tt>XStoreColor()</tt>.
storeColor :: Display -> Colormap -> Color -> IO ()

-- | interface to the X11 library function <tt>XFreeColors()</tt>.
freeColors :: Display -> Colormap -> [Pixel] -> Pixel -> IO ()

-- | interface to the X11 library function <tt>XParseColor()</tt>.
parseColor :: Display -> Colormap -> String -> IO Color

-- | interface to the X11 library function <tt>XAllocColor()</tt>.
allocColor :: Display -> Colormap -> Color -> IO Color

-- | interface to the X11 library function <tt>XAllocNamedColor()</tt>.
allocNamedColor :: Display -> Colormap -> String -> IO (Color, Color)

-- | interface to the X11 library function <tt>XLookupColor()</tt>.
lookupColor :: Display -> Colormap -> String -> IO (Color, Color)

-- | interface to the X11 library function <tt>XInstallColormap()</tt>.
installColormap :: Display -> Colormap -> IO ()

-- | interface to the X11 library function <tt>XUninstallColormap()</tt>.
uninstallColormap :: Display -> Colormap -> IO ()

-- | interface to the X11 library function <tt>XCopyColormapAndFree()</tt>.
copyColormapAndFree :: Display -> Colormap -> IO Colormap

-- | interface to the X11 library function <tt>XCreateColormap()</tt>.
createColormap :: Display -> Window -> Visual -> ColormapAlloc -> IO Colormap

-- | interface to the X11 library function <tt>XFreeColormap()</tt>.
freeColormap :: Display -> Colormap -> IO ()

-- | partial interface to the X11 library function <tt>XCreateGC()</tt>.
createGC :: Display -> Drawable -> IO GC

-- | interface to the X11 library function <tt>XSetDashes()</tt>.
setDashes :: Display -> GC -> CInt -> String -> CInt -> IO ()

-- | interface to the X11 library function <tt>XSetArcMode()</tt>.
setArcMode :: Display -> GC -> ArcMode -> IO ()

-- | interface to the X11 library function <tt>XSetBackground()</tt>.
setBackground :: Display -> GC -> Pixel -> IO ()

-- | interface to the X11 library function <tt>XSetForeground()</tt>.
setForeground :: Display -> GC -> Pixel -> IO ()

-- | interface to the X11 library function <tt>XSetFunction()</tt>.
setFunction :: Display -> GC -> GXFunction -> IO ()

-- | interface to the X11 library function
--   <tt>XSetGraphicsExposures()</tt>.
setGraphicsExposures :: Display -> GC -> Bool -> IO ()

-- | interface to the X11 library function <tt>XSetClipMask()</tt>.
setClipMask :: Display -> GC -> Pixmap -> IO ()

-- | interface to the X11 library function <tt>XSetClipOrigin()</tt>.
setClipOrigin :: Display -> GC -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XSetFillRule()</tt>.
setFillRule :: Display -> GC -> FillRule -> IO ()

-- | interface to the X11 library function <tt>XSetFillStyle()</tt>.
setFillStyle :: Display -> GC -> FillStyle -> IO ()

-- | interface to the X11 library function <tt>XSetFont()</tt>.
setFont :: Display -> GC -> Font -> IO ()

-- | interface to the X11 library function <tt>XSetLineAttributes()</tt>.
setLineAttributes :: Display -> GC -> CInt -> LineStyle -> CapStyle -> JoinStyle -> IO ()

-- | interface to the X11 library function <tt>XSetPlaneMask()</tt>.
setPlaneMask :: Display -> GC -> Pixel -> IO ()

-- | interface to the X11 library function <tt>XSetState()</tt>.
setState :: Display -> GC -> Pixel -> Pixel -> GXFunction -> Pixel -> IO ()

-- | interface to the X11 library function <tt>XSetStipple()</tt>.
setStipple :: Display -> GC -> Pixmap -> IO ()

-- | interface to the X11 library function <tt>XSetSubwindowMode()</tt>.
setSubwindowMode :: Display -> GC -> SubWindowMode -> IO ()

-- | interface to the X11 library function <tt>XSetTSOrigin()</tt>.
setTSOrigin :: Display -> GC -> Position -> Position -> IO ()

-- | interface to the X11 library function <tt>XSetTile()</tt>.
setTile :: Display -> GC -> Pixmap -> IO ()

-- | interface to the X11 library function <tt>XGContextFromGC()</tt>.
gContextFromGC :: GC -> GContext

-- | interface to the X11 library function <tt>XFreeGC()</tt>.
freeGC :: Display -> GC -> IO ()

-- | interface to the X11 library function <tt>XFlushGC()</tt>.
flushGC :: Display -> GC -> IO ()

-- | interface to the X11 library function <tt>XCopyGC()</tt>.
copyGC :: Display -> GC -> Mask -> GC -> IO ()

-- | interface to the X11 library function <tt>XSendEvent()</tt>.
sendEvent :: Display -> Window -> Bool -> EventMask -> XEventPtr -> IO ()

-- | This function is somewhat compatible with Win32's
--   <tt>TimeGetTime()</tt>
gettimeofday_in_milliseconds :: IO Integer

-- | Reads an event with a timeout (in microseconds). Returns True if
--   timeout occurs.
waitForEvent :: Display -> Word32 -> IO Bool
get_ConfigureEvent :: XEventPtr -> IO XConfigureEvent
get_ExposeEvent :: XEventPtr -> IO XExposeEvent
get_MotionEvent :: XEventPtr -> IO XMotionEvent
get_ButtonEvent :: XEventPtr -> IO XButtonEvent
asKeyEvent :: XEventPtr -> XKeyEventPtr
get_KeyEvent :: XEventPtr -> IO XKeyEvent
get_Window :: XEventPtr -> IO Window
get_EventType :: XEventPtr -> IO EventType
allocaXEvent :: (XEventPtr -> IO a) -> IO a
queuedAfterReading :: QueuedMode
queuedAfterFlush :: QueuedMode
queuedAlready :: QueuedMode

-- | interface to the X11 library function <tt>XFlush()</tt>.
flush :: Display -> IO ()

-- | interface to the X11 library function <tt>XSync()</tt>.
sync :: Display -> Bool -> IO ()

-- | interface to the X11 library function <tt>XPending()</tt>.
pending :: Display -> IO CInt

-- | interface to the X11 library function <tt>XEventsQueued()</tt>.
eventsQueued :: Display -> QueuedMode -> IO CInt

-- | interface to the X11 library function <tt>XNextEvent()</tt>.
nextEvent :: Display -> XEventPtr -> IO ()

-- | interface to the X11 library function <tt>XAllowEvents()</tt>.
allowEvents :: Display -> AllowEvents -> Time -> IO ()

-- | interface to the X11 library function <tt>XSelectInput()</tt>.
selectInput :: Display -> Window -> EventMask -> IO ()

-- | interface to the X11 library function <tt>XWindowEvent()</tt>.
windowEvent :: Display -> Window -> EventMask -> XEventPtr -> IO ()

-- | interface to the X11 library function <tt>XCheckWindowEvent()</tt>.
checkWindowEvent :: Display -> Window -> EventMask -> XEventPtr -> IO Bool

-- | interface to the X11 library function <tt>XMaskEvent()</tt>.
maskEvent :: Display -> EventMask -> XEventPtr -> IO ()

-- | interface to the X11 library function <tt>XCheckMaskEvent()</tt>.
checkMaskEvent :: Display -> EventMask -> XEventPtr -> IO Bool

-- | interface to the X11 library function <tt>XCheckTypedEvent()</tt>.
checkTypedEvent :: Display -> EventType -> XEventPtr -> IO Bool

-- | interface to the X11 library function
--   <tt>XCheckTypedWindowEvent()</tt>.
checkTypedWindowEvent :: Display -> Window -> EventType -> XEventPtr -> IO Bool

-- | interface to the X11 library function <tt>XPutBackEvent()</tt>.
putBackEvent :: Display -> XEventPtr -> IO ()

-- | interface to the X11 library function <tt>XPeekEvent()</tt>.
peekEvent :: Display -> XEventPtr -> IO ()
type QueuedMode = CInt
newtype XEvent
XEvent :: XEventPtr -> XEvent
type XEventPtr = Ptr XEvent
type XKeyEvent = (Window, Window, Time, CInt, CInt, CInt, CInt, Modifier, KeyCode, Bool)
type XKeyEventPtr = Ptr XKeyEvent
type XButtonEvent = (Window, Window, Time, CInt, CInt, CInt, CInt, Modifier, Button, Bool)
type XMotionEvent = (Window, Window, Time, CInt, CInt, CInt, CInt, Modifier, NotifyMode, Bool)
type XExposeEvent = (Position, Position, Dimension, Dimension, CInt)
type XMappingEvent = (MappingRequest, KeyCode, CInt)
type XConfigureEvent = (Position, Position, Dimension, Dimension)

-- | interface to the X11 library function <tt>XOpenDisplay()</tt>.
openDisplay :: String -> IO Display

-- | interface to the X11 library function <tt>XServerVendor()</tt>.
serverVendor :: Display -> String

-- | interface to the X11 library function <tt>XDisplayString()</tt>.
displayString :: Display -> String

-- | interface to the X11 library function
--   <tt>XScreenResourceString()</tt>.
screenResourceString :: Screen -> String

-- | interface to the X11 library function
--   <tt>XResourceManagerString()</tt>.
resourceManagerString :: Display -> String

-- | interface to the X11 library function <tt>XAllPlanes()</tt>.
allPlanes_aux :: Pixel

-- | interface to the X11 library function <tt>XBlackPixel()</tt>.
blackPixel :: Display -> ScreenNumber -> Pixel

-- | interface to the X11 library function <tt>XWhitePixel()</tt>.
whitePixel :: Display -> ScreenNumber -> Pixel

-- | interface to the X11 library function <tt>XConnectionNumber()</tt>.
connectionNumber :: Display -> CInt

-- | interface to the X11 library function <tt>XDefaultColormap()</tt>.
defaultColormap :: Display -> ScreenNumber -> Colormap

-- | interface to the X11 library function <tt>XDefaultGC()</tt>.
defaultGC :: Display -> ScreenNumber -> GC

-- | interface to the X11 library function <tt>XDefaultDepth()</tt>.
defaultDepth :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XDefaultScreen()</tt>.
defaultScreen :: Display -> ScreenNumber

-- | interface to the X11 library function
--   <tt>XDefaultScreenOfDisplay()</tt>.
defaultScreenOfDisplay :: Display -> Screen

-- | interface to the X11 library function <tt>XDisplayHeight()</tt>.
displayHeight :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XDisplayHeightMM()</tt>.
displayHeightMM :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XDisplayWidth()</tt>.
displayWidth :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XDisplayWidthMM()</tt>.
displayWidthMM :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XMaxRequestSize()</tt>.
maxRequestSize :: Display -> CInt

-- | interface to the X11 library function
--   <tt>XDisplayMotionBufferSize()</tt>.
displayMotionBufferSize :: Display -> CInt

-- | interface to the X11 library function <tt>XImageByteOrder()</tt>.
imageByteOrder :: Display -> CInt

-- | interface to the X11 library function <tt>XProtocolRevision()</tt>.
protocolRevision :: Display -> CInt

-- | interface to the X11 library function <tt>XProtocolVersion()</tt>.
protocolVersion :: Display -> CInt

-- | interface to the X11 library function <tt>XScreenCount()</tt>.
screenCount :: Display -> CInt

-- | interface to the X11 library function <tt>XDefaultVisual()</tt>.
defaultVisual :: Display -> ScreenNumber -> Visual

-- | interface to the X11 library function <tt>XDisplayCells()</tt>.
displayCells :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XDisplayPlanes()</tt>.
displayPlanes :: Display -> ScreenNumber -> CInt

-- | interface to the X11 library function <tt>XScreenOfDisplay()</tt>.
screenOfDisplay :: Display -> ScreenNumber -> Screen

-- | interface to the X11 library function <tt>XDefaultRootWindow()</tt>.
defaultRootWindow :: Display -> Window

-- | interface to the X11 library function <tt>XRootWindow()</tt>.
rootWindow :: Display -> ScreenNumber -> IO Window

-- | interface to the X11 library function <tt>XQLength()</tt>.
qLength :: Display -> IO CInt

-- | interface to the X11 library function <tt>XNoOp()</tt>.
noOp :: Display -> IO ()

-- | interface to the X11 library function <tt>XCloseDisplay()</tt>.
closeDisplay :: Display -> IO ()
xC_xterm :: Glyph
xC_watch :: Glyph
xC_ur_angle :: Glyph
xC_umbrella :: Glyph
xC_ul_angle :: Glyph
xC_trek :: Glyph
xC_top_tee :: Glyph
xC_top_side :: Glyph
xC_top_right_corner :: Glyph
xC_top_left_corner :: Glyph
xC_top_left_arrow :: Glyph
xC_tcross :: Glyph
xC_target :: Glyph
xC_star :: Glyph
xC_spraycan :: Glyph
xC_spider :: Glyph
xC_sizing :: Glyph
xC_shuttle :: Glyph
xC_sb_v_double_arrow :: Glyph
xC_sb_up_arrow :: Glyph
xC_sb_right_arrow :: Glyph
xC_sb_left_arrow :: Glyph
xC_sb_h_double_arrow :: Glyph
xC_sb_down_arrow :: Glyph
xC_sailboat :: Glyph
xC_rtl_logo :: Glyph
xC_rightbutton :: Glyph
xC_right_tee :: Glyph
xC_right_side :: Glyph
xC_right_ptr :: Glyph
xC_question_arrow :: Glyph
xC_plus :: Glyph
xC_pirate :: Glyph
xC_pencil :: Glyph
xC_mouse :: Glyph
xC_man :: Glyph
xC_lr_angle :: Glyph
xC_ll_angle :: Glyph
xC_leftbutton :: Glyph
xC_left_tee :: Glyph
xC_left_side :: Glyph
xC_left_ptr :: Glyph
xC_iron_cross :: Glyph
xC_icon :: Glyph
xC_heart :: Glyph
xC_hand2 :: Glyph
xC_hand1 :: Glyph
xC_gumby :: Glyph
xC_gobbler :: Glyph
xC_fleur :: Glyph
xC_exchange :: Glyph
xC_draped_box :: Glyph
xC_draft_small :: Glyph
xC_draft_large :: Glyph
xC_double_arrow :: Glyph
xC_dotbox :: Glyph
xC_dot :: Glyph
xC_diamond_cross :: Glyph
xC_crosshair :: Glyph
xC_cross_reverse :: Glyph
xC_cross :: Glyph
xC_coffee_mug :: Glyph
xC_clock :: Glyph
xC_circle :: Glyph
xC_center_ptr :: Glyph
xC_box_spiral :: Glyph
xC_bottom_tee :: Glyph
xC_bottom_side :: Glyph
xC_bottom_right_corner :: Glyph
xC_bottom_left_corner :: Glyph
xC_bogosity :: Glyph
xC_boat :: Glyph
xC_based_arrow_up :: Glyph
xC_based_arrow_down :: Glyph
xC_arrow :: Glyph
xC_X_cursor :: Glyph

-- | interface to the X11 library function <tt>XTextWidth()</tt>.
textWidth :: FontStruct -> String -> Int32

-- | interface to the X11 library function <tt>XTextExtents()</tt>.
textExtents :: FontStruct -> String -> (FontDirection, Int32, Int32, CharStruct)
descentFromFontStruct :: FontStruct -> Int32
ascentFromFontStruct :: FontStruct -> Int32
fontFromFontStruct :: FontStruct -> Font

-- | interface to the X11 library function <tt>XLoadQueryFont()</tt>.
loadQueryFont :: Display -> String -> IO FontStruct

-- | interface to the X11 library function <tt>XGetGCValues()</tt>.
fontFromGC :: Display -> GC -> IO Font

-- | interface to the X11 library function <tt>XQueryFont()</tt>.
queryFont :: Display -> Font -> IO FontStruct

-- | interface to the X11 library function <tt>XFreeFont()</tt>.
freeFont :: Display -> FontStruct -> IO ()
type Glyph = Word16

-- | pointer to an X11 <tt>XFontStruct</tt> structure
data FontStruct
type CharStruct = (CInt, CInt, CInt, CInt, CInt)

-- | interface to the X11 library function <tt>XGetPixel()</tt>.
getPixel :: Image -> CInt -> CInt -> CULong

-- | interface to the X11 library function <tt>XGetImage()</tt>.
getImage :: Display -> Drawable -> CInt -> CInt -> CUInt -> CUInt -> CULong -> ImageFormat -> IO Image

-- | interface to the X11 library function <tt>XCreateImage()</tt>.
createImage :: Display -> Visual -> CInt -> ImageFormat -> CInt -> Ptr CChar -> Dimension -> Dimension -> CInt -> CInt -> IO Image

-- | interface to the X11 library function <tt>XPutImage()</tt>.
putImage :: Display -> Drawable -> GC -> Image -> Position -> Position -> Position -> Position -> Dimension -> Dimension -> IO ()

-- | interface to the X11 library function <tt>XDestroyImage()</tt>.
destroyImage :: Image -> IO ()
xGetPixel :: Image -> CInt -> CInt -> IO CULong

-- | interface to the X11 library function <tt>XSetRegion()</tt>.
setRegion :: Display -> GC -> Region -> IO CInt

-- | interface to the X11 library function <tt>XShrinkRegion()</tt>.
shrinkRegion :: Region -> Point -> IO CInt

-- | interface to the X11 library function <tt>XOffsetRegion()</tt>.
offsetRegion :: Region -> Point -> IO CInt

-- | interface to the X11 library function <tt>XClipBox()</tt>.
clipBox :: Region -> IO (Rectangle, CInt)

-- | interface to the X11 library function <tt>XRectInRegion()</tt>.
rectInRegion :: Region -> Rectangle -> IO RectInRegionResult

-- | interface to the X11 library function <tt>XPointInRegion()</tt>.
pointInRegion :: Region -> Point -> IO Bool

-- | interface to the X11 library function <tt>XEqualRegion()</tt>.
equalRegion :: Region -> Region -> IO Bool

-- | interface to the X11 library function <tt>XEmptyRegion()</tt>.
emptyRegion :: Region -> IO Bool

-- | interface to the X11 library function <tt>XXorRegion()</tt>.
xorRegion :: Region -> Region -> Region -> IO CInt

-- | interface to the X11 library function <tt>XUnionRegion()</tt>.
unionRegion :: Region -> Region -> Region -> IO CInt

-- | interface to the X11 library function <tt>XUnionRectWithRegion()</tt>.
unionRectWithRegion :: Rectangle -> Region -> Region -> IO CInt

-- | interface to the X11 library function <tt>XSubtractRegion()</tt>.
subtractRegion :: Region -> Region -> Region -> IO CInt

-- | interface to the X11 library function <tt>XIntersectRegion()</tt>.
intersectRegion :: Region -> Region -> Region -> IO CInt

-- | interface to the X11 library function <tt>XPolygonRegion()</tt>.
polygonRegion :: [Point] -> FillRule -> IO Region

-- | interface to the X11 library function <tt>XCreateRegion()</tt>.
createRegion :: IO Region
rectanglePart :: RectInRegionResult
rectangleIn :: RectInRegionResult
rectangleOut :: RectInRegionResult
data Region
type RectInRegionResult = CInt

-- | interface to the X11 library function <tt>XBlackPixelOfScreen()</tt>.
blackPixelOfScreen :: Screen -> Pixel

-- | interface to the X11 library function <tt>XWhitePixelOfScreen()</tt>.
whitePixelOfScreen :: Screen -> Pixel

-- | interface to the X11 library function <tt>XCellsOfScreen()</tt>.
cellsOfScreen :: Screen -> CInt

-- | interface to the X11 library function
--   <tt>XDefaultColormapOfScreen()</tt>.
defaultColormapOfScreen :: Screen -> Colormap

-- | interface to the X11 library function
--   <tt>XDefaultDepthOfScreen()</tt>.
defaultDepthOfScreen :: Screen -> CInt

-- | interface to the X11 library function <tt>XDefaultGCOfScreen()</tt>.
defaultGCOfScreen :: Screen -> GC

-- | interface to the X11 library function
--   <tt>XDefaultVisualOfScreen()</tt>.
defaultVisualOfScreen :: Screen -> Visual

-- | interface to the X11 library function <tt>XDoesBackingStore()</tt>.
doesBackingStore :: Screen -> Bool

-- | interface to the X11 library function <tt>XDoesSaveUnders()</tt>.
doesSaveUnders :: Screen -> Bool

-- | interface to the X11 library function <tt>XDisplayOfScreen()</tt>.
displayOfScreen :: Screen -> Display

-- | interface to the X11 library function <tt>XEventMaskOfScreen()</tt>.
--   Event mask at connection setup time - not current event mask!
eventMaskOfScreen :: Screen -> EventMask

-- | interface to the X11 library function <tt>XMinCmapsOfScreen()</tt>.
minCmapsOfScreen :: Screen -> CInt

-- | interface to the X11 library function <tt>XMaxCmapsOfScreen()</tt>.
maxCmapsOfScreen :: Screen -> CInt

-- | interface to the X11 library function <tt>XRootWindowOfScreen()</tt>.
rootWindowOfScreen :: Screen -> Window

-- | interface to the X11 library function <tt>XWidthOfScreen()</tt>.
widthOfScreen :: Screen -> Dimension

-- | interface to the X11 library function <tt>XWidthMMOfScreen()</tt>.
widthMMOfScreen :: Screen -> Dimension

-- | interface to the X11 library function <tt>XHeightOfScreen()</tt>.
heightOfScreen :: Screen -> Dimension

-- | interface to the X11 library function <tt>XHeightMMOfScreen()</tt>.
heightMMOfScreen :: Screen -> Dimension

-- | interface to the X11 library function <tt>XPlanesOfScreen()</tt>.
planesOfScreen :: Screen -> CInt

-- | interface to the X11 library function
--   <tt>XScreenNumberOfScreen()</tt>.
screenNumberOfScreen :: Screen -> ScreenNumber

-- | pointer to an X11 <tt>Display</tt> structure
newtype Display
Display :: Ptr Display -> Display

-- | pointer to an X11 <tt>Screen</tt> structure
data Screen

-- | pointer to an X11 <tt>Visual</tt> structure
data Visual

-- | pointer to an X11 <tt>GC</tt> structure
data GC

-- | pointer to an X11 <tt>XSetWindowAttributes</tt> structure
data SetWindowAttributes

-- | counterpart of an X11 <tt>XVisualInfo</tt> structure
data VisualInfo
VisualInfo :: Visual -> VisualID -> ScreenNumber -> CInt -> CInt -> CULong -> CULong -> CULong -> CInt -> CInt -> VisualInfo
[visualInfo_visual] :: VisualInfo -> Visual
[visualInfo_visualID] :: VisualInfo -> VisualID
[visualInfo_screen] :: VisualInfo -> ScreenNumber
[visualInfo_depth] :: VisualInfo -> CInt
[visualInfo_class] :: VisualInfo -> CInt
[visualInfo_redMask] :: VisualInfo -> CULong
[visualInfo_greenMask] :: VisualInfo -> CULong
[visualInfo_blueMask] :: VisualInfo -> CULong
[visualInfo_colormapSize] :: VisualInfo -> CInt
[visualInfo_bitsPerRGB] :: VisualInfo -> CInt

-- | pointer to an X11 <tt>XImage</tt> structure
data Image
type Pixel = Word64
type Position = Int32
type Dimension = Word32
type Angle = CInt
type ScreenNumber = Word32
type Buffer = CInt

-- | counterpart of an X11 <tt>XPoint</tt> structure
data Point
Point :: !Position -> !Position -> Point
[pt_x] :: Point -> !Position
[pt_y] :: Point -> !Position

-- | counterpart of an X11 <tt>XRectangle</tt> structure
data Rectangle
Rectangle :: !Position -> !Position -> !Dimension -> !Dimension -> Rectangle
[rect_x] :: Rectangle -> !Position
[rect_y] :: Rectangle -> !Position
[rect_width] :: Rectangle -> !Dimension
[rect_height] :: Rectangle -> !Dimension

-- | counterpart of an X11 <tt>XArc</tt> structure
data Arc
Arc :: Position -> Position -> Dimension -> Dimension -> Angle -> Angle -> Arc
[arc_x] :: Arc -> Position
[arc_y] :: Arc -> Position
[arc_width] :: Arc -> Dimension
[arc_height] :: Arc -> Dimension
[arc_angle1] :: Arc -> Angle
[arc_angle2] :: Arc -> Angle

-- | counterpart of an X11 <tt>XSegment</tt> structure
data Segment
Segment :: Position -> Position -> Position -> Position -> Segment
[seg_x1] :: Segment -> Position
[seg_y1] :: Segment -> Position
[seg_x2] :: Segment -> Position
[seg_y2] :: Segment -> Position

-- | counterpart of an X11 <tt>XColor</tt> structure
data Color
Color :: Pixel -> Word16 -> Word16 -> Word16 -> Word8 -> Color
[color_pixel] :: Color -> Pixel
[color_red] :: Color -> Word16
[color_green] :: Color -> Word16
[color_blue] :: Color -> Word16
[color_flags] :: Color -> Word8
xRR_UnknownConnection :: Connection
xRR_Disconnected :: Connection
xRR_Connected :: Connection
xRR_Reflect_Y :: Reflection
xRR_Reflect_X :: Reflection
xRR_Rotate_270 :: Rotation
xRR_Rotate_180 :: Rotation
xRR_Rotate_90 :: Rotation
xRR_Rotate_0 :: Rotation
zPixmap :: ImageFormat
xyPixmap :: ImageFormat
xyBitmap :: ImageFormat
fontRightToLeft :: FontDirection
fontLeftToRight :: FontDirection
doBlue :: Word8
doGreen :: Word8
doRed :: Word8
always :: BackingStore
whenMapped :: BackingStore
notUseful :: BackingStore
unmapGravity :: WindowGravity
staticGravity :: BitGravity
southEastGravity :: BitGravity
southGravity :: BitGravity
southWestGravity :: BitGravity
eastGravity :: BitGravity
centerGravity :: BitGravity
westGravity :: BitGravity
northEastGravity :: BitGravity
northGravity :: BitGravity
northWestGravity :: BitGravity
forgetGravity :: BitGravity
setModeDelete :: ChangeSaveSetMode
setModeInsert :: ChangeSaveSetMode
mappingPointer :: MappingRequest
mappingKeyboard :: MappingRequest
mappingModifier :: MappingRequest
allocAll :: ColormapAlloc
allocNone :: ColormapAlloc
mSBFirst :: ByteOrder
lSBFirst :: ByteOrder
lowerHighest :: CirculationDirection
raiseLowest :: CirculationDirection
gCLastBit :: GCMask
gCArcMode :: GCMask
gCDashList :: GCMask
gCDashOffset :: GCMask
gCClipMask :: GCMask
gCClipYOrigin :: GCMask
gCClipXOrigin :: GCMask
gCGraphicsExposures :: GCMask
gCSubwindowMode :: GCMask
gCFont :: GCMask
gCTileStipYOrigin :: GCMask
gCTileStipXOrigin :: GCMask
gCStipple :: GCMask
gCTile :: GCMask
gCFillRule :: GCMask
gCFillStyle :: GCMask
gCJoinStyle :: GCMask
gCCapStyle :: GCMask
gCLineStyle :: GCMask
gCLineWidth :: GCMask
gCBackground :: GCMask
gCForeground :: GCMask
gCPlaneMask :: GCMask
gCFunction :: GCMask
arcPieSlice :: ArcMode
arcChord :: ArcMode
convex :: PolygonShape
nonconvex :: PolygonShape
complex :: PolygonShape
coordModePrevious :: CoordinateMode
coordModeOrigin :: CoordinateMode
includeInferiors :: SubWindowMode
clipByChildren :: SubWindowMode
windingRule :: FillRule
evenOddRule :: FillRule
fillOpaqueStippled :: FillStyle
fillStippled :: FillStyle
fillTiled :: FillStyle
fillSolid :: FillStyle
joinBevel :: JoinStyle
joinRound :: JoinStyle
joinMiter :: JoinStyle
capProjecting :: CapStyle
capRound :: CapStyle
capButt :: CapStyle
capNotLast :: CapStyle
lineDoubleDash :: LineStyle
lineOnOffDash :: LineStyle
lineSolid :: LineStyle
gXset :: GXFunction
gXnand :: GXFunction
gXorInverted :: GXFunction
gXcopyInverted :: GXFunction
gXorReverse :: GXFunction
gXinvert :: GXFunction
gXequiv :: GXFunction
gXnor :: GXFunction
gXor :: GXFunction
gXxor :: GXFunction
gXnoop :: GXFunction
gXandInverted :: GXFunction
gXcopy :: GXFunction
gXandReverse :: GXFunction
gXand :: GXFunction
gXclear :: GXFunction
stippleShape :: QueryBestSizeClass
tileShape :: QueryBestSizeClass
cursorShape :: QueryBestSizeClass
retainTemporary :: CloseDownMode
retainPermanent :: CloseDownMode
destroyAll :: CloseDownMode
cWHeight :: AttributeMask
cWWidth :: AttributeMask
cWY :: AttributeMask
cWX :: AttributeMask
cWCursor :: AttributeMask
cWColormap :: AttributeMask
cWDontPropagate :: AttributeMask
cWEventMask :: AttributeMask
cWSaveUnder :: AttributeMask
cWOverrideRedirect :: AttributeMask
cWBackingPixel :: AttributeMask
cWBackingPlanes :: AttributeMask
cWBackingStore :: AttributeMask
cWWinGravity :: AttributeMask
cWBitGravity :: AttributeMask
cWBorderPixel :: AttributeMask
cWBorderPixmap :: AttributeMask
cWBackPixel :: AttributeMask
cWBackPixmap :: AttributeMask
inputOnly :: WindowClass
inputOutput :: WindowClass
copyFromParent :: WindowClass
throwIfZero :: String -> IO Status -> IO ()
lastExtensionError :: ErrorCode
firstExtensionError :: ErrorCode
badImplementation :: ErrorCode
badLength :: ErrorCode
badName :: ErrorCode
badIDChoice :: ErrorCode

-- | Xlib functions with return values of type <tt>Status</tt> return zero
--   on failure and nonzero on success.
badGC :: ErrorCode
badColor :: ErrorCode
badAlloc :: ErrorCode
badAccess :: ErrorCode
badDrawable :: ErrorCode
badMatch :: ErrorCode
badFont :: ErrorCode
badCursor :: ErrorCode
badAtom :: ErrorCode
badPixmap :: ErrorCode
badWindow :: ErrorCode
badValue :: ErrorCode
badRequest :: ErrorCode
success :: ErrorCode
revertToParent :: FocusMode
revertToPointerRoot :: FocusMode
revertToNone :: FocusMode
syncBoth :: AllowEvents
asyncBoth :: AllowEvents
replayKeyboard :: AllowEvents
syncKeyboard :: AllowEvents
asyncKeyboard :: AllowEvents
replayPointer :: AllowEvents
syncPointer :: AllowEvents
asyncPointer :: AllowEvents
grabFrozen :: GrabStatus
grabNotViewable :: GrabStatus
grabInvalidTime :: GrabStatus
alreadyGrabbed :: GrabStatus
grabSuccess :: GrabStatus
grabModeAsync :: GrabMode
grabModeSync :: GrabMode
colormapInstalled :: ColormapNotification
colormapUninstalled :: ColormapNotification
propertyDelete :: PropertyNotification
propertyNewValue :: PropertyNotification
familyChaos :: Protocol
familyDECnet :: Protocol
familyInternet :: Protocol
placeOnBottom :: Place
placeOnTop :: Place
visibilityFullyObscured :: Visibility
visibilityPartiallyObscured :: Visibility
visibilityUnobscured :: Visibility
notifyDetailNone :: NotifyDetail
notifyPointerRoot :: NotifyDetail
notifyPointer :: NotifyDetail
notifyNonlinearVirtual :: NotifyDetail
notifyNonlinear :: NotifyDetail
notifyInferior :: NotifyDetail
notifyVirtual :: NotifyDetail
notifyAncestor :: NotifyDetail
notifyHint :: NotifyMode
notifyWhileGrabbed :: NotifyMode
notifyUngrab :: NotifyMode
notifyGrab :: NotifyMode
notifyNormal :: NotifyMode
button5 :: Button
button4 :: Button
button3 :: Button
button2 :: Button
button1 :: Button
button5Mask :: ButtonMask
button4Mask :: ButtonMask
button3Mask :: ButtonMask
button2Mask :: ButtonMask
button1Mask :: ButtonMask
mod5Mask :: KeyMask
mod4Mask :: KeyMask
mod3Mask :: KeyMask
mod2Mask :: KeyMask
mod1Mask :: KeyMask
controlMask :: KeyMask
lockMask :: KeyMask
shiftMask :: KeyMask
noModMask :: KeyMask
anyModifier :: Modifier
mod5MapIndex :: Modifier
mod4MapIndex :: Modifier
mod3MapIndex :: Modifier
mod2MapIndex :: Modifier
mod1MapIndex :: Modifier
controlMapIndex :: Modifier
lockMapIndex :: Modifier
shiftMapIndex :: Modifier
screenSaverNotify :: EventType
lASTEvent :: EventType
rrNotifyOutputProperty :: EventType
rrNotifyOutputChange :: EventType
rrNotifyCrtcChange :: EventType
rrNotify :: EventType
rrScreenChangeNotify :: EventType
mappingNotify :: EventType
clientMessage :: EventType
colormapNotify :: EventType
selectionNotify :: EventType
selectionRequest :: EventType
selectionClear :: EventType
propertyNotify :: EventType
circulateRequest :: EventType
circulateNotify :: EventType
resizeRequest :: EventType
gravityNotify :: EventType
configureRequest :: EventType
configureNotify :: EventType
reparentNotify :: EventType
mapRequest :: EventType
mapNotify :: EventType
unmapNotify :: EventType
destroyNotify :: EventType
createNotify :: EventType
visibilityNotify :: EventType
noExpose :: EventType
graphicsExpose :: EventType
expose :: EventType
keymapNotify :: EventType
focusOut :: EventType
focusIn :: EventType
leaveNotify :: EventType
enterNotify :: EventType
motionNotify :: EventType
buttonRelease :: EventType
buttonPress :: EventType
keyRelease :: EventType
keyPress :: EventType
screenSaverNotifyMask :: EventMask
screenSaverCycleMask :: EventMask
rrOutputPropertyNotifyMask :: EventMask
rrOutputChangeNotifyMask :: EventMask
rrCrtcChangeNotifyMask :: EventMask
rrScreenChangeNotifyMask :: EventMask
ownerGrabButtonMask :: EventMask
colormapChangeMask :: EventMask
propertyChangeMask :: EventMask
focusChangeMask :: EventMask
substructureRedirectMask :: EventMask
substructureNotifyMask :: EventMask
resizeRedirectMask :: EventMask
structureNotifyMask :: EventMask
visibilityChangeMask :: EventMask
exposureMask :: EventMask
keymapStateMask :: EventMask
buttonMotionMask :: EventMask
button5MotionMask :: EventMask
button4MotionMask :: EventMask
button3MotionMask :: EventMask
button2MotionMask :: EventMask
button1MotionMask :: EventMask
pointerMotionHintMask :: EventMask
pointerMotionMask :: EventMask
leaveWindowMask :: EventMask
enterWindowMask :: EventMask
buttonReleaseMask :: EventMask
buttonPressMask :: EventMask
keyReleaseMask :: EventMask
keyPressMask :: EventMask
noEventMask :: EventMask
xK_ydiaeresis :: KeySym
xK_thorn :: KeySym
xK_yacute :: KeySym
xK_udiaeresis :: KeySym
xK_ucircumflex :: KeySym
xK_uacute :: KeySym
xK_ugrave :: KeySym
xK_oslash :: KeySym
xK_division :: KeySym
xK_odiaeresis :: KeySym
xK_otilde :: KeySym
xK_ocircumflex :: KeySym
xK_oacute :: KeySym
xK_ograve :: KeySym
xK_ntilde :: KeySym
xK_eth :: KeySym
xK_idiaeresis :: KeySym
xK_icircumflex :: KeySym
xK_iacute :: KeySym
xK_igrave :: KeySym
xK_ediaeresis :: KeySym
xK_ecircumflex :: KeySym
xK_eacute :: KeySym
xK_egrave :: KeySym
xK_ccedilla :: KeySym
xK_ae :: KeySym
xK_aring :: KeySym
xK_adiaeresis :: KeySym
xK_atilde :: KeySym
xK_acircumflex :: KeySym
xK_aacute :: KeySym
xK_agrave :: KeySym
xK_ssharp :: KeySym
xK_Thorn :: KeySym
xK_THORN :: KeySym
xK_Yacute :: KeySym
xK_Udiaeresis :: KeySym
xK_Ucircumflex :: KeySym
xK_Uacute :: KeySym
xK_Ugrave :: KeySym
xK_Ooblique :: KeySym
xK_multiply :: KeySym
xK_Odiaeresis :: KeySym
xK_Otilde :: KeySym
xK_Ocircumflex :: KeySym
xK_Oacute :: KeySym
xK_Ograve :: KeySym
xK_Ntilde :: KeySym
xK_Eth :: KeySym
xK_ETH :: KeySym
xK_Idiaeresis :: KeySym
xK_Icircumflex :: KeySym
xK_Iacute :: KeySym
xK_Igrave :: KeySym
xK_Ediaeresis :: KeySym
xK_Ecircumflex :: KeySym
xK_Eacute :: KeySym
xK_Egrave :: KeySym
xK_Ccedilla :: KeySym
xK_AE :: KeySym
xK_Aring :: KeySym
xK_Adiaeresis :: KeySym
xK_Atilde :: KeySym
xK_Acircumflex :: KeySym
xK_Aacute :: KeySym
xK_Agrave :: KeySym
xK_questiondown :: KeySym
xK_threequarters :: KeySym
xK_onehalf :: KeySym
xK_onequarter :: KeySym
xK_guillemotright :: KeySym
xK_masculine :: KeySym
xK_onesuperior :: KeySym
xK_cedilla :: KeySym
xK_periodcentered :: KeySym
xK_paragraph :: KeySym
xK_mu :: KeySym
xK_acute :: KeySym
xK_threesuperior :: KeySym
xK_twosuperior :: KeySym
xK_plusminus :: KeySym
xK_degree :: KeySym
xK_macron :: KeySym
xK_registered :: KeySym
xK_hyphen :: KeySym
xK_notsign :: KeySym
xK_guillemotleft :: KeySym
xK_ordfeminine :: KeySym
xK_copyright :: KeySym
xK_diaeresis :: KeySym
xK_section :: KeySym
xK_brokenbar :: KeySym
xK_yen :: KeySym
xK_currency :: KeySym
xK_sterling :: KeySym
xK_cent :: KeySym
xK_exclamdown :: KeySym
xK_nobreakspace :: KeySym
xK_asciitilde :: KeySym
xK_braceright :: KeySym
xK_bar :: KeySym
xK_braceleft :: KeySym
xK_z :: KeySym
xK_y :: KeySym
xK_x :: KeySym
xK_w :: KeySym
xK_v :: KeySym
xK_u :: KeySym
xK_t :: KeySym
xK_s :: KeySym
xK_r :: KeySym
xK_q :: KeySym
xK_p :: KeySym
xK_o :: KeySym
xK_n :: KeySym
xK_m :: KeySym
xK_l :: KeySym
xK_k :: KeySym
xK_j :: KeySym
xK_i :: KeySym
xK_h :: KeySym
xK_g :: KeySym
xK_f :: KeySym
xK_e :: KeySym
xK_d :: KeySym
xK_c :: KeySym
xK_b :: KeySym
xK_a :: KeySym
xK_quoteleft :: KeySym
xK_grave :: KeySym
xK_underscore :: KeySym
xK_asciicircum :: KeySym
xK_bracketright :: KeySym
xK_backslash :: KeySym
xK_bracketleft :: KeySym
xK_Z :: KeySym
xK_Y :: KeySym
xK_X :: KeySym
xK_W :: KeySym
xK_V :: KeySym
xK_U :: KeySym
xK_T :: KeySym
xK_S :: KeySym
xK_R :: KeySym
xK_Q :: KeySym
xK_P :: KeySym
xK_O :: KeySym
xK_N :: KeySym
xK_M :: KeySym
xK_L :: KeySym
xK_K :: KeySym
xK_J :: KeySym
xK_I :: KeySym
xK_H :: KeySym
xK_G :: KeySym
xK_F :: KeySym
xK_E :: KeySym
xK_D :: KeySym
xK_C :: KeySym
xK_B :: KeySym
xK_A :: KeySym
xK_at :: KeySym
xK_question :: KeySym
xK_greater :: KeySym
xK_equal :: KeySym
xK_less :: KeySym
xK_semicolon :: KeySym
xK_colon :: KeySym
xK_9 :: KeySym
xK_8 :: KeySym
xK_7 :: KeySym
xK_6 :: KeySym
xK_5 :: KeySym
xK_4 :: KeySym
xK_3 :: KeySym
xK_2 :: KeySym
xK_1 :: KeySym
xK_0 :: KeySym
xK_slash :: KeySym
xK_period :: KeySym
xK_minus :: KeySym
xK_comma :: KeySym
xK_plus :: KeySym
xK_asterisk :: KeySym
xK_parenright :: KeySym
xK_parenleft :: KeySym
xK_quoteright :: KeySym
xK_apostrophe :: KeySym
xK_ampersand :: KeySym
xK_percent :: KeySym
xK_dollar :: KeySym
xK_numbersign :: KeySym
xK_quotedbl :: KeySym
xK_exclam :: KeySym
xK_space :: KeySym
xK_Hyper_R :: KeySym
xK_Hyper_L :: KeySym
xK_Super_R :: KeySym
xK_Super_L :: KeySym
xK_Alt_R :: KeySym
xK_Alt_L :: KeySym
xK_Meta_R :: KeySym
xK_Meta_L :: KeySym
xK_Shift_Lock :: KeySym
xK_Caps_Lock :: KeySym
xK_Control_R :: KeySym
xK_Control_L :: KeySym
xK_Shift_R :: KeySym
xK_Shift_L :: KeySym
xK_R15 :: KeySym
xK_F35 :: KeySym
xK_R14 :: KeySym
xK_F34 :: KeySym
xK_R13 :: KeySym
xK_F33 :: KeySym
xK_R12 :: KeySym
xK_F32 :: KeySym
xK_R11 :: KeySym
xK_F31 :: KeySym
xK_R10 :: KeySym
xK_F30 :: KeySym
xK_R9 :: KeySym
xK_F29 :: KeySym
xK_R8 :: KeySym
xK_F28 :: KeySym
xK_R7 :: KeySym
xK_F27 :: KeySym
xK_R6 :: KeySym
xK_F26 :: KeySym
xK_R5 :: KeySym
xK_F25 :: KeySym
xK_R4 :: KeySym
xK_F24 :: KeySym
xK_R3 :: KeySym
xK_F23 :: KeySym
xK_R2 :: KeySym
xK_F22 :: KeySym
xK_R1 :: KeySym
xK_F21 :: KeySym
xK_L10 :: KeySym
xK_F20 :: KeySym
xK_L9 :: KeySym
xK_F19 :: KeySym
xK_L8 :: KeySym
xK_F18 :: KeySym
xK_L7 :: KeySym
xK_F17 :: KeySym
xK_L6 :: KeySym
xK_F16 :: KeySym
xK_L5 :: KeySym
xK_F15 :: KeySym
xK_L4 :: KeySym
xK_F14 :: KeySym
xK_L3 :: KeySym
xK_F13 :: KeySym
xK_L2 :: KeySym
xK_F12 :: KeySym
xK_L1 :: KeySym
xK_F11 :: KeySym
xK_F10 :: KeySym
xK_F9 :: KeySym
xK_F8 :: KeySym
xK_F7 :: KeySym
xK_F6 :: KeySym
xK_F5 :: KeySym
xK_F4 :: KeySym
xK_F3 :: KeySym
xK_F2 :: KeySym
xK_F1 :: KeySym
xK_KP_9 :: KeySym
xK_KP_8 :: KeySym
xK_KP_7 :: KeySym
xK_KP_6 :: KeySym
xK_KP_5 :: KeySym
xK_KP_4 :: KeySym
xK_KP_3 :: KeySym
xK_KP_2 :: KeySym
xK_KP_1 :: KeySym
xK_KP_0 :: KeySym
xK_KP_Divide :: KeySym
xK_KP_Decimal :: KeySym
xK_KP_Subtract :: KeySym
xK_KP_Separator :: KeySym
xK_KP_Add :: KeySym
xK_KP_Multiply :: KeySym
xK_KP_Equal :: KeySym
xK_KP_Delete :: KeySym
xK_KP_Insert :: KeySym
xK_KP_Begin :: KeySym
xK_KP_End :: KeySym
xK_KP_Page_Down :: KeySym
xK_KP_Next :: KeySym
xK_KP_Page_Up :: KeySym
xK_KP_Prior :: KeySym
xK_KP_Down :: KeySym
xK_KP_Right :: KeySym
xK_KP_Up :: KeySym
xK_KP_Left :: KeySym
xK_KP_Home :: KeySym
xK_KP_F4 :: KeySym
xK_KP_F3 :: KeySym
xK_KP_F2 :: KeySym
xK_KP_F1 :: KeySym
xK_KP_Enter :: KeySym
xK_KP_Tab :: KeySym
xK_KP_Space :: KeySym
xK_Num_Lock :: KeySym
xK_script_switch :: KeySym
xK_Mode_switch :: KeySym
xK_Break :: KeySym
xK_Help :: KeySym
xK_Cancel :: KeySym
xK_Find :: KeySym
xK_Menu :: KeySym
xK_Redo :: KeySym
xK_Undo :: KeySym
xK_Insert :: KeySym
xK_Execute :: KeySym
xK_Print :: KeySym
xK_Select :: KeySym
xK_Begin :: KeySym
xK_End :: KeySym
xK_Page_Down :: KeySym
xK_Next :: KeySym
xK_Page_Up :: KeySym
xK_Prior :: KeySym
xK_Down :: KeySym
xK_Right :: KeySym
xK_Up :: KeySym
xK_Left :: KeySym
xK_Home :: KeySym
xK_PreviousCandidate :: KeySym
xK_MultipleCandidate :: KeySym
xK_SingleCandidate :: KeySym
xK_Codeinput :: KeySym
xK_Multi_key :: KeySym
xK_Delete :: KeySym
xK_Escape :: KeySym
xK_Sys_Req :: KeySym
xK_Scroll_Lock :: KeySym
xK_Pause :: KeySym
xK_Return :: KeySym
xK_Clear :: KeySym
xK_Linefeed :: KeySym
xK_Tab :: KeySym
xK_BackSpace :: KeySym
xK_VoidSymbol :: KeySym
type XID = Word64
type Mask = Word64
type Atom = Word64
type VisualID = Word64
type Time = Word64
type Window = XID
type Drawable = XID
type Font = XID
type Pixmap = XID
type Cursor = XID
type Colormap = XID
type GContext = XID
type KeyCode = Word8
type KeySym = XID
type EventMask = Mask
type EventType = Word32
type Modifier = CUInt
type KeyMask = Modifier
type ButtonMask = Modifier
type Button = Word32
type NotifyMode = CInt
type NotifyDetail = CInt
type Visibility = CInt

-- | Place of window relative to siblings (used in Circulation requests or
--   events)
type Place = CInt
type Protocol = CInt
type PropertyNotification = CInt
type ColormapNotification = CInt
type GrabMode = CInt
type GrabStatus = CInt
type AllowEvents = CInt
type FocusMode = CInt
type ErrorCode = CInt
type Status = CInt
type WindowClass = CInt
type AttributeMask = Mask
type CloseDownMode = CInt
type QueryBestSizeClass = CInt
type GXFunction = CInt
type LineStyle = CInt
type CapStyle = CInt
type JoinStyle = CInt
type FillStyle = CInt
type FillRule = CInt
type SubWindowMode = CInt
type CoordinateMode = CInt
type PolygonShape = CInt
type ArcMode = CInt
type GCMask = CInt
type CirculationDirection = CInt
type ByteOrder = CInt
type ColormapAlloc = CInt
type MappingRequest = CInt
type ChangeSaveSetMode = CInt
type BitGravity = CInt
type WindowGravity = CInt
type BackingStore = CInt
type FontDirection = CInt
type ImageFormat = CInt
type Rotation = Word16
type Reflection = Word16
type SizeID = Word16
type SubpixelOrder = Word16
type Connection = Word16
type RROutput = Word64
type RRCrtc = Word64
type RRMode = Word64
type XRRModeFlags = Word64

-- | Bitwise "or"
(.|.) :: Bits a => a -> a -> a
infixl 5 .|.

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: Type -> Type) | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r (m :: Type -> Type) | m -> r

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Executes a computation in a modified environment.
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | Retrieves a function of the current environment.
reader :: MonadReader r m => (r -> a) -> m a

-- | Retrieves a function of the current environment.
asks :: MonadReader r m => (r -> a) -> m a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a
