<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>XMonad.Doc.Extending</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">xmonad-contrib-0.16.999: Community-maintained extensions extensions for xmonad</span><ul class="links" id="page-menu"><li><a href="src/XMonad.Doc.Extending.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(C) 2007 Andrea Rossato</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>andrea.rossato@unibz.it</td></tr><tr><th>Stability</th><td>unstable</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">XMonad.Doc.Extending</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">The xmonad-contrib library</a><ul><li><a href="#g:2">Actions</a></li><li><a href="#g:3">Hooks</a></li><li><a href="#g:4">Layouts</a></li><li><a href="#g:5">Prompts</a></li><li><a href="#g:6">Utilities</a></li></ul></li><li><a href="#g:7">Extending xmonad</a><ul><li><a href="#g:8">Editing key bindings</a><ul><li><a href="#g:9">Adding key bindings</a></li><li><a href="#g:10">Removing key bindings</a></li><li><a href="#g:11">Adding and removing key bindings</a></li></ul></li><li><a href="#g:12">Editing mouse bindings</a></li><li><a href="#g:13">Editing the layout hook</a></li><li><a href="#g:14">Editing the manage hook</a></li><li><a href="#g:15">The log hook and external status bars</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module documents the xmonad-contrib library and
 how to use it to extend the capabilities of xmonad.</p><p>Reading this document should not require a deep knowledge of
 Haskell; the examples are intended to be useful and understandable
 for those users who do not know Haskell and don't want to have to
 learn it just to configure xmonad.  You should be able to get by
 just fine by ignoring anything you don't understand and using the
 provided examples as templates.  However, relevant Haskell features
 are discussed when appropriate, so this document will hopefully be
 useful for more advanced Haskell users as well.</p><p>Those wishing to be totally hardcore and develop their own xmonad
 extensions (it's easier than it sounds, we promise!) should read
 the documentation in <a href="XMonad-Doc-Developing.html">XMonad.Doc.Developing</a>.</p><p>More configuration examples may be found on the Haskell wiki:</p><p><a href="http://haskell.org/haskellwiki/Xmonad/Config_archive">http://haskell.org/haskellwiki/Xmonad/Config_archive</a></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>The xmonad-contrib library</h1></a><div class="doc"><p>The xmonad-contrib (xmc) library is a set of extension modules
contributed by xmonad hackers and users, which provide additional
xmonad features.  Examples include various layout modes (tabbed,
spiral, three-column...), prompts, program launchers, the ability to
manipulate windows and workspaces in various ways, alternate
navigation modes, and much more.  There are also &quot;meta-modules&quot;
which make it easier to write new modules and extensions.</p><p>This is a description of the different namespaces in xmonad-contrib.
For more information about any particular module, go to the root of
the documentation and just click on its name to view its Haddock
documentation; each module should come with extensive documentation.
If you find a module that could be better documented, or has incorrect
documentation, please report it as a bug
(<a href="https://github.com/xmonad/xmonad-contrib/issues">https://github.com/xmonad/xmonad-contrib/issues</a>)!</p><p>First and foremost, xmonad defines its own prelude for commonly used
functions, as well as re-exports from <code>base</code>.</p><ul><li><a href="XMonad-Prelude.html">XMonad.Prelude</a>:
    Utility functions and re-exports for a more ergonomic developing
    experience.</li></ul><p>There are also other documentation modules, showing you around
individual parts of xmonad:</p><ul><li><a href="XMonad-Doc-Configuring.html">XMonad.Doc.Configuring</a>:
    Brief tutorial that will teach you how to create a basic
    xmonad configuration.</li><li><a href="XMonad-Doc-Developing.html">XMonad.Doc.Developing</a>:
    A brief overview of xmonad's internals.</li></ul><p>A list of the contrib modules can be found at
<a href="https://xmonad.github.io/xmonad-docs/xmonad-contrib-0.16.999/">https://xmonad.github.io/xmonad-docs/xmonad-contrib-0.16.999/</a></p></div><a href="#g:2" id="g:2"><h2>Actions</h2></a><div class="doc"><p>In the <code>XMonad.Actions</code> namespace you can find modules exporting
various functions that are usually intended to be bound to key
combinations or mouse actions, in order to provide functionality
beyond the standard keybindings provided by xmonad.</p><p>See <a href="XMonad-Doc-Extending.html#Editing_key_bindings">XMonad.Doc.Extending</a> for instructions on how to
edit your key bindings.</p></div><a href="#g:3" id="g:3"><h2>Hooks</h2></a><div class="doc"><p>In the <code>XMonad.Hooks</code> namespace you can find modules exporting
hooks. Hooks are actions that xmonad performs when certain events
occur. The three most important hooks are:</p><ul><li><code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:manageHook" title="XMonad.Core">manageHook</a></code>: this hook is called when a new window
  xmonad must take care of is created. This is a very powerful hook,
  since it lets us examine the new window's properties and act
  accordingly. For instance, we can configure xmonad to put windows
  belonging to a given application in the float layer, not to manage
  dock applications, or open them in a given workspace. See
  <a href="XMonad-Doc-Extending.html#Editing_the_manage_hook">XMonad.Doc.Extending</a> for more information on
  customizing <code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:manageHook" title="XMonad.Core">manageHook</a></code>.</li><li><code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:logHook" title="XMonad.Core">logHook</a></code>: this hook is called when the stack of windows
  managed by xmonad has been changed, by calling the
  <code><a href="../xmonad-0.16.99999/XMonad-Operations.html#v:windows" title="XMonad.Operations">windows</a></code> function. For instance
  <a href="XMonad-Hooks-DynamicLog.html">XMonad.Hooks.DynamicLog</a> will produce a string (whose format can be
  configured) to be printed to the standard output. This can be used
  to display some information about the xmonad state in a status bar.
  See <a href="XMonad-Doc-Extending.html#The_log_hook_and_external_status_bars">XMonad.Doc.Extending</a> for more
  information.</li><li><code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:handleEventHook" title="XMonad.Core">handleEventHook</a></code>: this hook is called on all events handled
  by xmonad, thus it is extremely powerful. See <a href="../X11-1.10.2/Graphics-X11-Xlib-Extras.html">Graphics.X11.Xlib.Extras</a>
  and xmonad source and development documentation for more details.</li></ul></div><a href="#g:4" id="g:4"><h2>Layouts</h2></a><div class="doc"><p>In the <code>XMonad.Layout</code> namespace you can find modules exporting
contributed tiling algorithms, such as a tabbed layout, a circle, a spiral,
three columns, and so on.</p><p>You will also find modules which provide facilities for combining
different layouts, such as <a href="XMonad-Layout-Combo.html">XMonad.Layout.Combo</a>, <a href="XMonad-Layout-ComboP.html">XMonad.Layout.ComboP</a>,
<a href="XMonad-Layout-LayoutBuilder.html">XMonad.Layout.LayoutBuilder</a>, <a href="XMonad-Layout-SubLayouts.html">XMonad.Layout.SubLayouts</a>, or
<a href="XMonad-Layout-LayoutCombinators.html">XMonad.Layout.LayoutCombinators</a>.</p><p>Layouts can be also modified with layout modifiers. A general
interface for writing layout modifiers is implemented in
<a href="XMonad-Layout-LayoutModifier.html">XMonad.Layout.LayoutModifier</a>.</p><p>For more information on using those modules for customizing your
<code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:layoutHook" title="XMonad.Core">layoutHook</a></code> see <a href="XMonad-Doc-Extending.html#Editing_the_layout_hook">XMonad.Doc.Extending</a>.</p></div><a href="#g:5" id="g:5"><h2>Prompts</h2></a><div class="doc"><p>In the <code>XMonad.Prompt</code> name space you can find modules providing
graphical prompts for getting user input and using it to perform
various actions.</p><p>The <a href="XMonad-Prompt.html">XMonad.Prompt</a> provides a library for easily writing new prompt
modules.</p></div><a href="#g:6" id="g:6"><h2>Utilities</h2></a><div class="doc"><p>In the <code>XMonad.Util</code> namespace you can find modules exporting various
utility functions that are used by the other modules of the
xmonad-contrib library.</p><p>There are also utilities for helping in configuring xmonad or using
external utilities.</p></div><a href="#g:7" id="g:7"><h1>Extending xmonad</h1></a><div class="doc"><p><a id="Extending_xmonad"></a></p><p>Since the <code>xmonad.hs</code> file is just another Haskell module, you may
import and use any Haskell code or libraries you wish, such as
extensions from the xmonad-contrib library, or other code you write
yourself.</p></div><a href="#g:8" id="g:8"><h2>Editing key bindings</h2></a><div class="doc"><p><a id="Editing_key_bindings"></a></p><p>Editing key bindings means changing the <code><a href="XMonad-Core-XConfig.html#v:keys" title="XMonad.Core.XConfig">keys</a></code>
field of the <code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:XConfig" title="XMonad.Core">XConfig</a></code> record used by xmonad.  For
example, you could write:</p><pre>   import XMonad

   main = xmonad $ def { keys = myKeys }</pre><p>and provide an appropriate definition of <code>myKeys</code>, such as:</p><pre>myKeys conf@(XConfig {XMonad.modMask = modm}) = M.fromList
            [ ((modm, xK_F12), xmonadPrompt def)
            , ((modm, xK_F3 ), shellPrompt  def)
            ]</pre><p>This particular definition also requires importing <a href="XMonad-Prompt.html">XMonad.Prompt</a>,
<a href="XMonad-Prompt-Shell.html">XMonad.Prompt.Shell</a>, <a href="XMonad-Prompt-XMonad.html">XMonad.Prompt.XMonad</a>, and <a href="../containers-0.6.2.1/Data-Map.html">Data.Map</a>:</p><pre>import qualified Data.Map as M
import XMonad.Prompt
import XMonad.Prompt.Shell
import XMonad.Prompt.XMonad</pre><p>For a list of the names of particular keys (such as xK_F12, and so
on), see
<a href="http://hackage.haskell.org/packages/archive/X11/latest/doc/html/Graphics-X11-Types.html">http://hackage.haskell.org/packages/archive/X11/latest/doc/html/Graphics-X11-Types.html</a></p><p>Usually, rather than completely redefining the key bindings, as we did
above, we want to simply add some new bindings and/or remove existing
ones.</p></div><a href="#g:9" id="g:9"><h3>Adding key bindings</h3></a><div class="doc"><p><a id="Adding_key_bindings"></a></p><p>Adding key bindings can be done in different ways. See the end of this
section for the easiest ways. The type signature of
<code><a href="XMonad-Core-XConfig.html#v:keys" title="XMonad.Core.XConfig">keys</a></code> is:</p><pre>   keys :: XConfig Layout -&gt; M.Map (ButtonMask,KeySym) (X ())</pre><p>In order to add new key bindings, you need to first create an
appropriate <code><a href="../containers-0.6.2.1/Data-Map.html#v:Map" title="Data.Map">Map</a></code> from a list of key bindings using
<code><a href="../containers-0.6.2.1/Data-Map.html#v:fromList" title="Data.Map">fromList</a></code>.  This <code><a href="../containers-0.6.2.1/Data-Map.html#v:Map" title="Data.Map">Map</a></code> of new key bindings then
needs to be joined to a <code><a href="../containers-0.6.2.1/Data-Map.html#v:Map" title="Data.Map">Map</a></code> of existing bindings using
<code><a href="../containers-0.6.2.1/Data-Map.html#v:union" title="Data.Map">union</a></code>.</p><p>Since we are going to need some of the functions of the <a href="../containers-0.6.2.1/Data-Map.html">Data.Map</a>
module, before starting we must first import this modules:</p><pre>   import qualified Data.Map as M</pre><p>For instance, if you have defined some additional key bindings like
these:</p><pre>   myKeys conf@(XConfig {XMonad.modMask = modm}) = M.fromList
            [ ((modm, xK_F12), xmonadPrompt def)
            , ((modm, xK_F3 ), shellPrompt  def)
            ]</pre><p>then you can create a new key bindings map by joining the default one
with yours:</p><pre>   newKeys x  = myKeys x `M.union` keys def x</pre><p>Finally, you can use <code>newKeys</code> in the <code><a href="XMonad-Core-XConfig.html#v:keys" title="XMonad.Core.XConfig">keys</a></code> field
of the configuration:</p><pre>   main = xmonad $ def { keys = newKeys }</pre><p>Alternatively, the <code>&lt;+&gt;</code> operator can be used which in this usage does exactly
the same as the explicit usage of <code><a href="M.html#v:union" title="M">union</a></code> and propagation of the config
argument, thanks to appropriate instances in <a href="../base-4.14.1.0/Data-Monoid.html">Data.Monoid</a>.</p><pre>   main = xmonad $ def { keys = myKeys &lt;+&gt; keys def }</pre><p>All together, your <code>~/.xmonad/xmonad.hs</code> would now look like this:</p><pre>   module Main (main) where

   import XMonad

   import qualified Data.Map as M
   import Graphics.X11.Xlib
   import XMonad.Prompt
   import XMonad.Prompt.Shell
   import XMonad.Prompt.XMonad

   main :: IO ()
   main = xmonad $ def { keys = myKeys &lt;+&gt; keys def }

   myKeys conf@(XConfig {XMonad.modMask = modm}) = M.fromList
            [ ((modm, xK_F12), xmonadPrompt def)
            , ((modm, xK_F3 ), shellPrompt  def)
            ]</pre><p>There are much simpler ways to accomplish this, however, if you are
willing to use an extension module to help you configure your keys.
For instance, <a href="XMonad-Util-EZConfig.html">XMonad.Util.EZConfig</a> and <a href="XMonad-Util-CustomKeys.html">XMonad.Util.CustomKeys</a> both
provide useful functions for editing your key bindings; <a href="XMonad-Util-EZConfig.html">XMonad.Util.EZConfig</a> even lets you use emacs-style keybinding descriptions like &quot;M-C-<a href="F12">F12</a>&quot;.</p></div><a href="#g:10" id="g:10"><h3>Removing key bindings</h3></a><div class="doc"><p><a id="Removing_key_bindings"></a></p><p>Removing key bindings requires modifying the <code><a href="../containers-0.6.2.1/Data-Map.html#v:Map" title="Data.Map">Map</a></code> which
stores the key bindings.  This can be done with <code><a href="../containers-0.6.2.1/Data-Map.html#v:difference" title="Data.Map">difference</a></code>
or with <code><a href="../containers-0.6.2.1/Data-Map.html#v:delete" title="Data.Map">delete</a></code>.</p><p>For example, suppose you want to get rid of <code>mod-q</code> and <code>mod-shift-q</code>
(you just want to leave xmonad running forever). To do this you need
to define <code>newKeys</code> as a <code><a href="../containers-0.6.2.1/Data-Map.html#v:difference" title="Data.Map">difference</a></code> between the default
map and the map of the key bindings you want to remove.  Like so:</p><pre>   newKeys x = keys def x `M.difference` keysToRemove x

   keysToRemove :: XConfig Layout -&gt;    M.Map (KeyMask, KeySym) (X ())
   keysToRemove x = M.fromList
            [ ((modm              , xK_q ), return ())
            , ((modm .|. shiftMask, xK_q ), return ())
            ]</pre><p>As you can see, it doesn't matter what actions we associate with the
keys listed in <code>keysToRemove</code>, so we just use <code>return ()</code> (the
&quot;null&quot; action).</p><p>It is also possible to simply define a list of keys we want to unbind
and then use <code><a href="../containers-0.6.2.1/Data-Map.html#v:delete" title="Data.Map">delete</a></code> to remove them. In that case we would
write something like:</p><pre>   newKeys x = foldr M.delete (keys def x) (keysToRemove x)

   keysToRemove :: XConfig Layout -&gt; [(KeyMask, KeySym)]
   keysToRemove x =
            [ (modm              , xK_q )
            , (modm .|. shiftMask, xK_q )
            ]</pre><p>Another even simpler possibility is the use of some of the utilities
provided by the xmonad-contrib library. Look, for instance, at
<code><a href="XMonad-Util-EZConfig.html#v:removeKeys" title="XMonad.Util.EZConfig">removeKeys</a></code>.</p></div><a href="#g:11" id="g:11"><h3>Adding and removing key bindings</h3></a><div class="doc"><p><a id="Adding_and_removing_key_bindings"></a></p><p>Adding and removing key bindings requires simply combining the steps
for removing and adding.  Here is an example from
<a href="XMonad-Config-Arossato.html">XMonad.Config.Arossato</a>:</p><pre>   defKeys    = keys def
   delKeys x  = foldr M.delete           (defKeys x) (toRemove x)
   newKeys x  = foldr (uncurry M.insert) (delKeys x) (toAdd    x)
   -- remove some of the default key bindings
   toRemove XConfig{modMask = modm} =
       [ (modm              , xK_j     )
       , (modm              , xK_k     )
       , (modm              , xK_p     )
       , (modm .|. shiftMask, xK_p     )
       , (modm .|. shiftMask, xK_q     )
       , (modm              , xK_q     )
       ] ++
       -- I want modm .|. shiftMask 1-9 to be free!
       [(shiftMask .|. modm, k) | k &lt;- [xK_1 .. xK_9]]
   -- These are my personal key bindings
   toAdd XConfig{modMask = modm} =
       [ ((modm              , xK_F12   ), xmonadPrompt def )
       , ((modm              , xK_F3    ), shellPrompt  def )
       ] ++
       -- Use modm .|. shiftMask .|. controlMask 1-9 instead
       [( (m .|. modm, k), windows $ f i)
        | (i, k) &lt;- zip (workspaces x) [xK_1 .. xK_9]
       ,  (f, m) &lt;- [(W.greedyView, 0), (W.shift, shiftMask .|. controlMask)]
       ]</pre><p>You can achieve the same result using the <a href="XMonad-Util-CustomKeys.html">XMonad.Util.CustomKeys</a>
module; take a look at the <code><a href="XMonad-Util-CustomKeys.html#v:customKeys" title="XMonad.Util.CustomKeys">customKeys</a></code>
function in particular.</p><p>NOTE: modm is defined as the modMask you defined (or left as the default) in
your config.</p></div><a href="#g:12" id="g:12"><h2>Editing mouse bindings</h2></a><div class="doc"><p><a id="Editing_mouse_bindings"></a></p><p>Most of the previous discussion of key bindings applies to mouse
bindings as well.  For example, you could configure button4 to close
the window you click on like so:</p><pre>   import qualified Data.Map as M

   myMouse x  = [ (0, button4), (\w -&gt; focus w &gt;&gt; kill) ]

   newMouse x = M.union (mouseBindings def x) (M.fromList (myMouse x))

   main = xmonad $ def { ..., mouseBindings = newMouse, ... }</pre><p>Overriding or deleting mouse bindings works similarly.  You can also
configure mouse bindings much more easily using the
<code><a href="XMonad-Util-EZConfig.html#v:additionalMouseBindings" title="XMonad.Util.EZConfig">additionalMouseBindings</a></code> and
<code><a href="XMonad-Util-EZConfig.html#v:removeMouseBindings" title="XMonad.Util.EZConfig">removeMouseBindings</a></code> functions from the
<a href="XMonad-Util-EZConfig.html">XMonad.Util.EZConfig</a> module.</p></div><a href="#g:13" id="g:13"><h2>Editing the layout hook</h2></a><div class="doc"><p><a id="Editing_the_layout_hook"></a></p><p>When you start an application that opens a new window, when you change
the focused window, or move it to another workspace, or change that
workspace's layout, xmonad will use the <code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:layoutHook" title="XMonad.Core">layoutHook</a></code> for
reordering the visible windows on the visible workspace(s).</p><p>Since different layouts may be attached to different workspaces, and
you can change them, xmonad needs to know which one to use. In this
sense the layoutHook may be thought as the list of layouts that
xmonad will use for laying out windows on the screen(s).</p><p>The problem is that the layout subsystem is implemented with an
advanced feature of the Haskell programming language: type classes.
This allows us to very easily write new layouts, combine or modify
existing layouts, create layouts with internal state, etc. See
<a href="XMonad-Doc-Extending.html#The_LayoutClass">XMonad.Doc.Extending</a> for more information. This
means that we cannot simply have a list of layouts as we used to have
before the 0.5 release: a list requires every member to belong to the
same type!</p><p>Instead the combination of layouts to be used by xmonad is created
with a specific layout combinator: <code><a href="../xmonad-0.16.99999/XMonad-Layout.html#v:-124--124--124-" title="XMonad.Layout">|||</a></code>.</p><p>Suppose we want a list with the <code><a href="../xmonad-0.16.99999/XMonad-Layout.html#v:Full" title="XMonad.Layout">Full</a></code>,
<code><a href="XMonad-Layout-Tabbed.html#v:tabbed" title="XMonad.Layout.Tabbed">tabbed</a></code> and
<code><a href="XMonad-Layout-Accordion.html#v:Accordion" title="XMonad.Layout.Accordion">Accordion</a></code> layouts. First we import, in our
<code>~/.xmonad/xmonad.hs</code>, all the needed modules:</p><pre>   import XMonad

   import XMonad.Layout.Tabbed
   import XMonad.Layout.Accordion</pre><p>Then we create the combination of layouts we need:</p><pre>   mylayoutHook = Full ||| tabbed shrinkText def ||| Accordion</pre><p>Now, all we need to do is change the <code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:layoutHook" title="XMonad.Core">layoutHook</a></code>
field of the <code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:XConfig" title="XMonad.Core">XConfig</a></code> record, like so:</p><pre>   main = xmonad $ def { layoutHook = mylayoutHook }</pre><p>Thanks to the new combinator, we can apply a layout modifier to a
whole combination of layouts, instead of applying it to each one. For
example, suppose we want to use the
<code><a href="XMonad-Layout-NoBorders.html#v:noBorders" title="XMonad.Layout.NoBorders">noBorders</a></code> layout modifier, from the
<a href="XMonad-Layout-NoBorders.html">XMonad.Layout.NoBorders</a> module (which must be imported):</p><pre>   mylayoutHook = noBorders (Full ||| tabbed shrinkText def ||| Accordion)</pre><p>If we want only the tabbed layout without borders, then we may write:</p><pre>   mylayoutHook = Full ||| noBorders (tabbed shrinkText def) ||| Accordion</pre><p>Our <code>~/.xmonad/xmonad.hs</code> will now look like this:</p><pre>   import XMonad

   import XMonad.Layout.Tabbed
   import XMonad.Layout.Accordion
   import XMonad.Layout.NoBorders

   mylayoutHook = Full ||| noBorders (tabbed shrinkText def) ||| Accordion

   main = xmonad $ def { layoutHook = mylayoutHook }</pre><p>That's it!</p></div><a href="#g:14" id="g:14"><h2>Editing the manage hook</h2></a><div class="doc"><p><a id="Editing_the_manage_hook"></a></p><p>The <code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:manageHook" title="XMonad.Core">manageHook</a></code> is a very powerful tool for customizing
the behavior of xmonad with regard to new windows.  Whenever a new
window is created, xmonad calls the <code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:manageHook" title="XMonad.Core">manageHook</a></code>, which
can thus be used to perform certain actions on the new window, such as
placing it in a specific workspace, ignoring it, or placing it in the
float layer.</p><p>The default <code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:manageHook" title="XMonad.Core">manageHook</a></code> causes xmonad to float MPlayer
and Gimp, and to ignore gnome-panel, desktop_window, kicker, and
kdesktop.</p><p>The <a href="../xmonad-0.16.99999/XMonad-ManageHook.html">XMonad.ManageHook</a> module provides some simple combinators that
can be used to alter the <code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:manageHook" title="XMonad.Core">manageHook</a></code> by replacing or adding
to the default actions.</p><p>Let's start by analyzing the default <code><a href="../xmonad-0.16.99999/XMonad-Config.html#v:manageHook" title="XMonad.Config">manageHook</a></code>, defined
in <a href="../xmonad-0.16.99999/XMonad-Config.html">XMonad.Config</a>:</p><pre>   manageHook :: ManageHook
   manageHook = composeAll
                   [ className =? &quot;MPlayer&quot;        --&gt; doFloat
                   , className =? &quot;Gimp&quot;           --&gt; doFloat
                   , resource  =? &quot;desktop_window&quot; --&gt; doIgnore
                   , resource  =? &quot;kdesktop&quot;       --&gt; doIgnore ]</pre><p><code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:composeAll" title="XMonad.ManageHook">composeAll</a></code> can be used to compose a list of
different <code><a href="../xmonad-0.16.99999/XMonad-Config.html#v:ManageHook" title="XMonad.Config">ManageHook</a></code>s. In this example we have a list
of <code><a href="../xmonad-0.16.99999/XMonad-Config.html#v:ManageHook" title="XMonad.Config">ManageHook</a></code>s formed by the following commands: the
Mplayer's and the Gimp's windows, whose <code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:className" title="XMonad.ManageHook">className</a></code>
are, respectively &quot;Mplayer&quot; and &quot;Gimp&quot;, are to be placed in the
float layer with the <code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:doFloat" title="XMonad.ManageHook">doFloat</a></code> function; the windows
whose resource names are respectively &quot;desktop_window&quot; and
kdesktop&quot; are to be ignored with the <code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:doIgnore" title="XMonad.ManageHook">doIgnore</a></code>
function.</p><p>This is another example of <code><a href="../xmonad-0.16.99999/XMonad-Config.html#v:manageHook" title="XMonad.Config">manageHook</a></code>, taken from
<a href="XMonad-Config-Arossato.html">XMonad.Config.Arossato</a>:</p><pre>   myManageHook  = composeAll [ resource =? &quot;realplay.bin&quot; --&gt; doFloat
                              , resource =? &quot;win&quot;          --&gt; doF (W.shift &quot;doc&quot;) -- xpdf
                              , resource =? &quot;firefox-bin&quot;  --&gt; doF (W.shift &quot;web&quot;)
                              ]
   newManageHook = myManageHook &lt;+&gt; manageHook def</pre><p>Again we use <code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:composeAll" title="XMonad.ManageHook">composeAll</a></code> to compose a list of
different <code><a href="../xmonad-0.16.99999/XMonad-Config.html#v:ManageHook" title="XMonad.Config">ManageHook</a></code>s. The first one will put
RealPlayer on the float layer, the second one will put the xpdf
windows in the workspace named &quot;doc&quot;, with <code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:doF" title="XMonad.ManageHook">doF</a></code>
and <code><a href="../xmonad-0.16.99999/XMonad-StackSet.html#v:shift" title="XMonad.StackSet">shift</a></code> functions, and the third one will put all
firefox windows on the workspace called &quot;web&quot;. Then we use the
<code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:-60--43--62-" title="XMonad.ManageHook">&lt;+&gt;</a></code> combinator to compose <code>myManageHook</code> with the
default <code><a href="../xmonad-0.16.99999/XMonad-Config.html#v:manageHook" title="XMonad.Config">manageHook</a></code> to form <code>newManageHook</code>.</p><p>Each <code><a href="../xmonad-0.16.99999/XMonad-Config.html#v:ManageHook" title="XMonad.Config">ManageHook</a></code> has the form:</p><pre>   property =? match --&gt; action</pre><p>Where <code>property</code> can be:</p><ul><li><code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:title" title="XMonad.ManageHook">title</a></code>: the window's title</li><li><code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:resource" title="XMonad.ManageHook">resource</a></code>: the resource name</li><li><code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:className" title="XMonad.ManageHook">className</a></code>: the resource class name.</li><li><code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:stringProperty" title="XMonad.ManageHook">stringProperty</a></code> <code>somestring</code>: the contents of the
  property <code>somestring</code>.</li></ul><p>(You can retrieve the needed information using the X utility named
<code>xprop</code>; for example, to find the resource class name, you can type</p><pre>xprop | grep WM_CLASS</pre><p>at a prompt, then click on the window whose resource class you want to
know.)</p><p><code>match</code> is the string that will match the property value (for instance
the one you retrieved with <code>xprop</code>).</p><p>An  <code>action</code> can be:</p><ul><li><code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:doFloat" title="XMonad.ManageHook">doFloat</a></code>: to place the window in the float layer;</li><li><code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:doIgnore" title="XMonad.ManageHook">doIgnore</a></code>: to ignore the window;</li><li><code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:doF" title="XMonad.ManageHook">doF</a></code>: to execute a function with the window as
  argument.</li></ul><p>For example, suppose we want to add a <code><a href="../xmonad-0.16.99999/XMonad-Config.html#v:manageHook" title="XMonad.Config">manageHook</a></code> to
float RealPlayer, which usually has a <code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:resource" title="XMonad.ManageHook">resource</a></code>
name of &quot;realplay.bin&quot;.</p><p>First we need to import <a href="../xmonad-0.16.99999/XMonad-ManageHook.html">XMonad.ManageHook</a>:</p><pre>   import XMonad.ManageHook</pre><p>Then we create our own <code><a href="../xmonad-0.16.99999/XMonad-Config.html#v:manageHook" title="XMonad.Config">manageHook</a></code>:</p><pre>   myManageHook = resource =? &quot;realplay.bin&quot; --&gt; doFloat</pre><p>We can now use the <code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:-60--43--62-" title="XMonad.ManageHook">&lt;+&gt;</a></code> combinator to add our
<code><a href="../xmonad-0.16.99999/XMonad-Config.html#v:manageHook" title="XMonad.Config">manageHook</a></code> to the default one:</p><pre>   newManageHook = myManageHook &lt;+&gt; manageHook def</pre><p>(Of course, if we wanted to completely replace the default
<code><a href="../xmonad-0.16.99999/XMonad-Config.html#v:manageHook" title="XMonad.Config">manageHook</a></code>, this step would not be necessary.) Now,
all we need to do is change the <code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:manageHook" title="XMonad.Core">manageHook</a></code> field of the
<code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:XConfig" title="XMonad.Core">XConfig</a></code> record, like so:</p><pre>   main = xmonad def { ..., manageHook = newManageHook, ... }</pre><p>And we are done.</p><p>Obviously, we may wish to add more then one
<code><a href="../xmonad-0.16.99999/XMonad-Config.html#v:manageHook" title="XMonad.Config">manageHook</a></code>. In this case we can use a list of hooks,
compose them all with <code><a href="../xmonad-0.16.99999/XMonad-ManageHook.html#v:composeAll" title="XMonad.ManageHook">composeAll</a></code>, and add the
composed to the default one.</p><p>For instance, if we want RealPlayer to float and thunderbird always
opened in the workspace named &quot;mail&quot;, we can do so like this:</p><pre>   myManageHook = composeAll [ resource =? &quot;realplay.bin&quot;    --&gt; doFloat
                             , resource =? &quot;thunderbird-bin&quot; --&gt; doF (W.shift &quot;mail&quot;)
                             ]</pre><p>Remember to import the module that defines the <code><a href="../xmonad-0.16.99999/XMonad-StackSet.html#v:shift" title="XMonad.StackSet">shift</a></code>
function, <a href="../xmonad-0.16.99999/XMonad-StackSet.html">XMonad.StackSet</a>, like this:</p><pre>   import qualified XMonad.StackSet as W</pre><p>And then we can add <code>myManageHook</code> to the default one to create
<code>newManageHook</code> as we did in the previous example.</p><p>One more thing to note about this system is that if
a window matches multiple rules in a <code><a href="../xmonad-0.16.99999/XMonad-Config.html#v:manageHook" title="XMonad.Config">manageHook</a></code>, <em>all</em>
of the corresponding actions will be run (in the order in which they
are defined).  This is a change from versions before 0.5, when only
the first rule that matched was run.</p><p>Finally, for additional rules and actions you can use in your
manageHook, check out the contrib module <a href="XMonad-Hooks-ManageHelpers.html">XMonad.Hooks.ManageHelpers</a>.</p></div><a href="#g:15" id="g:15"><h2>The log hook and external status bars</h2></a><div class="doc"><p><a id="The_log_hook_and_external_status_bars"></a></p><p>When the stack of the windows managed by xmonad changes for any
reason, xmonad will call <code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:logHook" title="XMonad.Core">logHook</a></code>, which can be used to
output some information about the internal state of xmonad, such as the
layout that is presently in use, the workspace we are in, the focused
window's title, and so on.</p><p>Extracting information about the internal xmonad state can be somewhat
difficult if you are not familiar with the source code. Therefore,
it's usually easiest to use a module that has been designed
specifically for logging some of the most interesting information
about the internal state of xmonad: <a href="XMonad-Hooks-DynamicLog.html">XMonad.Hooks.DynamicLog</a>.  This
module can be used with an external status bar to print the produced
logs in a convenient way; the most commonly used status bars are dzen
and xmobar. The module <a href="XMonad-Hooks-StatusBar.html">XMonad.Hooks.StatusBar</a> offers another interface
to interact with status bars, that might be more convenient to use.</p><p>By default the <code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:logHook" title="XMonad.Core">logHook</a></code> doesn't produce anything. To
enable it you need first to import <a href="XMonad-Hooks-DynamicLog.html">XMonad.Hooks.DynamicLog</a>:</p><pre>   import XMonad.Hooks.DynamicLog</pre><p>Then you just need to update the <code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:logHook" title="XMonad.Core">logHook</a></code> field of the
<code><a href="../xmonad-0.16.99999/XMonad-Core.html#v:XConfig" title="XMonad.Core">XConfig</a></code> record with one of the provided functions. For
example:</p><pre>   main = xmonad def { logHook = dynamicLog }</pre><p>More interesting configurations are also possible; see the
<a href="XMonad-Hooks-DynamicLog.html">XMonad.Hooks.DynamicLog</a> module for more possibilities.</p><p>You may now enjoy your extended xmonad experience.</p><p>Have fun!</p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.0</p></div></body></html>